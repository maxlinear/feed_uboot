# HG changeset patch
# Parent  3e819da03a138ca06015648689072db13cb3c8d7

diff --git a/scripts_platform/Kconfig b/scripts_platform/Kconfig
new file mode 100755
--- /dev/null
+++ b/scripts_platform/Kconfig
@@ -0,0 +1,1188 @@
+#
+# For a description of the syntax of this configuration file,
+# see Linux Documentation
+#
+#
+
+config IFX_UBOOT_OPTIMIZED
+      bool
+      default y
+
+config CONFIG_REMOVE_GZIP
+      bool
+    default y
+
+config CONFIG_IFX_MIPS
+      bool
+      default y
+
+config CROSS_COMPILE_UCLIBC
+      bool
+      default y
+
+config LANTIQ_UART
+	  bool
+	  default y
+          depends on !LANTIQ_UBOOT_vbg400
+
+menu "Build Options"
+
+choice
+    prompt 'Boot From'
+
+config BOOT_FROM_NOR
+    bool "NOR Flash"
+    select ENV_IS_IN_FLASH
+    depends on !DRIVER_HN1 && !DRIVER_AR10 
+    depends on !DRIVER_GRX500
+
+config BOOT_FROM_SPI
+    bool "SPI Flash"
+    select ENV_IS_IN_SPI_FLASH
+    select SPI_FLASH
+    help
+    Boots from SPI flash.
+
+config BOOT_FROM_NAND
+    bool "NAND Flash"
+    select NAND_FLASH
+    select NAND_U_BOOT
+	help
+    Boots from NAND flash.
+
+
+config BOOT_FROM_ETHERNET
+    bool "ETHERNET"
+	select ENV_IS_NOWHERE
+    help
+    Boots from ethernet port.
+    depends on !DRIVER_HN1
+	
+config BOOT_FROM_UART
+    bool "UART"
+    select ENV_IS_IN_FLASH
+    help
+    Boots from asc port.
+	depends on !DRIVER_HN1
+
+config BOOT_WITH_NO_FLASH
+    bool "NO FLASH"
+    select ENV_IS_NOWHERE
+    depends on !DRIVER_HN1
+
+endchoice
+
+config ENV_IS_NOWHERE
+    bool 
+	default n
+
+config ENV_IS_IN_FLASH
+    bool
+
+config ENV_IS_IN_SPI_FLASH
+    bool
+
+config ENV_IS_IN_NAND
+    bool
+	default y
+	depends on BOOT_FROM_NAND && !ENV_IS_NOWHERE
+
+config ENV_IS_NOWHERE
+    bool
+
+config NAND_U_BOOT
+    bool
+
+config SPI_WITH_NAND
+	bool
+
+config RAM_TEXT_BASE
+    hex  
+	default "0xA0400000"
+
+config BOOTSTRAP_TEXT_BASE
+    hex 
+    default "0x80200000" if ( LANTIQ_UBOOT_grx500 )
+    default "0x80100000" if ( BOOT_FROM_NAND )
+    default "0xB0000000" if ( BOOT_FROM_NOR )
+    default "0xa0100000" if ( BOOT_FROM_SPI && !LANTIQ_UBOOT_vbg400 )
+    default "0xA0800000" if ( LANTIQ_UBOOT_vbg400 )
+
+config NAND_PRELOAD_TEXT_BASE
+	hex
+	default "0xbe1a0000" if LANTIQ_UBOOT_ar9
+	default "0xbe220000" if LANTIQ_UBOOT_vr9
+	default "0xbf280000" if LANTIQ_UBOOT_hn1
+	default "0xbe1a0000" if LANTIQ_UBOOT_ar10
+        default "0xa0010000" if LANTIQ_UBOOT_grx500
+
+config NAND_SPL_TEXT_BASE
+    hex  
+	default "0xBE1a0400"  if LANTIQ_UBOOT_ar9
+        default "0xBE220400"  if ( LANTIQ_UBOOT_vr9 && NAND_PRELOAD )
+	default "0xbe220000"  if ( LANTIQ_UBOOT_vr9 && !NAND_PRELOAD )
+        default "0xBF280400"  if LANTIQ_UBOOT_hn1
+	default "0xBE1A0000"  if LANTIQ_UBOOT_ar10 
+	default "0xa0001000"  if LANTIQ_UBOOT_grx500
+        depends on BOOT_FROM_NAND
+
+config SFDDR_TEXT_BASE
+	hex 
+	default "0xbe1a0000" if LANTIQ_UBOOT_ar9
+	default "0xbe220500" if LANTIQ_UBOOT_vr9
+	default "0xbf280500" if LANTIQ_UBOOT_hn1
+	default "0xa0001000" if LANTIQ_UBOOT_grx500
+    depends on BOOT_FROM_SPI
+
+choice
+     prompt "OS COMPRESSION TYPE"
+     default OS_LZMA
+
+config OS_GZIP
+     bool "GZIP"
+
+config OS_LZMA
+     bool "LZMA"
+
+config OS_LZO
+     bool "LZO"
+
+config OS_BZIP2
+     bool "BZIP2"
+
+endchoice
+						   
+
+config LTQ_SECURE_BOOT
+	bool "SECURE BOOT"
+	default n
+	depends on DRIVER_VR9 || DRIVER_AR10 || DRIVER_GRX500 
+        depends on !BOOT_FROM_NOR
+
+config AES_KEY
+        string "stage1 aes key"
+	default "0000000000000000000000000000000000000000000000000000000000000000"
+	depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10 
+
+config STAGE2_AES_KEY
+        string "stage2 aes key"
+        default "0000000000000000000000000000000000000000000000000000000000000000"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config STAGE2_AES_IV
+	string
+	default "00000000000000000000000000000000"
+	depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config STAGE2_AES_IV
+	string
+	default "00000000000000000000000000000000"
+	depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10 
+
+config ENCRYPT_STAGE3
+        bool "encypt stage3 image"
+	default n
+	depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config STAGE3_AES_KEY
+        string "stage3 aes key"
+        default "0000000000000000000000000000000000000000000000000000000000000000"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config DSA_KEY_AUTO
+	bool "generate a new DSA key"
+	default y
+	depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config DSA_PRIVKEY
+        string "dsa private key"
+	default "privkey.pem"
+	depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config DSA_PUBKEY
+        string "dsa public key"
+        default "pubkey.pem"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config STAGE2_LOADADDR
+        hex "stage2 load address"
+	default "0x80400000"
+	depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config STAGE2_SIZE
+        hex "stage2 size"
+	default "0x19000"
+	depends on LTQ_SECURE_BOOT
+        depends on DRIVER_VR9 || DRIVER_AR10
+
+config MANUBOOT
+        bool "Manufacturing Boot ( Root Of Trust Transfer )"
+        default n
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+
+config SIGNTOOL
+        string "signtool path"
+        default "signtool"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+
+config PROD_UNIQUE_KEY
+        string "product unique key(path)"
+        default "CRkey.bin"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+
+config PRIVATE_KEY
+        string "private key(path)"
+        default "privatekey.der"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+
+config CERTIFICATION_SUPPORT
+        bool "Certification Support"
+        default y
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+
+config CERTIFICATION
+        string "certification(path)"
+        default "cert.bin"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+        depends on CERTIFICATION_SUPPORT
+
+config MANUBOOT_CREDENTIAL_SUPPORT
+        bool "Manufacturing Boot Credential Support"
+        default n
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+        depends on MANUBOOT
+
+config MANUBOOT_CREDENTIAL
+        string "Manufacturing Boot Credential(path)"
+        default "cred.bin"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+        depends on MANUBOOT
+        depends on MANUBOOT_CREDENTIAL_SUPPORT
+
+config MANUBOOT_OTP_SUPPORT
+        bool "Manufacturing Boot OTP Programming Support"
+        default n
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+        depends on MANUBOOT
+        select CMD_ROT
+
+config MANUBOOT_OTP
+        string "Manufacturing Boot OTP binary(path)"
+        default "otp.bin"
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+        depends on MANUBOOT
+        depends on MANUBOOT_OTP_SUPPORT
+
+config LTQ_EIP123_IAP_ACCESS
+        bool "EIP-123 InterAptiv Access (for Secure EJTAG)"
+        default n
+        depends on LTQ_SECURE_BOOT
+        depends on DRIVER_GRX500
+
+config USE_DEFAULT_PREBOOT
+    bool "use default preboot command" 
+    default y
+
+config PREBOOT
+    string "pre-boot command"
+    default "echo;echo run \"flash_flash\" to bring up the kernel;echo;"
+	depends on !USE_DEFAULT_PREBOOT
+
+config AUTOBOOT_KEYED
+    bool "AUTOBOOT KEYED"
+	default n
+
+config AUTOBOOT_DELAY_STR
+    string "AUTOBOOT PASSWORD"
+    default ""
+    depends on AUTOBOOT_KEYED
+
+config SILENT_CONSOLE
+    bool "Silent console support"
+	default n
+
+config SUPPRESS_KERNEL_OUTPUT
+    bool "suppress kernel output"
+	default n
+	depends on SILENT_CONSOLE
+
+config VENDOR_NAME
+    string 
+	default "LANTIQ"
+	depends on LTQ_IMAGE_EXTRA_CHECKS
+
+config SW_VERSION
+    string 
+	default "4.2.0"
+	depends on LTQ_IMAGE_EXTRA_CHECKS
+
+config DEBUG
+    bool "VERBOSE"
+	default n
+
+endmenu
+
+menu "Board Settings"
+
+config IFX_MEMORY_SIZE
+        int "RAM Size(M)"
+        default 32
+
+config BAUDRATE
+  int "ASC BAUDRATE"
+  default 115200
+
+config NOR_FLASH
+        bool "NOR FLASH SUPPORT"
+        default y
+        select CMD_FLASH
+        depends on !DRIVER_AR10 && !DRIVER_HN1
+
+config SYS_NO_FLASH
+       bool
+	   default y
+	   depends on !NOR_FLASH
+
+config FLASH_CFI_DRIVER
+       bool
+	   default y
+	   depends on NOR_FLASH
+
+config SYS_FLASH_CFI
+       bool
+	   default y
+	   depends on NOR_FLASH
+
+config FLASH_CFI_MTD
+	   bool "MTD SUPPORT"
+	   default n
+	   depends on NOR_FLASH
+
+choice
+     prompt "NOR Flash Size(M)"
+     depends on BOOT_FROM_NOR
+     default NOR_FLASH_8M
+
+config NOR_FLASH_8M
+     bool "8M"
+
+config NOR_FLASH_4M
+     bool "4M"
+
+config NOR_FLASH_2M
+     bool "2M"
+
+config NOR_FLASH_AUTO
+     bool "auto detect"
+
+endchoice
+
+
+config SPI_FLASH
+      bool "SPI FLASH SUPPORT"
+        select LANTIQ_SPI
+      select CMD_SF
+
+choice
+     prompt "SPI Flash Size(M)"
+	 depends on BOOT_FROM_SPI
+	 default SPI_FLASH_4M
+
+config SPI_FLASH_16M
+     bool "16M"
+
+config SPI_FLASH_8M
+     bool "8M"
+
+config SPI_FLASH_4M
+     bool "4M"
+
+config SPI_FLASH_2M
+     bool "2M"
+
+config SPI_FLASH_1M
+     bool "1M"
+
+endchoice
+							  
+
+config SPI_FLASH_ATMEL
+        bool "ATMEL SFLASH SUPPORT"
+    depends on SPI_FLASH
+
+config SPI_FLASH_STMICRO
+        bool  "STMICRO SFLASH SUPPORT"
+    depends on SPI_FLASH
+
+config SPI_FLASH_SST
+        bool "SST SFLASH SUPPORT"
+        depends on SPI_FLASH
+
+config SPI_FLASH_SPANSION
+        bool "SPANSION SFLASH SUPPORT"
+    depends on SPI_FLASH
+
+config SPI_FLASH_MXIC
+        bool "MXIC SFLASH SUPPORT"
+    depends on SPI_FLASH
+
+config SPI_FLASH_WINBOND
+   bool "WINBOND SFLASH SUPPORT"
+   depends on SPI_FLASH
+
+config LANTIQ_SPI
+        bool
+
+config  SF_DEFAULT_SPEED
+        int "SPI FLASH BAUDRATE(Hz)"
+    default "1000000"
+        depends on SPI_FLASH
+
+config SF_DEFAULT_MODE
+        int "SFLASH SPI MODE"
+    default "0"
+    depends on LANTIQ_SPI
+
+config SPI_EEPROM
+        bool "SPI EEPROM SUPPORT"
+    select CMD_EEPROM
+    select LANTIQ_SPI
+    select SPI_EEPROM_ATMEL
+
+
+config SPI_EEPROM_ATMEL
+        bool "ATMEL 250X0 SUPPORT"
+        depends on SPI_EEPROM
+
+
+config  EEPROM_DEFAULT_SPEED
+        int "EEPROM BAUDRATE(Hz)"
+    default "1000000"
+    depends on SPI_EEPROM
+
+config  EEPROM_DEFAULT_MODE
+        int "EEPROM SPI MODE"
+        default "0"
+        depends on SPI_EEPROM
+
+
+config NAND_FLASH
+      bool "NAND FLASH_SUPPORT"
+      select CMD_NAND
+      select SPI_WITH_NAND if BOOT_FROM_SPI
+
+choice
+      prompt "NAND TYPE"
+      default NAND_LANTIQ
+      depends on NAND_FLASH
+
+config NAND_LANTIQ
+       bool "EBU NAND"
+
+config SPINAND_LANTIQ
+       bool "SPI NAND"
+       depends on LANTIQ_SPI
+endchoice
+
+config GIGA_DEVICE_SPINAND
+       bool "GIGADEVICE SPI NAND"
+       depends on SPINAND_LANTIQ
+
+choice 
+      prompt "ECC MODE"
+	  depends on NAND_FLASH
+	  default NAND_ECC_SOFT
+
+config NAND_ECC_SOFT
+       bool "SOFTWARE HAMMING"
+
+config NAND_ECC_BCH
+       bool "SOFTWARE BCH"
+       select BCH
+
+config NAND_ECC_HW_REED_SOLOMON
+       bool "HARDWARE REED SOLOMON"
+
+config NAND_BENAND
+	   bool "BENAND Flash Boot"
+	   select BENAND
+
+endchoice
+
+
+choice 
+	prompt "BCH ECC Strength configuration"
+        depends on NAND_ECC_BCH
+        depends on DRIVER_GRX500
+
+config BCH_4BITS
+	bool "Support for 4-bits/512bytes BCH"
+
+config BCH_8BITS
+	bool "Support for 8-bits/512bytes BCH"
+
+endchoice
+
+config BCH_CONT_T
+	int
+	depends on NAND_ECC_BCH
+        depends on DRIVER_GRX500
+        default "7" if ( BCH_4BITS )
+	default "13" if ( BCH_8BITS )
+
+config SPL_OOBSIZE
+	int "NAND Flash OOB Size"
+        depends on NAND_ECC_BCH
+        depends on DRIVER_GRX500
+	default "64" if ( NAND_PAGE_SIZE = 0x800) 
+	default "448" if ( NAND_PAGE_SIZE = 0x2000)
+
+
+
+
+choice 
+     prompt "ECC LOCATION"
+     depends on NAND_ECC_HW_REED_SOLOMON
+     default NAND_HW_ECC_SPARE_AREA
+
+config NAND_HW_ECC_SPARE_AREA
+      bool "ECC IN OOB AREA"
+
+config NAND_HW_ECC_EMBEDDED
+      bool "ECC EMBEDDED IN DATA AREA"
+	  
+endchoice
+
+choice
+     prompt "ECC LENGTH"
+     depends on NAND_ECC_HW_REED_SOLOMON
+	 default NAND_ECC_HW_4BYTES
+
+config NAND_ECC_HW_4BYTES
+     bool "4 bytes"
+
+config NAND_ECC_HW_3BYTES
+     bool "3 bytes"
+
+endchoice
+
+
+config MLC_NAND_HEADER_NUMBER
+      int "MLC NAND HEADER NUMBER"
+	  default 1
+	  depends on BOOT_FROM_NAND && NAND_ECC_HW_REED_SOLOMON
+
+config NAND_ECC_HW
+	  bool
+	  depends on NAND_ECC_HW_HAMMING || NAND_ECC_HW_REED_SOLOMON
+	  default y
+
+config NAND_BBT_SCAN
+        bool "BAD NAND BLOCK SCAN"
+        depends on NAND_FLASH
+
+config NAND_LANTIQ
+       bool
+       depends on NAND_FLASH
+
+if LANTIQ_UBOOT_ar10 
+config NAND_CS0
+       bool "NAND FLASH ON CS0"
+	   default n
+	   depends on NAND_FLASH 
+endif 
+
+choice
+     prompt "NAND Flash Size(M)"
+	 depends on BOOT_FROM_NAND
+	 default NAND_FLASH_4M
+
+config NAND_FLASH_8192M
+	 bool "8192M" 
+
+config NAND_FLASH_4096M
+	 bool "4096M" 
+
+config NAND_FLASH_2048M
+     bool "2048M"
+
+config NAND_FLASH_1024M
+     bool "1024M"
+
+config NAND_FLASH_512M
+     bool "512M"
+
+config NAND_FLASH_256M
+     bool "256M"
+
+config NAND_FLASH_128M
+     bool "128M"
+
+config NAND_FLASH_64M
+     bool "64M"
+
+config NAND_FLASH_32M
+     bool "32M"
+
+config NAND_FLASH_8M
+     bool "8M"
+
+config NAND_FLASH_4M
+     bool "4M"
+
+config NAND_FLASH_2M
+     bool "2M"
+
+endchoice
+
+
+config NAND_FLASH_SIZE
+    int 
+	default "2" if ( NAND_FLASH_2M )
+	default "4" if ( NAND_FLASH_4M )
+	default "8" if ( NAND_FLASH_8M )
+	default "32" if ( NAND_FLASH_32M )
+	default "64" if ( NAND_FLASH_64M )
+	default "128" if ( NAND_FLASH_128M )
+	default "256" if ( NAND_FLASH_256M )
+	default "512" if ( NAND_FLASH_512M )
+	default "1024" if ( NAND_FLASH_1024M )
+	default "2048" if ( NAND_FLASH_2048M )
+	default "4096" if ( NAND_FLASH_4096M )
+	default "8192" if ( NAND_FLASH_8192M )
+	
+config NAND_PAGE_SIZE
+     hex "NAND flash page size(bytes in hex)"
+     default "0x200"
+     depends on BOOT_FROM_NAND
+
+config NAND_BLOCK_SIZE
+	 hex "NAND flash erase block size(bytes in hex)"
+	 default "0x40000"
+	 depends on BOOT_FROM_NAND
+
+config NAND_SPL_BLOCK_SIZE
+     hex "NAND SPL IMAGE SIZE(bytes in hex)"
+	 default "0x4000"
+	 depends on BOOT_FROM_NAND && (!NAND_ECC_HW_REED_SOLOMON || DRIVER_GRX500)
+
+config NAND_PRELOAD
+     bool "nand mini loader"
+	 default n
+	 depends on BOOT_FROM_NAND && !NAND_ECC_HW_REED_SOLOMON
+
+config NAND_SPL_BBT
+	 bool "nand spl bbt support"
+	 default n
+	 depends on BOOT_FROM_NAND && !NAND_ECC_HW_REED_SOLOMON
+
+config FIRMWARE_IN_ROOTFS
+     bool "firmware in rootfs"
+     default n
+
+config OVERLAY
+	 bool "overlay fs support"
+	 default n
+	 depends on DRIVER_VR9 || DRIVER_AR9 || DRIVER_DANUBE
+
+config LTQ_I2C
+	bool "I2C access support"
+	default n
+	depends on DRIVER_GRX500
+	select CMD_I2C 
+
+if LANTIQ_UBOOT_ar9
+   source board/ar9/Kconfig
+endif
+
+if LANTIQ_UBOOT_danube
+   source board/danube/Kconfig
+endif
+
+if LANTIQ_UBOOT_amazon_se
+   source board/amazon_se/Kconfig
+endif
+
+if LANTIQ_UBOOT_vr9
+   source board/vr9/Kconfig
+endif
+
+if LANTIQ_UBOOT_hn1
+   source board/hn1/Kconfig
+endif
+
+if LANTIQ_UBOOT_ar10 
+   source board/ar10/Kconfig
+endif
+
+if LANTIQ_UBOOT_vbg400
+   source board/vbg400/Kconfig
+endif
+
+if LANTIQ_UBOOT_grx500
+   source board/grx500/Kconfig
+endif
+
+endmenu
+
+
+menu "Network Settings"
+config IP_ADDRESS
+    string "IP address"
+    default "192.168.1.1"
+
+config SERVER_IP_ADDRESS
+    string "Server IP address"
+    default "192.168.1.2"
+
+config ETHERNET_ADDRESS
+    string "Ethernet Address"
+    default "00:E0:92:00:01:40"
+
+config ETHERNET_DEVICE
+    string "Ethernet Interface"
+    default "eth0"
+endmenu
+
+menu "Environment Settings"
+
+config ENV_SIZE
+	hex "env size"
+	default "0x4000"
+	#depends on BOOT_FROM_NAND
+
+config ENV_REDUND
+    bool "redundant env"
+	default no
+
+config ENV_OVERWRITE
+	bool "enable env overwrite"
+	default y
+
+config BUILD_ENV_BLOCK
+    bool "build env block image"
+	default n
+
+config TFTP_LOAD_ADDRESS
+    string "tftp load address"
+    default "0x80800000"
+    
+config MEM
+    string "mem"
+    default "31M"
+
+config PHYM
+    string "phym"
+    default "32M"
+
+config WLANM
+    string "wlanm"
+	default "30M"
+	depends on DRIVER_AR10
+
+config BOOTDELAY
+    int "BOOTDELAY(seconds)"
+	default 5
+
+config ROOT_PATH
+    string "rootpath"
+    default "/mnt/full_fs"
+
+
+config CONSOLE
+    string "console"
+	default "ttyS0" if ( LANTIQ_UBOOT_vbg400 )
+	default "ttyS1" if ( !LANTIQ_UBOOT_vbg400 )
+
+config TFTPPATH
+    string "tftppath"
+	default ""
+
+config ROOTFSMTD
+    string "rootfsmtd" 
+	default "/dev/mtdblock1" if ( FIRMWARE_IN_ROOTFS && !BOOT_FROM_NAND )
+	default "/dev/mtdblock2" if ( !FIRMWARE_IN_ROOTFS && !BOOT_FROM_NAND && !LANTIQ_UBOOT_hn1)
+	default "/dev/mtdblock3" if ( !FIRMWARE_IN_ROOTFS && !BOOT_FROM_NAND && LANTIQ_UBOOT_hn1)
+	default "/dev/mtdblock2" if ( FIRMWARE_IN_ROOTFS && BOOT_FROM_NAND )
+	default "/dev/mtdblock3" if ( !FIRMWARE_IN_ROOTFS && BOOT_FROM_NAND )
+
+config NFSARGS
+    string "nfsargs"
+    default "setenv bootargs root=/dev/nfs rw nfsroot=$(serverip):$(rootpath)"
+
+config RAMARGS
+    string "ramargs"
+    default "setenv bootargs root=/dev/ram rw"
+
+config FLASHARGS
+    string "flashargs"
+    default "setenv bootargs root=$(rootfsmtd) ro rootfstype=squashfs init=/etc/preinit"
+
+config ADDIP
+    string "addip"
+    default "setenv bootargs $(bootargs) ip=$(ipaddr):$(serverip):$(gatewayip):$(netmask):$(hostname):$(netdev):on"
+
+config ADDMISC
+    string "addmisc"
+	default "setenv bootargs $(bootargs) console=$(console),$(baudrate) ethaddr=$(ethaddr) phym=$(phym) mem=$(mem) panic=1 mtdparts=$(mtdparts)" 
+
+config BOOTFILE
+    string "bootfile"
+    default "uImage"
+
+config BOOT_CORE
+	string "bootcore"
+	default "bootcore"
+
+config U_BOOT
+    string "u-boot"
+    default "u-boot.ltq"
+
+config ROOTFS
+    string "rootfs"
+    default "rootfs.img"
+
+config FIRMWARE
+    string "firmware"
+    default "firmware.img"
+
+config FULLIMAGE
+    string "fullimage"
+	default "fullimage.img"
+
+config TOTALIMAGE
+    string "totalimage"
+	default "totalimage.img"
+
+config MTDIDS
+    string "mtdids"
+	default "nand0=ifx_nand"
+	depends on CMD_MTDPARTS 
+
+
+config USE_DEFAULT_MTDPARTS
+    bool "use default MTDPARTS"
+	default y
+
+
+if LANTIQ_UBOOT_danube
+config MTDPARTS
+    string
+	default "ifx_nor0:64k(uboot),256k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS && !OVERLAY )
+  default "ifx_nor0:64k(uboot),256k(firmware),7424k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS && OVERLAY )
+  default "ifx_nor0:64k(uboot),8000k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS && !OVERLAY)
+  default "ifx_nor0:64k(uboot),7680k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS && OVERLAY )
+	default "ifx_nor0:64k(uboot),-(rootfs)" if ( BOOT_FROM_UART )
+	default "" if ( NOR_FLASH_AUTO )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+if LANTIQ_UBOOT_amazon_se
+config MTDPARTS
+    string
+    default "ifx_nor0:64k(uboot),3904k(rootfs),32k(sysconfig),4k(ubootconfig),4k(fwdiag),-(res)" if ( BOOT_FROM_NOR && NOR_FLASH_4M && FIRMWARE_IN_ROOTFS )  
+    default "ifx_nor0:64k(uboot),192k(firmware),3796k(rootfs),32k(sysconfig),4k(ubootconfig),4k(fwdiag),-(res)" if ( BOOT_FROM_NOR && NOR_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),256k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),8000k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),3904k(rootfs),32k(sysconfig),4k(ubootconfig),4k(fwdiag),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_4M && FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),192k(firmware),3796k(rootfs),32k(sysconfig),4k(ubootconfig),4k(fwdiag),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64kk(uboot),192k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_SPI && SPI_FLASH_8M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),-(rootfs)" if ( BOOT_FROM_SPI && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:64k(uboot),-(rootfs)" if ( BOOT_FROM_NAND && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:64k(uboot),192k(firmware),-(rootfs)" if ( BOOT_FROM_NAND && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),-(rootfs)" if ( BOOT_FROM_UART )
+	default "" if ( NOR_FLASH_AUTO )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+if LANTIQ_UBOOT_vbg400
+config MTDPARTS
+    string
+	default "ifx_sflash:64k(uboot),3904k(rootfs),64k(sysconfig),8k(ubootconfig),8k(wlanconfig),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_4M && FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),8000k(rootfs),64k(sysconfig),8k(ubootconfig),8k(wlanconfig),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_8M && FIRMWARE_IN_ROOTFS )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+if LANTIQ_UBOOT_ar9
+config MTDPARTS
+    string
+	default "ifx_nor0:64k(uboot),192k(firmware),-(rootfs)" if ( BOOT_FROM_NOR && NOR_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),3904k(rootfs),32k(sysconfig),4k(ubootconfig),-(res)" if ( BOOT_FROM_SPI && SPI_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),256k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS && !OVERLAY )
+  default "ifx_nor0:64k(uboot),256k(firmware),7424k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M  && !FIRMWARE_IN_ROOTFS && OVERLAY )
+  default "ifx_nor0:64k(uboot),8000k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS && !OVERLAY )
+  default "ifx_nor0:64k(uboot),7680k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && NOR_FLASH_8M && FIRMWARE_IN_ROOTFS && OVERLAY )
+  default "ifx_sflash:128k(uboot),192k(firmware),-(rootfs)" if ( BOOT_FROM_SPI && SPI_FLASH_1M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:128k(uboot),192k(firmware),7744k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_SPI && SPI_FLASH_8M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:128k(uboot),-(rootfs)" if ( BOOT_FROM_SPI && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:128k(uboot),2688k(kernel),28800k(rootfs),64k(sysconfig),16k(ubootconfig),16k(fwdiag),-(res)" if ( BOOT_FROM_NAND && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:128k(uboot),192k(firmware),-(rootfs)" if ( BOOT_FROM_NAND && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:64k(uboot),-(rootfs)" if ( BOOT_FROM_UART )
+	default "" if ( NOR_FLASH_AUTO )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+
+
+if LANTIQ_UBOOT_vr9
+config MTDPARTS
+    string 
+	default "ifx_nor0:128k(uboot),7936k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && FIRMWARE_IN_ROOTFS && !OVERLAY )
+	default "ifx_nor0:128k(uboot),7616k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && FIRMWARE_IN_ROOTFS && OVERLAY )
+	default "ifx_nor0:128k(uboot),512k(firmware),7424k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && !FIRMWARE_IN_ROOTFS && !OVERLAY )
+	default "ifx_nor0:128k(uboot),512k(firmware),7104k(rootfs),320k(overlay),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_NOR && !FIRMWARE_IN_ROOTFS && OVERLAY )
+	default "ifx_sflash:128k(uboot),512k(firmware),-(rootfs)" if ( SPI_FLASH_4M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:128k(uboot),512k(firmware),7424k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( SPI_FLASH_8M && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:128k(uboot),7936k(rootfs),64k(sysconfig),64k(ubootconfig)" if ( BOOT_FROM_SPI && FIRMWARE_IN_ROOTFS )
+  default "ifx_nand:256k(uboot),2560k(kernel),111872k(rootfs),256k(sysconfig),256k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:256k(uboot),512k(firmware),2m(kernel),111872k(rootfs),256k(sysconfig),256k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && !FIRMWARE_IN_ROOTFS )
+	default "ifx_nor0:128k(uboot),-(rootfs)" if ( BOOT_FROM_UART )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+
+if LANTIQ_UBOOT_hn1
+config MTDPARTS
+    string 
+	default "ifx_sflash:64k(uboot),64k(gphyfirmware),512k(firmware),-(rootfs)" if ( BOOT_FROM_SPI && !FIRMWARE_IN_ROOTFS )
+	default "ifx_sflash:64k(uboot),64k(gphyfirmware),-(rootfs)" if ( BOOT_FROM_SPI && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:192k(uboot),64k(gphyfirmware),2560k(kernel),111872k(rootfs),256k(sysconfig),4k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && NAND_FLASH_128M && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:192k(uboot),64k(gphyfirmware),512k(firmware),2m(kernel),111872k(rootfs),256k(sysconfig),4k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && NAND_FLASH_128M && !FIRMWARE_IN_ROOTFS )	
+	default "ifx_nand:192k(uboot),64k(gphyfirmware),2560k(kernel),505088k(rootfs),256k(sysconfig),4k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && NAND_FLASH_512M && FIRMWARE_IN_ROOTFS )
+	default "ifx_nand:192k(uboot),64k(gphyfirmware),512k(firmware),2048k(kernel),505088k(rootfs),256k(sysconfig),4k(ubootconfig),256k(fwdiag),-(res)" if ( BOOT_FROM_NAND && NAND_FLASH_512M && !FIRMWARE_IN_ROOTFS )
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+
+if LANTIQ_UBOOT_ar10 
+config MTDPARTS
+    string 
+    default "ifx_nand:64k(uboot),-(rootfs)"
+	depends on USE_DEFAULT_MTDPARTS
+endif
+
+if LANTIQ_UBOOT_grx500
+config MTDPARTS
+    string
+    default "ifx_nand:64k(uboot),-(rootfs)"
+    depends on USE_DEFAULT_MTDPARTS
+endif
+
+
+config MTDPARTS
+    string "MTDPARTS"
+	default "ifx_nor0:64k(uboot),-(rootfs)"
+	depends on !USE_DEFAULT_MTDPARTS
+
+if LANTIQ_UBOOT_vbg400
+config UPDATE_TFTP_NFS
+	string "update_tftp_nfs"
+	default "setenv bootcmd run tftp_nfs;saveenv"
+
+config TFTP_NFS
+	string "tftp_nfs"
+	default "tftpboot $(loadaddr) uimage.unc;run nfsargs addip addmisc;bootm $(loadaddr)"
+
+config UPDATE_TFTP_FLASH
+	string "update_tftp_flash"
+	default "run update_rootfs;setenv bootcmd run tftp_flash;saveenv"
+
+config TFTP_FLASH
+	string "tftp_flash"
+	default "tftpboot $(loadaddr) uimage.unc;run flashargs addip addmisc;bootm $(loadaddr)"
+	
+config UPDATE_FLASH_FLASH
+	string "update_flash_flash"
+	default "run update_fullimage;setenv bootcmd run flash_flash;saveenv"
+
+config UPDATE_FLASH_NFS
+	string "update_flash_nfs"
+	default "set bootfile uImage.unc;run update_kernel;setenv bootcmd run flash_nfs;saveenv"
+
+config FLASH_NFS
+	string "flash_nfs"
+	default "run nfsargs addip addmisc;bootm $(loadaddr)"
+endif
+
+config NET_RAM
+    string "net_ram"
+    default "tftp $(loadaddr) $(tftppath)$(bootfile); run ramargs addip addmisc; bootm"
+
+config NET_FLASH
+    string "net_flash"
+    default "tftp $(loadaddr) $(tftppath)$(bootfile); run flashargs addip addmisc; bootm"
+
+config FLASH_NFS
+    string "flash_nfs"
+    default "run nfsargs addip addmisc;bootm $(kernel_addr)"
+
+config NET_NFS
+    string "net_nfs"
+    default "tftp $(loadaddr) $(tftppath)$(bootfile);run nfsargs addip addmisc;bootm"
+
+config FLASH_FLASH
+    string "flash_flash"
+    default "run flashargs addip addmisc; bootm $(kernel_addr)"
+
+config UPDATE_NANDBOOT
+    string "update_nandboot"
+	default "tftp $(loadaddr) $(tftppath)u-boot-nand.bin; nand erase clean 0 0x08000000; nand write $(loadaddr) 0 $(filesize)"
+#	depends on BOOT_FROM_NAND
+
+config UPDATE_UBOOT
+    string "update_uboot"
+    default "tftpboot $(loadaddr) $(tftppath)$(u-boot);erase b0000000 b001ffff;cp.b $(loadaddr) b0000000 $(filesize);reset"
+
+config UPDATE_BOOTLOADER
+    string "update_bootloader"
+	default "update_uboot" if LANTIQ_UBOOT_ar9 
+	default "update_uboot;update gphyfirmware" if LANTIQ_UBOOT_vr9 
+	default "update_uboot;update gphyfirmware" if LANTIQ_UBOOT_ar10 
+	default "update_uboot"
+
+config UPDATE_KERNEL
+    string "update_kernel"
+    default "tftpboot $(loadaddr) $(tftppath)$(bootfile);upgrade $(loadaddr) $(filesize)"
+
+config UPDATE_ROOTFS
+    string "update_rootfs"
+    default "tftpboot $(loadaddr) $(tftppath)$(rootfs); upgrade $(loadaddr) $(filesize)"
+
+config UPDATE_FIRMWARE
+    string "update_firmware"
+    default "tftpboot $(loadaddr) $(tftppath)$(firmware);upgrade $(loadaddr) $(filesize)"
+    depends on !FIRMWARE_IN_ROOTFS
+
+config UPDATE_GPHYFIRMWARE
+    string "update_gphyfirmware"
+	default "tftpboot $(loadaddr) $(tftppath)gphy_firmware.img;nand write.partial $(loadaddr) 24000 10000" if ( !VR9_GPHY_FW_EMBEDDED )
+	default "tftpboot $(loadaddr) $(tftppath)gphy_firmware.img; sf probe 3; sf erase 0x10000 0x10000; sf write $(loadaddr) 0x10000 $(filesize)" if ( LANTIQ_UBOOT_hn1 && !HN1_GPHY_FW_EMBEDDED && BOOT_FROM_SPI)
+	default "tftpboot $(loadaddr) $(tftppath)gphy_firmware.img; nand write.partial $(loadaddr) 0x24000 10000" if ( LANTIQ_UBOOT_hn1 && !HN1_GPHY_FW_EMBEDDED && BOOT_FROM_NAND)
+	depends on !VR9_GPHY_FW_EMBEDDED && !HN1_GPHY_FW_EMBEDDED && !AR10_GPHY_FW_EMBEDDED
+
+config UPDATE_FULLIMAGE
+    string "update_fullimage"
+	default "tftpboot $(loadaddr) $(tftppath)$(fullimage);upgrade $(loadaddr) $(filesize)"
+
+config UPDATE_TOTALIMAGE
+    string "update_totalimage"
+	default "tftpboot $(loadaddr) $(tftppath)$(totalimage);upgrade $(loadaddr) $(filesize)"
+
+if LANTIQ_UBOOT_grx500
+config UPDATE_BOOTCORE
+    string "update_bootcore"
+    default "tftpboot $(loadaddr) $(tftppath)$(bootcore);nand erase 200000 40000;nand write $(loadaddr) 200000 40000"
+
+config RUN_BOOTCORE
+	string "run_bootcore"
+	default "nand read 0xA0400000 $(tftppath)$(bootcore);secboot load_os 0x8E000000 0xA0400000 0x200000"
+
+endif
+
+config UBI_INIT
+  string "ubi_init"
+	default "ubi part data;setenv kernelA_vol_id 0;setenv rootfsA_vol_id 1;setenv firmwareA_vol_id 2;setenv kernelB_vol_id 3;setenv rootfsB_vol_id 4;setenv firmwareB_vol_id 5;i setenv bootcoreA_vol_id 6; bootcoreB_vol_id 7; setenv setbank check_image$(update_chk);run $(setbank)"
+	depends on CMD_UBI 
+
+config DUAL_IMAGE
+  bool "dual image support"
+  default n
+  #depends on BOOT_FROM_NAND
+ 
+config UPDATE_CHK
+  string "update_chk"
+  default "0"
+  depends on DUAL_IMAGE
+ 
+config SWITCH_BANKA
+  string "switchbankA"
+  default "setenv active_bank A;setenv kernel_vol kernelA_vol;setenv rootfs_vol rootfsA_vol;setenv firmware_vol firmwareA_vol;setenv rootfsmtd /dev/mtdblock5"  
+  depends on DUAL_IMAGE
+
+config SWITCH_BANKB
+  string "switchbankB"
+  default "setenv active_bank B;setenv kernel_vol kernelB_vol;setenv rootfs_vol rootfsB_vol;setenv firmware_vol firmwareB_vol;setenv rootfsmtd /dev/mtdblock7"
+  depends on DUAL_IMAGE
+
+config CHECK_IMAGE0
+  string "check_image0"
+  default "run switchbankA"
+  depends on DUAL_IMAGE
+  
+config CHECK_IMAGE1
+  string "check_image1"
+  default "run switchbankB;setenv update_chk 0;save"
+  depends on DUAL_IMAGE
+  
+config CHECK_IMAGE2
+  string "check_image2"
+  default "run switchbankB"
+  depends on DUAL_IMAGE
+  
+config CHECK_IMAGE3
+  string "check_image3"
+  default "run switchbankA;setenv update_chk 2;save"
+  depends on DUAL_IMAGE
+      
+config BOOTCOMMAND
+    string "bootcmd"
+	default "run flash_flash"
+
+config RESET_UBOOT_CONFIG
+	string "reset_uboot_config"
+	default "prot off $(f_ubootconfig_addr) $(f_ubootconfig_end); erase $(f_ubootconfig_addr) $(f_ubootconfig_end)" if ( BOOT_FROM_NOR )
+	default "sf probe 3; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_ar9 ) 
+	default "sf probe 0; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_amazon_se )
+	default "sf probe 3; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_vr9 )
+	default "sf probe 3; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_hn1 )
+	default "sf probe 0; sf write A0400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_vbg400 )
+        default "sf probe 0; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_ar10 )
+	default "sf probe 1; sf write 80400000 $(f_ubootconfig_addr) $(f_ubootconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_grx500 )
+        default "nand erase $(f_ubootconfig_addr) $(f_ubootconfig_range)" if ( BOOT_FROM_NAND && !ENV_REDUND)
+	default "nand erase $(f_ubootconfig_addr) $(f_ubootconfig_range);nand erase $(f_red_ubootconfig_addr) $(f_ubootconfig_range);" if ( BOOT_FROM_NAND && ENV_REDUND)
+        
+
+config RESET_DDR_CONFIG
+    string "reset_ddr_config"
+	default "prot off $(f_ddrconfig_addr) $(f_ddrconfig_end); erase $(f_ddrconfig_addr) $(f_ddrconfig_end)" if ( BOOT_FROM_NOR )
+    default "sf probe 3; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_ar9 )
+    default "sf probe 0; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_amazon_se	)
+    default "sf probe 3; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_vr9 )
+    default "sf probe 3; sf read 0x80800000 0x0 0x10000; mw 0x8080ffe8 0xffffffff 0x6; sf erase 0x0 0x10000; sf write 0x80800000 0x0 0x10000"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_hn1 )
+    default "sf probe 0; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_ar10 )
+    default "sf probe 1; sf write 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)"  if ( BOOT_FROM_SPI && LANTIQ_UBOOT_grx500 )
+	default "nand write.partial 80400000 $(f_ddrconfig_addr) $(f_ddrconfig_size)" if ( BOOT_FROM_NAND )
+					
+config RESET_SYSCONFIG
+    string 
+	default "erase $(f_sysconfig_addr) 10000" if BOOT_FROM_NOR 
+	default "sf probe 0;sf erase $(f_sysconfig_addr) 10000" if BOOT_FROM_SPI && ( LANTIQ_UBOOT_ar10 || LANTIQ_UBOOT_vbg400 || LANTIQ_UBOOT_amazon_se )
+	default "sf probe 3;sf erase $(f_sysconfig_addr) 10000" if BOOT_FROM_SPI && ( LANTIQ_UBOOT_vr9 || LANTIQ_UBOOT_ar9 || LANTIQ_UBOOT_hn1 )
+        default "sf probe 1;sf erase $(f_sysconfig_addr) 10000" if BOOT_FROM_SPI && LANTIQ_UBOOT_grx500
+	default "run ubi_init;ubi remove sysconfig;ubi remove sysconfigA;ubi remove sysconfigB" if ( BOOT_FROM_NAND && CMD_UBI )
+
+endmenu
+
+
+source lib/Kconfig
+source common/Kconfig
diff --git a/scripts_platform/big_nand_gct b/scripts_platform/big_nand_gct
new file mode 100755
--- /dev/null
+++ b/scripts_platform/big_nand_gct
@@ -0,0 +1,52 @@
+# shell script for making u-boot image for big nand flash
+# Written by Wu Qi Ming Qi-Ming.Wu@infineon.com
+
+#!/bin/sh
+
+
+FILESIZE=0
+PADSIZE=0
+TARGET_FILE=u-boot.nand
+MINIBOOTROM=scripts_platform/minibootrom.img
+#modify this for different page size
+NAND_PAGE_SIZE=2048
+
+
+scripts_platform/sgct scripts_platform/minibootrom/dummy scripts_platform/minibootrom/bootrom.rec ${MINIBOOTROM}
+
+cat ${MINIBOOTROM} >${TARGET_FILE}
+
+FILESIZE=`ls -l ${TARGET_FILE} | awk '{print $5}'`  
+
+
+PADSIZE=`expr ${NAND_PAGE_SIZE} - ${FILESIZE}`
+
+
+dd if=/dev/zero of=zero bs=${PADSIZE} count=1
+
+cat zero >>${TARGET_FILE}
+
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' $2 | awk '{printf "%s %s\n", $1, $2}' >tmp
+
+scripts_platform/gen_ram.pl tmp ram_tmp
+
+cat ram_tmp >>${TARGET_FILE}
+
+FILESIZE=`ls -l ${TARGET_FILE} | awk '{print $5}'`
+
+
+PADSIZE=`expr ${NAND_PAGE_SIZE} + ${NAND_PAGE_SIZE} - ${FILESIZE}`
+
+
+dd if=/dev/zero of=zero bs=${PADSIZE} count=1
+
+cat zero >>${TARGET_FILE}
+
+cat $3 >>${TARGET_FILE}
+
+rm -rf tmp ram_tmp zero ${MINIBOOTROM} 
+
+
+
+
+
diff --git a/scripts_platform/bin2array.pl b/scripts_platform/bin2array.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/bin2array.pl
@@ -0,0 +1,45 @@
+#!/usr/bin/perl
+# perl script from binary to C array
+# 1-March-2016 Author William Widjaja
+
+use warnings;
+use strict;
+
+my $name;
+my $buffer;
+my $byte;
+
+if(@ARGV < 3){
+	print "not enough arguments\n";
+    print "Syntax: ./bin2array.pl <input-file> <output-file> <array-name>\n";
+	print "example: ./bin2array.pl data.bin output.h data_array\n";
+    exit;
+}
+
+open(INFILE, "<$ARGV[0]") or die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[1]") or die("\nOutput file open fail\n");
+$name = $ARGV[2];
+
+binmode INFILE;
+binmode OUTFILE;
+
+print OUTFILE "unsigned char ";
+print OUTFILE $name;
+print OUTFILE "[]={";
+
+while (read (INFILE, $buffer, 1))
+{
+    $byte = unpack("H2",$buffer);
+   
+    print OUTFILE "0x$byte";
+   
+    if (!eof(INFILE)) {
+        print OUTFILE ", ";
+	}
+   
+};
+
+print OUTFILE "};\n";
+
+close INFILE;
+close OUTFILE;
\ No newline at end of file
diff --git a/scripts_platform/bin2asc.pl b/scripts_platform/bin2asc.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/bin2asc.pl
@@ -0,0 +1,68 @@
+#!/usr/bin/perl
+
+# this perl script is used to generate simulation-friendly asc file from raw binary file.
+
+#********************************************************************************************
+
+$ARGV[0] || go_die();
+$ARGV[1] || go_die();
+
+$infile = $ARGV[0];
+$outfile = $ARGV[1];
+
+#********************************************************************************************
+
+open ($INFILE, $infile) || go_die("Can't open $infile fo read",1);
+
+open ($OUTFILE, ">$outfile") || go_die("Can't open $outfile for write",1);
+
+binmode $INFILE;
+
+# start address for asc file
+print $OUTFILE "\@00000000\n";
+
+
+$WIDTH = 4;   # number of bytes to read per loop
+$packFormat  = "H" . 2 * $WIDTH;  # must use big "H" ie high nibble first
+
+# copy first binary image into output file
+while ( read $INFILE, $buf, $WIDTH )
+{
+    $pack = unpack $packFormat, $buf;
+
+    $pack = sprintf("%08X", hex($pack));  # change to upper case
+
+    print $OUTFILE $pack;
+    print $OUTFILE "\n";
+}
+
+close ($INFILE);
+close ($OUTFILE);
+
+#********************************************************************************************
+
+sub go_die
+{
+    my($message, $supressformat) = @_;
+
+    if ($message)
+    {
+        print "$message";
+    }
+
+    close (INFILE);
+    close (OUTFILE);
+
+    unless ($supressformat)
+    {
+        print "format is: \n";
+        print " bin2asc.pl bootrom.bin bootrom.asc\n";
+    }
+    else
+    {
+       print "----------------------------------------------------------\n";
+    }
+
+    die ("\n");
+}
+
diff --git a/scripts_platform/bin2h.pl b/scripts_platform/bin2h.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/bin2h.pl
@@ -0,0 +1,94 @@
+#!/usr/bin/perl
+# this perl script is used to generate simulation-friendly asc file from raw binary file.
+#********************************************************************************************
+$ARGV[0] || go_die();
+
+$infile = $ARGV[0];
+
+#********************************************************************************************
+open ($INFILE, $infile) || go_die("Can't open $infile fo read",1);
+binmode $INFILE;
+
+my ($s1,$s2) = split '\.', $infile;
+$s2 = uc $s1;
+
+my $out000 = "$s1\.h";
+open ($OUT000, ">$out000") || go_die("Can't open $out000 for write",1);
+
+$s1 =~ s/[^A-Za-z0-9]/_/g;
+$s2 =~ s/[^A-Za-z0-9]/_/g;
+
+$WIDTH = 1;   						# number of bytes to read per loop
+$packFormat  = "H" . 2 * $WIDTH;  	# must use big "H" ie high nibble first
+
+$PreLoad_cnt = 
+$B_cnt = 0;							# 8KB block count
+$Len = 0;
+$Csum = 0;
+$size = -s $infile;
+
+print $OUT000 "\#ifndef __$s2\_H__\n";
+print $OUT000 "\#define __$s2\_H__\n";
+print $OUT000 "const char $s1\[$size] = {\n";
+
+while ( 1 )
+{
+	if (read ($INFILE, $buf, $WIDTH) != $WIDTH) {
+		last;
+	}	
+
+	$p = unpack $packFormat, $buf;
+	$Csum = $Csum + hex($p);
+	$Len = $Len + 1;	
+	
+	if ($B_cnt%4 == 0){
+		print $OUT000 "    ";	
+	}
+	$pack = unpack $packFormat, $buf;
+	$pack = sprintf("0x%02X, ", hex($pack));  # change to upper case
+	print $OUT000 $pack;
+	
+	if ($B_cnt%4 == 3){
+		print $OUT000 "\n";
+	} 
+		   
+	$B_cnt = $B_cnt + 1;
+}
+
+print $OUT000 "};\n";
+print $OUT000 "\#endif";
+
+$Csum = sprintf("0x%X", $Csum);
+print "Length = $Len\n";
+print "Csum = $Csum\n";
+
+close ($INFILE);
+close ($OUT000);
+
+#********************************************************************************************
+
+sub go_die
+{
+    my($message, $supressformat) = @_;
+
+    if ($message)
+    {
+        print "$message";
+    }
+
+    close (INFILE);
+    close (OUTFILE);
+
+    unless ($supressformat)
+    {
+        print "format is: \n";
+        print "    bin2h.pl file.bin\n";
+    }
+    else
+    {
+       print "----------------------------------------------------------\n";
+    }
+
+    die ("\n");
+}
+
diff --git a/scripts_platform/build_asc.pl b/scripts_platform/build_asc.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/build_asc.pl
@@ -0,0 +1,121 @@
+#!/usr/bin/perl
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+
+if(@ARGV < 3){
+	print "\n not enough arguments";
+	print "\n Syntax: build_asc.pl ram.conf data.bin offset u-boot.asc\n";
+    exit;
+}
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[3]") || die("\nOutput file open fail\n");
+
+binmode INFILE2;
+
+$i=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+                  if($i eq 0){
+		  printf OUTFILE ("33333333");
+		  }
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+                  $i=$i+1;
+		  if($i eq 8)
+		  {
+                      $i=0;
+		      printf OUTFILE ("\n");
+		  }
+
+           }
+        }
+
+	    }
+
+        while($i lt 8 && $i gt 0){
+                   printf OUTFILE "00"x8;
+		   $i=$i+1;
+		   }
+
+$i=0;
+$addr=$ARGV[2];
+$addr=hex($addr);
+$chsum=0x0;
+
+while (read (INFILE2, $buffer, 4))
+{
+   if(($i % 16) eq 0)
+   {
+     printf OUTFILE ("\n%08x",$addr);
+	 $chsum+=$addr;
+	 $addr+=0x40;
+   }
+   $i+=1;
+   $data=unpack("H*",$buffer);
+   $data=hex($data);
+   printf OUTFILE ("%08x",$data);
+   $chsum+=$data;
+}
+
+while ( ($i % 16) != 0 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+
+$chsum=$chsum & 0xffffffff;
+
+printf OUTFILE ("\n11111111");
+printf OUTFILE ("%08x",$chsum);
+$i=0;
+while ( $i < 15 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+
+printf OUTFILE ("\n99999999");
+
+printf OUTFILE ("%08x",hex($ARGV[2]));
+
+$i=0;
+while ( $i < 15 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+printf OUTFILE ("\n");
+
+close(INFILE1);
+close(INFILE2);
+close(OUTFILE);
diff --git a/scripts_platform/build_stage3.sh b/scripts_platform/build_stage3.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/build_stage3.sh
@@ -0,0 +1,201 @@
+#!/bin/sh
+#shell script to generate stage3 image 
+#revision history
+#Wu Qi Ming 6/12/2012 Qi-Ming.Wu@lantiq.com
+
+Usage(){
+  echo "Usage: build_stage3.sh [option]...[file]..."
+  echo "-h  --help             print help information"
+  echo "-i  --in   input       input file"
+  echo "-o  --out  output      output file"
+  echo "-k  --key  key         aes cbc key"
+  echo "-p  --priv privkey     dsa private key"
+  echo "-d  --da   address     decrypted(destination) image address"
+  echo "-j  --ja   address     jump address"
+  return
+}
+
+PRIVKEY=
+HEADMAGIC=0x65976743
+INPUTFILE=
+OUTPUTFILE=
+#CBCKEY=693deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4
+CBCKEY=
+CBCIV=00000000000000000000000000000000
+ENCRYPT_ADDR=
+DECRYPT_ADDR=
+JUMP_ADDR=
+
+parse_args() {
+  while [ "$#" -gt "0" ]
+  do
+     case $1 in
+	             --in | -i)
+		                INPUTFILE=$2		
+			            ;;
+                --out | -o)
+                        OUTPUTFILE=$2
+                        ;;
+                --key | -k)
+                        CBCKEY=$2
+						HEADMAGIC=0x65976742
+                        ;;
+				--privkey | -p)
+				        PRIVKEY=$2
+						;;
+                --ea | -e)
+                        ENCRYPT_ADDR=$2
+                        ;;
+				--da | -d)
+				        DECRYPT_ADDR=$2
+					    ;;
+                --ja | -j)
+			            JUMP_ADDR=$2
+			            ;;
+                --help | -h )
+			Usage
+			exit 1
+			;;
+      esac			
+      shift 
+  done
+  return
+}
+
+packhex(){
+    PACK_DATA_LEN=`echo $1 |wc -c`
+    let PACK_DATA_LEN=$PACK_DATA_LEN-1
+    PACK_START=1
+    PACK_RESULT=
+    while [ $PACK_START -le $PACK_DATA_LEN ]
+    do
+       PACK_TMP=`echo $1 | awk '{print substr($0, '$PACK_START', 2)}'`
+       PACK_RESULT="${PACK_RESULT}\x${PACK_TMP}" 
+       let PACK_START=$PACK_START+2
+    done
+    echo $PACK_RESULT
+}
+
+addchksum(){
+    RESULT=`perl -e "print $1+$2"|xargs printf "%08x\n"`
+    echo 0x$RESULT
+}
+
+
+
+if [ $# -eq 0 ] ; then  
+   Usage
+   exit 1
+fi 
+
+parse_args $@
+
+
+if [ -z $PRIVKEY ]
+then
+   echo "no dsa privkey"
+   Usage
+   exit 1
+fi
+
+if [ -z $DECRYPT_ADDR ]
+then
+   echo "no destination address"
+   Usage
+   exit 1
+fi
+
+
+if [ -z $JUMP_ADDR ]
+then
+   echo "no jump address"
+   Usage
+   exit 1
+fi
+
+
+if [ -z $OUTPUTFILE ]
+then
+   echo "no output file"
+   Usage
+   exit 1
+fi
+
+
+if [ -z $INPUTFILE ]
+then
+   echo "no output file"
+   Usage
+   exit 1
+fi
+
+
+#echo "input:" $INPUTFILE
+#echo "output:" $OUTPUTFILE
+#echo "cbckey:" $CBCKEY
+#echo "cbciv:"  $CBCIV
+#echo "headmagic:" $HEADMAGIC
+
+
+#creating secure header now
+
+#add headmagic
+DATA=`printf "%08x" $HEADMAGIC`
+echo -en `packhex $DATA` >shdr
+
+#followed by image length
+LEN=`stat -c %s $INPUTFILE`
+LENHEX=`printf "%08x" $LEN`
+echo -en `packhex $LENHEX` >>shdr
+
+#Followed by decrypted image address
+ADDR=`printf "%08x" $DECRYPT_ADDR`
+echo -en `packhex $ADDR` >>shdr
+
+#jump address
+ADDR=`printf "%08x" $JUMP_ADDR`
+echo -en `packhex $ADDR` >>shdr
+
+#SHA1 result 
+SHA_RESULT=`openssl dgst -sha1 $INPUTFILE | awk -F'= ' '{print $2}'`
+#echo "sha result:" $SHA_RESULT
+echo -en `packhex $SHA_RESULT` >>shdr
+
+#dsa signature now
+openssl dgst -dss1 -sign $PRIVKEY $INPUTFILE >sign.result
+
+openssl asn1parse -inform DER -in sign.result >sign.asn1
+R=`sed -n '2 p' sign.asn1 | awk -F':' '{print $4}'`
+#echo "R:" $R
+echo -en `packhex $R` >>shdr
+
+S=`sed -n '3 p' sign.asn1 | awk -F':' '{print $4}'`
+#echo "S:" $S
+echo -en `packhex $S` >>shdr
+
+#add header checksum */
+CHKSUM=0x0
+DATA=`hexdump -v -e '"0x"' -e '4/1 "%02x"' -e '" "' shdr`
+
+for VALUE in $DATA
+do
+  CHKSUM=`addchksum $CHKSUM $VALUE`
+done
+
+#echo $CHKSUM
+
+RESULT=`perl -e "print $CHKSUM & 0xffffffff"|xargs printf "%08x\n"`
+RESULT=`echo 0x$RESULT`
+
+DATA=`printf "%08x" $RESULT`
+echo -en `packhex $DATA` >>shdr
+
+cp shdr $OUTPUTFILE
+
+if [ -z $CBCKEY ];then
+  cat $INPUTFILE >>$OUTPUTFILE
+else
+  openssl enc -aes-256-cbc -in $INPUTFILE -out file.enc -K $CBCKEY -iv $CBCIV -nopad
+  cat file.enc >>$OUTPUTFILE
+fi
+
diff --git a/scripts_platform/duplicate.sh b/scripts_platform/duplicate.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/duplicate.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+#duplicate file to a specific times
+#Revision history
+#19/09/2011 Author: Wu Qi Ming Qi-Ming.Wu@infineon.com
+
+COUNTER=1
+TARGETFILE=$2
+
+cp $TARGETFILE tmp 
+
+while [ $COUNTER -lt $1 ]; do
+  echo "duplicate!"
+  cat $TARGETFILE >> tmp
+  COUNTER=$(($COUNTER+1))
+done
+
+cp tmp $2
+rm tmp
diff --git a/scripts_platform/eegct b/scripts_platform/eegct
new file mode 100755
--- /dev/null
+++ b/scripts_platform/eegct
@@ -0,0 +1,120 @@
+#!/usr/bin/perl
+#perl script to generate spi bootable u-boot
+#Revision history
+#03/27/08 Author Wu Qi Ming
+
+my $SPI_MAGIC=0xAA55;
+my $PHY1=0x1;
+my $PHY0=0x0;
+my $MAC0=0x2c;
+my $MAC1=0x02;
+my $MAC2=0x00;
+my $MAC3=0x92;
+my $MAC4=0xe0;
+my $MAC5=0x00;
+my $VALID=0x1; #always valid
+my $OFFSET=0x0c;
+
+if(@ARGV < 2){
+	print "not enough arguments\n";
+	print "Syntax: ./sgct input output\n";
+	print "example: ./sgct ddr_setting.conf u-boot.srec u-boot.sflash\n";
+	exit;
+}
+print "converting now, please wait...\n";
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[2]") || die("\nOutput file open fail\n");
+
+#form a REGCFG head
+$head=sprintf("%08x",($SPI_MAGIC<<16)|($PHY1<<8)|($PHY0));
+$head=$head.sprintf("%08x",($MAC3<<24)|($MAC2<<16)|($MAC1<<8)|($MAC0));
+$head=$head.sprintf("%08x",($OFFSET<<24)|($VALID<<16)|($MAC5)|($MAC4));
+printf OUTFILE pack("H*",$head);
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+
+printf OUTFILE pack("H*",$string);
+$string="";
+$firsttime=1;
+$count=0;
+while($aline=<INFILE2>){
+	$aline=uc($aline);
+	chomp($aline);
+	next if($aline=~/^S0/);
+        ($lineid, $length, $address, @bytes) = unpack"A2A2A8"."A2"x300, $aline;
+        $length = hex($length);
+        $address = hex($address);
+	$i=0;
+        if($lineid eq "S3")
+        { 
+         if($firsttime==1)
+          {
+             $addstr = sprintf("%08x", $address+1); 
+             $string=$addstr;
+             $loadaddr=$address;
+             $firsttime=0;
+          }
+          $length=$length-4;
+          while($length>1){
+           $bytes[$i]=~tr/ABCDEF/abcdef/;
+	   #printf ("length=%d,i=%d,byte=%02x\n",$length,$i,hex(@bytes[$i]));
+           $string=$string.@bytes[$i];
+           #printf ("string=%s\n",$string);
+	   $length=$length-1;
+           $i=$i+1;
+           $count++;
+          }
+        }
+        elsif($lineid eq "S7")
+        {
+           $exehead=sprintf("%08x",0xffffffff).sprintf("%08x",$address);
+	   #print $exehead
+        }
+}
+
+
+
+
+if($firsttime==1){
+    $string=sprintf("%08x",3);
+    printf OUTFILE pack("H*",$string);
+}
+else{
+   printf("addstr=%s\n",$addstr); 
+   printf OUTFILE pack("H*",$addstr);
+   printf OUTFILE pack("H*",sprintf("%08x",$count/4));
+   #printf OUTFILE pack("H*",$string);
+   @bytes=unpack"A2"x$count,$string;
+   for ($i=0;$i<$count;$i++){
+    printf OUTFILE pack("H2",$bytes[$i]);  
+}
+   printf OUTFILE pack("H*",$exehead);
+}
+
+
+
+
+
diff --git a/scripts_platform/gct b/scripts_platform/gct
new file mode 100755
--- /dev/null
+++ b/scripts_platform/gct
@@ -0,0 +1,157 @@
+#!/usr/bin/perl
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+
+if(@ARGV < 2){
+	print "\n not enough arguments";
+	print "\n Syntax: ./gct input output\n";
+}
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[2]") || die("\nOutput file open fail\n");
+
+$i=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+                  if($i eq 0){
+		  printf OUTFILE ("33333333");
+		  }
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+                  $i=$i+1;
+		  if($i eq 8)
+		  {
+                      $i=0;
+		      printf OUTFILE ("\n");
+		  }
+
+               }
+             }
+
+	    }
+
+        while($i lt 8 && $i gt 0){
+                   printf OUTFILE "00"x8;
+		   $i=$i+1;
+		   }
+        if($i eq 8){
+	printf OUTFILE ("\n");
+        }
+
+while($aline=<INFILE2>){
+	$aline=uc($aline);
+	chomp($aline);
+	next if(($aline=~/^S0/) || ($aline=~/^S7/));
+	($lineid, $length, $address, @bytes) = unpack"A2A2A8"."A2"x300, $aline;
+	$length = hex($length);
+	$address = hex($address);
+	$length -=5;
+	$i=0;
+
+	while($length>0){
+		if($firstime==1){
+				$addstr = sprintf("%x", $address);
+				$addstr = "0"x(8-length($addstr)).$addstr;
+				print OUTFILE $addstr;
+				addchsum($addstr);
+				$firstime=0;
+				$currentaddr=$address;
+				$loadaddr = $addstr;
+		}
+		else{
+			if($count==64){
+				$addstr = sprintf("%x", $currentaddr);
+				$addstr = "0"x(8-length($addstr)).$addstr;
+				print OUTFILE $addstr;
+				addchsum($addstr);
+				$count=0;
+			}
+		}
+		while($count<64){
+		        $bytes[$i]=~tr/ABCDEF/abcdef/;
+			print OUTFILE "$bytes[$i]";
+			addchsum($bytes[$i]);
+			$i++;
+			$count++;
+			$length--;
+			last if($length==0);
+		}
+		if($count==64){
+			print OUTFILE "\n";
+			#print OUTFILE "\r";
+			$currentaddr+=64;
+		}
+	}
+}
+if($count != 64){
+	$tmp = "00";
+	for($i=0;$i<(64-$count);$i++){
+		print OUTFILE "00";
+		addchsum($tmp);
+	}
+	print OUTFILE "\n";
+	#print OUTFILE "\r";
+}
+
+
+print OUTFILE "11"x4;
+use integer;
+$chsum=$chsum & 0xffffffff;
+$chsum = sprintf("%X", $chsum);
+$chsum = "0"x(8-length($chsum)).$chsum;
+$chsum =~tr/ABCDEF/abcdef/;
+print OUTFILE $chsum;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+print OUTFILE "99"x4;
+print OUTFILE $loadaddr;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+
+close OUTFILE;
+#END of Program
+
+
+
+sub addchsum{
+	my $cc=$_[0];
+	$holder=$holder.$cc;
+	if(length($holder)==8){
+		$holder = hex($holder);
+		$chsum+=$holder;
+		$holder="";
+	}
+}
+#END
+
+
diff --git a/scripts_platform/gen_ram.pl b/scripts_platform/gen_ram.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/gen_ram.pl
@@ -0,0 +1,21 @@
+#!/usr/bin/perl
+#perl script to generate ram parameters for big nand flash
+#Revision history
+#7/7/08 Author Wu Qi Ming
+
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[1]") || die("\nOutput file open fail\n");
+
+$string="";
+while ($line = <INFILE1>){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+		  $addr=@array[0];
+	          $regval=@array[1];
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+}
+
+printf OUTFILE pack("H*",$string);
+
diff --git a/scripts_platform/hex2array.pl b/scripts_platform/hex2array.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/hex2array.pl
@@ -0,0 +1,45 @@
+#!/usr/bin/perl
+#perl script to convert hex to C array
+#Revision history
+#27/11/2009 Author Wu Qi Ming
+#usage: hex2array.pl bn 010203....
+#output: unsigned char bn[]={0x01,0x02,0x03,....};
+
+
+$name = $ARGV[0];
+$string = $ARGV[1];
+
+
+if(length($string) % 2 >0){
+   $string="0".$string;
+}
+
+@bytes = unpack("(A2)*", $string);
+$len=@bytes;
+$rem=$len%4;
+
+print "unsigned char ";
+print $name;
+print "[]={";
+
+$i=0;
+if($rem>0){
+ while($i<(4-$rem))
+ {
+   print "0x00,";
+   $i++;
+ }
+}
+
+$i=0;
+while ($i<$len)
+{
+   print "0x$bytes[$i]";
+   if($i != ($len-1)){
+      print ",";
+   }
+   $i++;
+}
+
+print "};\n";
+
diff --git a/scripts_platform/hn1_ddr.pl b/scripts_platform/hn1_ddr.pl
new file mode 100644
--- /dev/null
+++ b/scripts_platform/hn1_ddr.pl
@@ -0,0 +1,103 @@
+#!/usr/bin/perl -w
+
+use strict;
+
+####################################################################################################
+# this perl script is used to convert vr9 chiptest/palladium image to support new ddr model in vr9 #
+####################################################################################################
+# Identical with vr9_ddr.pl and intented to be used for HN1                                        #
+####################################################################################################
+
+my $versioninfo = "V1.0.0 29 Oct 2008";
+
+my $infile = "";
+my $outfile = "";
+
+my $read_line;
+my $line1;
+my $line2;
+my $line3;
+my $line4;
+
+#
+# Verify the input/output parameters 
+#
+
+if (($#ARGV + 1) != 2 ) {
+    die "Usage: $0 <input asc file> <output asc file>\n"
+}
+
+$infile = shift(@ARGV);
+$outfile = shift(@ARGV);
+
+#
+# Read/Write file handler
+#
+open (INFILE, $infile) || go_die("Can't open $infile fo read :$!", 1);
+
+open (OUTFILE, ">$outfile") || go_die("Can't open $outfile for write :$!", 1);
+
+#
+# Force it to binary mode 
+#
+binmode (INFILE);
+
+binmode (OUTFILE);
+
+#
+# to skip @00000000, so that it still inherits the original address
+#
+$read_line = <INFILE>;  
+print OUTFILE $read_line;
+while (1) {
+    
+    if (eof(INFILE)){
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }
+    $line1 = <INFILE>;
+    if (eof(INFILE)){
+        print OUTFILE $line1;
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }    
+    $line2 = <INFILE>;
+    if (eof(INFILE)){
+        print OUTFILE $line1;
+        print OUTFILE $line2;        
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }   
+    $line3 = <INFILE>;
+    
+    if (eof(INFILE)){
+        print OUTFILE $line3;
+        print OUTFILE $line1;
+        print OUTFILE $line2;        
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }    
+    $line4 = <INFILE>;    
+    
+    print OUTFILE $line3;
+    print OUTFILE $line4;
+    print OUTFILE $line1;
+    print OUTFILE $line2;
+
+}
+
+#********************************************************************************************
+
+sub go_die
+{
+    my($message, $supressformat) = @_;
+
+    if ($message) {
+        print "$message";
+    }
+
+    close (INFILE);
+    close (OUTFILE);
+    
+    print " done\n";
+    exit (0);
+}
+
+
+
diff --git a/scripts_platform/ikos_ram_ddr_file_gen b/scripts_platform/ikos_ram_ddr_file_gen
new file mode 100755
--- /dev/null
+++ b/scripts_platform/ikos_ram_ddr_file_gen
@@ -0,0 +1,53 @@
+#!/bin/sh
+#for 16bit Verilog Memory Model
+usage() {
+echo "$0 binary_file_name start_address"
+}
+
+if [ "$#" -ne 3 ]
+then
+	usage
+	exit 1
+elif [ ! -f $1 ]
+then
+	echo "cannot open $1"
+	exit 1
+fi
+ENDIAN=$3
+START_ADDRESS=$2
+BINARY_FILE=$1
+SOURCE_FILE=${BINARY_FILE}.txt
+SOURCE_FILE2=${BINARY_FILE}.test.txt
+
+#generate the ascii-representd binary file
+#echo "@"$START_ADDRESS >${SOURCE_FILE}
+hexdump -v -e '4/1 "%02x""\n"' ${BINARY_FILE} >${SOURCE_FILE}
+hexdump -v -e '8/1 "%02x""\n"' ${BINARY_FILE} >${SOURCE_FILE2}
+
+rm -f ${SOURCE_FILE}.00
+rm -f ${SOURCE_FILE}.01
+rm -f ${SOURCE_FILE}.02
+echo "@"$START_ADDRESS>${SOURCE_FILE}.00
+echo "@"$START_ADDRESS>${SOURCE_FILE}.01
+echo "@"$START_ADDRESS>${SOURCE_FILE}.02
+#change to 8 bit
+#awk -F ""  '{printf("%s%s\n", $5,$6); printf("%s%s\n", $1,$2)}' < ${SOURCE_FILE} >> ${SOURCE_FILE}.00
+#awk -F ""  '{printf("%s%s\n", $7,$8); printf("%s%s\n", $3,$4)}' < ${SOURCE_FILE} >> ${SOURCE_FILE}.01
+
+if [ $ENDIAN = 'EL' ]
+then
+echo "Building asc for little endian..."
+awk -F ""  '{printf("%s%s\n", $7,$8); printf("%s%s\n", $5,$6); printf("%s%s\n", $3,$4); printf("%s%s\n", $1,$2)}' < ${SOURCE_FILE2} >> ${SOURCE_FILE}.00
+awk -F ""  '{printf("%s%s\n", $15,$16); printf("%s%s\n", $13,$14); printf("%s%s\n", $11,$12); printf("%s%s\n", $9,$10)}' < ${SOURCE_FILE2} >> ${SOURCE_FILE}.01
+awk -F ""  '{printf("%s%s%s%s\n", $9,$10,$1,$2); printf("%s%s%s%s\n", $11,$12,$3,$4); printf("%s%s%s%s\n", $13,$14,$5,$6); printf("%s%s%s%s\n", $15,$16,$7,$8)}' <${SOURCE_FILE2} >> ${SOURCE_FILE}.02
+else
+echo "Building asc for big endian..."
+awk -F ""  '{printf("%s%s\n", $7,$8); printf("%s%s\n", $5,$6); printf("%s%s\n", $3,$4); printf("%s%s\n", $1,$2)}' < ${SOURCE_FILE2} >> ${SOURCE_FILE}.00
+awk -F ""  '{printf("%s%s\n", $15,$16); printf("%s%s\n", $13,$14); printf("%s%s\n", $11,$12); printf("%s%s\n", $9,$10)}' < ${SOURCE_FILE2} >> ${SOURCE_FILE}.01
+awk -F ""  '{printf("%s%s%s%s\n", $7,$8,$15,$16); printf("%s%s%s%s\n", $5,$6,$13,$14); printf("%s%s%s%s\n", $3,$4,$11,$12); printf("%s%s%s%s\n", $1,$2,$9,$10)}' <${SOURCE_FILE2} >> ${SOURCE_FILE}.02
+fi
+
+rm -f {SOURCE_FILE}.asc
+echo "@4000">${SOURCE_FILE}.asc
+cat ${SOURCE_FILE2}>>${SOURCE_FILE}.asc
+
diff --git a/scripts_platform/key2header.sh b/scripts_platform/key2header.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/key2header.sh
@@ -0,0 +1,19 @@
+#!/bin/sh
+INPUTFILE=$1
+OUTPUTFILE=$2
+
+openssl asn1parse -in $INPUTFILE >privkey.asn1
+
+P=`sed -n '3 p' privkey.asn1 | awk -F':' '{print $4}'`
+scripts_platform/hex2array.pl bn_p $P >$OUTPUTFILE
+
+Q=`sed -n '4 p' privkey.asn1 | awk -F':' '{print $4}'`
+scripts_platform/hex2array.pl bn_q $Q >>$OUTPUTFILE
+
+G=`sed -n '5 p' privkey.asn1 | awk -F':' '{print $4}'`
+scripts_platform/hex2array.pl bn_g $G >>$OUTPUTFILE
+
+PUBKEY=`sed -n '6 p' privkey.asn1 | awk -F':' '{print $4}'`
+scripts_platform/hex2array.pl bn_pubkey $PUBKEY >>$OUTPUTFILE
+
+
diff --git a/scripts_platform/mk_eeprom.pl b/scripts_platform/mk_eeprom.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_eeprom.pl
@@ -0,0 +1,77 @@
+#!/usr/bin/perl
+#perl script to generate an bootable image for eeprom
+#Revision history
+#03/27/08 Author Wu Qi Ming
+
+my $SPI_MAGIC=0xAA55;
+my $PHY1=0x1;
+my $PHY0=0x0;
+my $MAC0=0x2c;
+my $MAC1=0x02;
+my $MAC2=0x00;
+my $MAC3=0x92;
+my $MAC4=0xe0;
+my $MAC5=0x00;
+my $VALID=0x1; #always valid
+my $OFFSET=0x0c;
+
+if(@ARGV < 2){
+	print "not enough arguments\n";
+    print "Syntax: ./mk_eeprom.pl config data address output\n";
+	print "example: ./mk_eeprom.pl ram.conf u-boot.ifx 0xa0100000 u-boot.eeprom\n";
+    exit;
+}
+print "converting now, please wait...\n";
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[3]") || die("\nOutput file open fail\n");
+
+#form a REGCFG head
+$head=sprintf("%08x",($SPI_MAGIC<<16)|($PHY1<<8)|($PHY0));
+$head=$head.sprintf("%08x",($MAC3<<24)|($MAC2<<16)|($MAC1<<8)|($MAC0));
+$head=$head.sprintf("%08x",($OFFSET<<24)|($VALID<<16)|($MAC5)|($MAC4));
+printf OUTFILE pack("H*",$head);
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+
+printf OUTFILE pack("H*",$string);
+
+
+$datafile_size=(-s $ARGV[1]);
+$datafile_size=sprintf("%08x",$datafile_size/4);
+$start_address=sprintf("%08x",hex($ARGV[2])+1);
+printf OUTFILE pack("H*",$start_address.$datafile_size);
+
+binmode(INFILE2,":raw");
+binmode(OUTFILE,":raw");
+
+read(INFILE2,$buf,(-s $ARGV[1]));
+print OUTFILE $buf;
+
+$exehead=sprintf("%08x",0xffffffff);
+$start_address=sprintf("%08x",hex($ARGV[2]));
+
+printf OUTFILE pack("H*", $exehead.$start_address);
+
diff --git a/scripts_platform/mk_envimg.sh b/scripts_platform/mk_envimg.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_envimg.sh
@@ -0,0 +1,57 @@
+#!/bin/bash
+#Build uboot environment block image
+#To be used in u-boot root directory of UGW package
+#Copyright (C) 2007-2010 Lantiq Asia Pacific Pte. Ltd
+#Revision history
+#10/07/2012 Wu Qi Ming Qi-Ming.Wu@lantiq.com
+#Usage: mk_envimg.sh target_file
+
+packhex(){
+    PACK_DATA_LEN=`echo $1 |wc -c`
+    let PACK_DATA_LEN=$PACK_DATA_LEN-1
+    PACK_START=1
+    PACK_RESULT=
+    while [ $PACK_START -le $PACK_DATA_LEN ]
+    do
+      PACK_TMP=`echo $1 | awk '{print substr($0, '$PACK_START', 2)}'`
+      PACK_RESULT="${PACK_RESULT}\x${PACK_TMP}"
+      let PACK_START=$PACK_START+2
+    done
+    echo $PACK_RESULT
+}
+
+
+OUTPUT=$1
+
+ADDRHEX=`sed -e '/default_environment/!d' u-boot.sym |awk '{print substr($1,length($1)-4,5)}'`
+
+ADDR=`echo $((16#$ADDRHEX))`
+
+
+LENHEX=`sed -e '/default_environment/!d' u-boot.sym |awk '{print $2}'`
+
+LEN=`echo $((16#$LENHEX))`
+
+
+dd if=u-boot.bin of=env.tmp ibs=1 skip=$ADDR count=$LEN
+
+CRC=`tools/envcrc env.tmp`
+
+echo -en `packhex $CRC` >$OUTPUT
+
+REDUND=`grep -r CONFIG_ENV_REDUND .config | awk -F'=' '{print $2}'`
+
+if [ "$REDUND" = "y" ];then
+   echo -en "\x0" >>$OUTPUT
+fi
+
+cat env.tmp >>$OUTPUT
+
+CONFIG_ENV_SIZE=`strings env.tmp | grep f_ubootconfig_size=|awk -F'=' '{print $2}'`
+
+SCRIPTDIR=${0%/*}
+$SCRIPTDIR/pad2align.sh -n $CONFIG_ENV_SIZE $OUTPUT
+
+rm -rf env.tmp
+
+
diff --git a/scripts_platform/mk_hn1_nand.sh b/scripts_platform/mk_hn1_nand.sh
new file mode 100644
--- /dev/null
+++ b/scripts_platform/mk_hn1_nand.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+touch scripts_platform/dummy
+scripts_platform/sgct scripts_platform/dummy board/hn1/bootrom.rec u-boot.nand
+scripts_platform/pad2align.sh -n 2048 u-boot.nand
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' ram.conf | awk '{printf "%s %s\n", $1, $2}' >tmp
+scripts_platform/gen_ram.pl tmp ram_tmp
+scripts_platform/pad2align.sh -n 2048 ram_tmp
+cat ram_tmp >>u-boot.nand
+cat u-boot.ifx >>u-boot.nand
+rm tmp ram_tmp u-boot.ifx
diff --git a/scripts_platform/mk_hn1_sf.sh b/scripts_platform/mk_hn1_sf.sh
new file mode 100644
--- /dev/null
+++ b/scripts_platform/mk_hn1_sf.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+touch scripts_platform/dummy
+scripts_platform/sgct scripts_platform/dummy board/hn1/sf_bootrom.rec u-boot.sflash
+scripts_platform/pad2align.sh -n 2048 u-boot.sflash
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' ram.conf | awk '{printf "%s %s\n", $1, $2}' >tmp
+scripts_platform/gen_ram.pl tmp ram_tmp
+scripts_platform/pad2align.sh -n 2048 ram_tmp
+cat ram_tmp >>u-boot.sflash
+cat u-boot.ifx >>u-boot.sflash
+rm tmp ram_tmp u-boot.ifx
diff --git a/scripts_platform/mk_key_img.pl b/scripts_platform/mk_key_img.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_key_img.pl
@@ -0,0 +1,50 @@
+#!/usr/bin/perl
+#perl script to make an image which contains the aes key
+#Revision history
+#18/02/2013 Author Wu Qi Ming
+#usage: mk_key_img.pl $(key) data.bin
+#output: data.bin
+
+use strict;
+
+#key image size, hardcoded to 256 bytes
+my $img_size=256;
+
+my $mask=0;
+my @array;
+my @key;
+my @result;
+
+my $string = $ARGV[0];
+open(OUTFILE, ">$ARGV[1]") || die("\nOutput file open fail\n");
+
+if(length($string) % 2 >0){
+   $string="0".$string;
+   }
+
+printf("key=%s\n",$string);
+
+my $range = 255;
+my $minimum = 0;
+my $rand_number;
+my $mask='';
+
+my @ascii = unpack("(A2)*", $string);
+my $arg;
+foreach $arg (@ascii){
+   $rand_number = int(rand($range)) + $minimum;
+   $arg = hex($arg) ^ $rand_number;
+   $rand_number=sprintf("%02x",$rand_number); 
+   $mask=$mask.$rand_number;
+   $arg=sprintf("%02x",$arg);
+}
+
+printf("mask=%s\n",$mask);
+
+my $result_string = pack("(A2)*", @ascii);
+
+printf("result_string=%s\n",$result_string);
+
+printf OUTFILE pack("H*", $result_string);
+
+
diff --git a/scripts_platform/mk_ltq_header.pl b/scripts_platform/mk_ltq_header.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_ltq_header.pl
@@ -0,0 +1,255 @@
+#!/usr/bin/perl 
+#perl script to generate lantiq header 
+#Revision history
+#19/11/2014 Author Wu Qi Ming
+
+#use strict;
+use Getopt::Long;
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+my $TAG_SOCMODE=0x88000000;
+my $TAG_CHKSUM=0x99000000;
+my $TAG_LQHDR=0xAA000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+
+
+sub usage
+{
+   print "mk_ltq_header.pl --options\n";
+   print "      --bch strength         enable bch, strength 8/16/40\n";
+   print "      --col col              nand column address cycle\n";
+   print "      --row row              nand row address cycle\n";
+   print "      --pagesize pagesize    nand page size in bytes\n";
+   print "      --blocksize blocksize  nand block size in kbytes \n";
+   print "      --offset off1,off2...  offset of images\n";
+   print "      --ddr ddrconfig        ddr configuration file\n";
+   print "      --out output           output file name\n";
+   print "      --gdsnand              gigadevice spi nand\n";
+   print "      --help                 show this menu\n";
+   exit 0;
+}
+
+# setup my defaults
+my $bch      = 0;
+my $help     = 0;
+my $col      = 0;
+my $row      = 0;
+my $pagesize = 0;
+my $blocksize = 0;
+my $ddr = "";
+my $output = "";
+my @offset=();
+my $gdsnand = 0;
+
+
+GetOptions(
+    'bch=i' => \$bch,
+    'col=i' => \$col,
+    'row=i' => \$row,
+    'pagesize=s' => \$pagesize,
+    'blocksize=s' => \$blocksize,
+    'backup=i' => \$backup,
+    'ddr=s'    => \$ddr,
+    'out=s'    => \$output,
+    'offset=s' => \@offset,
+    'gdsnand' => \$gdsnand,
+    'help!'     => \$help,
+) or usage();
+
+if( $help ) {
+    usage();
+} 
+
+if($ddr eq ''){
+   print "no ddr config file specified!\n";
+   usage();
+}
+
+
+if($output eq ''){
+   print "no output file specified!\n"; 
+   usage();
+}
+
+
+if (@offset==0){
+   print "no image offset specified!\n";
+   usage();
+}
+
+if($bch==0){
+  $bch=0;
+}elsif($bch==8){
+  $bch=1;
+}elsif($bch==16){
+  $bch=3;
+}elsif($bch==40){
+  $bch=5;
+}else{
+ print "ecc strenth can only be 8/16/40\n";
+ usage();
+}
+
+
+if($pagesize eq '0x200'){
+   $pagesize=0;
+}elsif($pagesize eq '0x800'){
+   $pagesize=1;
+}elsif($pagesize eq '0x1000'){
+   $pagesize=2;
+}elsif($pagesize eq '0x2000'){
+   $pagesize=3;
+}elsif($pagesize eq '0x4000'){
+   $pagesize=4;
+}elsif($pagesize eq '0x8000'){
+   $pagesize=5;
+}elsif($pagesize==0){
+   $pagesize=0;
+}elsif($pagesize==512){
+   $pagesize=0;
+}elsif($pagesize==2048){
+   $pagesize=1;
+}elsif($pagesize==4096){
+   $pagesize=2;
+}elsif($pagesize==8192){
+   $pagesize=3;
+}elsif($pagesize==16384){
+   $pagesize=4;
+}elsif($pagesize==32768){
+   $pagesize=5;
+}else{
+  print "page size must be 512/2048/8192/16384/32768\n";
+  usage();
+}
+
+if($blocksize eq '0x4000'){
+   $blocksize=0;
+}elsif($blocksize eq '0x20000'){
+   $blocksize=1;
+}elsif($blocksize eq '0x40000'){
+   $blocksize=2;
+}elsif($blocksize eq '0x80000'){
+   $blocksize=3;
+}elsif($blocksize eq '0x100000'){
+   $blocksize=4;
+}elsif($blocksize eq '0x200000'){
+   $blocksize=5;
+}elsif($blocksize==0){
+   $blocksize=0;
+}elsif($blocksize==16){
+   $blocksize=0;
+}elsif($blocksize==128){
+   $blocksize=1;
+}elsif($blocksize==256){
+   $blocksize=2;
+}elsif($blocksize==512){
+   $blocksize=3;
+}elsif($blocksize==1024){
+   $blocksize=4;
+}elsif($blocksize==2048){
+   $blocksize=5;
+}else{
+  print "block size must be 16/128/256/512/1024/2048\n";
+  usage();
+}
+
+
+if ($gdsnand==0){
+    $gdsnand=1<<5;   
+}else{
+    $gdsnand=0;
+}
+
+
+
+open(INFILE1, "<$ddr") || die("\ninput open fail\n");
+open(OUTFILE, ">$output") || die("\nOutput file open fail\n");
+
+
+#form a REGCFG head
+$head=$TAG_REGCFG|$FLAG_SDBG|$FLAG_DBG;
+$head=$head|(0xffff-($head>>16));
+
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+             if($line!~/[;#\*]/){
+                  chomp($line);
+                  $line=~s/\t//;
+                  @array=split(/ +/,$line);
+                  $j=0;
+                  while(@array[$j]!~/\w/)
+                  {
+                    $j=$j+1;
+                  }
+                  $addr=@array[$j];
+                  $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+                  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+$head=sprintf("%08x",$head).sprintf("%08x",$count*8);
+printf OUTFILE pack("H*",$head.$string);
+
+#********************************************************************************************
+
+# note that tag-length-data format is the basis of bstrap protocol
+# length is in bytes
+my $lnmw='';
+
+$lqmwtag=$TAG_LQHDR;
+$lqmwtag=$lqmwtag|(0xffff-($lqmwtag>>16));
+@offset = split(/,/,join(',',@offset));
+
+$lqmwtag=sprintf("%08x",$lqmwtag);
+$lqmwtag=$lqmwtag.sprintf("%08x",20);
+$lqmwtag=$lqmwtag.sprintf("%02x",scalar(@offset));
+$byte=$pagesize|($blocksize<<4);
+$lqmwtag=$lqmwtag.sprintf("%02x",$byte);
+$byte=$gdsnand|(($bch>0?1:0)<<4)|(($col>0?($col-1):0)<<2)|($row>0?($row-1):0);
+$lqmwtag=$lqmwtag.sprintf("%02x%02x",$bch,$byte);
+
+my $i=0;
+for ($i=0; $i<scalar(@offset); $i++) {
+    $lqmwtag=$lqmwtag.sprintf("%08x",hex($offset[$i]));
+}
+
+for($i=0;$i<4-scalar(@offset);$i++){
+    $lqmwtag=$lqmwtag.sprintf("%08x",0);
+}
+
+#print "lqmwtag=$lqmwtag\n";
+printf OUTFILE pack("H*", $lqmwtag);
+
+
+$exehead=$TAG_START|$FLAG_SDBG;
+$exehead=$exehead|(0xffff-($exehead>>16));
+$exehead=sprintf("%08x",$exehead).sprintf("%08x%08x",0x4,0);
+printf OUTFILE pack("H*", $exehead);
+
+close(INFILE1);
+close(OUTFILE);
+
+
+
diff --git a/scripts_platform/mk_mlc_image.pl b/scripts_platform/mk_mlc_image.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_mlc_image.pl
@@ -0,0 +1,132 @@
+#!/usr/bin/perl
+
+# only works on LINUX (not for Windows)
+# this perl script does the following:
+# 1. copy input file to output file.
+# 2. pads output file to filesize 0x8000. 
+# 3. add checksum to end of file. 
+
+use strict;
+use bigint;
+
+use File::stat;
+
+
+#********************************************************************************************
+
+$ARGV[0] || go_die();
+$ARGV[1] || go_die();
+
+my $infile = $ARGV[0];
+my $outfile = $ARGV[1];
+
+my $csum = 0;
+my $csum1;
+
+my $stat;
+
+my $zero = 0;
+
+my $OUTPUTFILE;
+
+my $INFILE;
+my $WIDTH;
+my $packFormat;
+my $pack;
+my $buf;
+
+my $stat;
+
+#********************************************************************************************
+
+
+if ($stat = stat $infile) {
+    print "$infile is ", $stat->size, " bytes\n";
+} else {
+    go_die("Can't open $infile for read", 1);
+}
+
+open ($INFILE, $infile) || go_die("Can't open $infile fo read",1);
+
+binmode $INFILE;
+
+$WIDTH = 4;   # number of bytes to read per loop
+$packFormat  = "H" . 2 * $WIDTH;  # must use big "H" ie high nibble first
+
+# compute U32 addition checksum
+while ( read $INFILE, $buf, $WIDTH )
+{
+    $pack = unpack $packFormat, $buf;
+
+    #$pack = sprintf("%08X", hex($pack));  # change to upper case
+    $pack = hex($pack);
+    
+    $csum += $pack;
+    $csum &= 0xFFFFFFFF;
+}
+
+
+system ("cp $infile $outfile");
+
+open ($OUTPUTFILE, ">>$outfile") || go_die("Can't open $outfile for write",1);
+
+binmode $OUTPUTFILE;
+
+my $pad_cnt = $stat->size;
+
+if ($pad_cnt > (0x8000 - 4))
+{
+    go_die("$infile is too big for MLC image", 1);
+}
+
+if ($pad_cnt != 0)
+{
+    $pad_cnt = 0x8000 - $pad_cnt - 4;
+}
+
+$zero = pack("C", $zero);   # note that data is saved in little-endian on Intel-based PC 
+while ($pad_cnt > 0)
+{
+    print $OUTPUTFILE $zero;
+    $pad_cnt--;
+}
+
+$csum = (($csum & 0x000000FF) << 24) | (($csum & 0x0000FF00) << 8) | (($csum & 0x00FF0000) >> 8) | (($csum & 0xFF000000) >> 24);
+$csum = pack("L", $csum);   # note that data is saved in little-endian on Intel-based PC 
+print $OUTPUTFILE $csum;
+
+close ($OUTPUTFILE);
+
+if ($stat = stat $outfile) {
+    print "$outfile is ", $stat->size, " bytes\n";
+} else {
+    go_die("Can't open $outfile for read", 1);
+}
+
+#********************************************************************************************
+
+sub go_die
+{
+    my($message, $supressformat) = @_;
+
+    if ($message)
+    {
+        print "$message";
+    }
+
+    close (INFILE);
+    close (OUTFILE);
+
+    unless ($supressformat)
+    {
+        print "format is: \n";
+        print " perl mk_mlc_image.pl original.bin mlc.bin\n";
+    }
+    else
+    {
+       print "----------------------------------------------------------\n";
+    }
+
+    die ("\n");
+}
+
diff --git a/scripts_platform/mk_mxl_header.pl b/scripts_platform/mk_mxl_header.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_mxl_header.pl
@@ -0,0 +1,263 @@
+#!/usr/bin/perl
+#perl script to generate Intel AnyWAN Header
+#Revision history
+#19/11/2014 Author Wu Qi Ming
+
+#use strict;
+use Getopt::Long;
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+my $TAG_SOCMODE=0x88000000;
+my $TAG_CHKSUM=0x99000000;
+my $TAG_LQHDR=0xAA000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+
+
+sub usage
+{
+   print "mk_mxl_header.pl --options\n";
+   print "      --bch strength         enable bch, strength 8/16/40\n";
+   print "      --col col              nand column address cycle\n";
+   print "      --row row              nand row address cycle\n";
+   print "      --pagesize pagesize    nand page size in bytes\n";
+   print "      --blocksize blocksize  nand block size in kbytes \n";
+   print "      --offset off1,off2...  offset of images\n";
+   print "      --ddr ddrconfig        ddr configuration file\n";
+   print "      --out output           output file name\n";
+   print "      --gdsnand              gigadevice spi nand\n";
+   print "      --help                 show this menu\n";
+   exit 0;
+}
+
+# setup my defaults
+my $bch      = 0;
+my $help     = 0;
+my $col      = 0;
+my $row      = 0;
+my $pagesize = 0;
+my $blocksize = 0;
+my $ddr = "";
+my $output = "";
+my @offset=();
+my $gdsnand = 0;
+
+
+GetOptions(
+    'bch=i' => \$bch,
+    'col=i' => \$col,
+    'row=i' => \$row,
+    'pagesize=s' => \$pagesize,
+    'blocksize=s' => \$blocksize,
+    'backup=i' => \$backup,
+    'ddr=s'    => \$ddr,
+    'out=s'    => \$output,
+    'offset=s' => \@offset,
+    'gdsnand' => \$gdsnand,
+    'help!'     => \$help,
+) or usage();
+
+if( $help ) {
+    usage();
+} 
+
+if($ddr eq ''){
+   print "no ddr config file specified!\n";
+   usage();
+}
+
+
+if($output eq ''){
+   print "no output file specified!\n"; 
+   usage();
+}
+
+
+if (@offset==0){
+   print "no image offset specified!\n";
+   usage();
+}
+
+if($bch==0){
+  $bch=0;
+}elsif($bch==1){
+  $bch=1;
+}elsif($bch==2){
+  $bch=2;
+}elsif($bch==3){
+  $bch=3;
+}elsif($bch==4){
+  $bch=4;
+}elsif($bch==5){
+  $bch=5;
+}elsif($bch==6){
+  $bch=6;
+}elsif($bch==7){
+  $bch=7;
+}else{
+ print "ecc strenth can only be 8/16/40\n";
+ usage();
+}
+
+
+if($pagesize eq '0x200'){
+   $pagesize=0;
+}elsif($pagesize eq '0x800'){
+   $pagesize=1;
+}elsif($pagesize eq '0x1000'){
+   $pagesize=2;
+}elsif($pagesize eq '0x2000'){
+   $pagesize=3;
+}elsif($pagesize eq '0x4000'){
+   $pagesize=4;
+}elsif($pagesize eq '0x8000'){
+   $pagesize=5;
+}elsif($pagesize==0){
+   $pagesize=0;
+}elsif($pagesize==512){
+   $pagesize=0;
+}elsif($pagesize==2048){
+   $pagesize=1;
+}elsif($pagesize==4096){
+   $pagesize=2;
+}elsif($pagesize==8192){
+   $pagesize=3;
+}elsif($pagesize==16384){
+   $pagesize=4;
+}elsif($pagesize==32768){
+   $pagesize=5;
+}else{
+  print "page size must be 512/2048/8192/16384/32768\n";
+  usage();
+}
+
+if($blocksize eq '0x4000'){
+   $blocksize=0;
+}elsif($blocksize eq '0x20000'){
+   $blocksize=1;
+}elsif($blocksize eq '0x40000'){
+   $blocksize=2;
+}elsif($blocksize eq '0x80000'){
+   $blocksize=3;
+}elsif($blocksize eq '0x100000'){
+   $blocksize=4;
+}elsif($blocksize eq '0x200000'){
+   $blocksize=5;
+}elsif($blocksize==0){
+   $blocksize=0;
+}elsif($blocksize==16){
+   $blocksize=0;
+}elsif($blocksize==128){
+   $blocksize=1;
+}elsif($blocksize==256){
+   $blocksize=2;
+}elsif($blocksize==512){
+   $blocksize=3;
+}elsif($blocksize==1024){
+   $blocksize=4;
+}elsif($blocksize==2048){
+   $blocksize=5;
+}else{
+  print "block size must be 16/128/256/512/1024/2048\n";
+  usage();
+}
+
+
+if ($gdsnand==0){
+    $gdsnand=1<<5;   
+}else{
+    $gdsnand=0;
+}
+
+
+
+open(INFILE1, "<$ddr") || die("\ninput open fail\n");
+open(OUTFILE, ">$output") || die("\nOutput file open fail\n");
+
+
+#form a REGCFG head
+$head=$TAG_REGCFG|$FLAG_SDBG|$FLAG_DBG;
+$head=$head|(0xffff-($head>>16));
+
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+             if($line!~/[;#\*]/){
+                  chomp($line);
+                  $line=~s/\t//;
+                  @array=split(/ +/,$line);
+                  $j=0;
+                  while(@array[$j]!~/\w/)
+                  {
+                    $j=$j+1;
+                  }
+                  $addr=@array[$j];
+                  $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+                  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+$head=sprintf("%08x",$head).sprintf("%08x",$count*8);
+printf OUTFILE pack("H*",$head.$string);
+
+#********************************************************************************************
+
+# note that tag-length-data format is the basis of bstrap protocol
+# length is in bytes
+my $lnmw='';
+
+$lqmwtag=$TAG_LQHDR;
+$lqmwtag=$lqmwtag|(0xffff-($lqmwtag>>16));
+@offset = split(/,/,join(',',@offset));
+
+$lqmwtag=sprintf("%08x",$lqmwtag);
+$lqmwtag=$lqmwtag.sprintf("%08x",20);
+$lqmwtag=$lqmwtag.sprintf("%02x",scalar(@offset));
+$byte=$pagesize|($blocksize<<4);
+$lqmwtag=$lqmwtag.sprintf("%02x",$byte);
+$byte=$gdsnand|(($bch>0?1:0)<<4)|(($col>0?($col-1):0)<<2)|($row>0?($row-1):0);
+$lqmwtag=$lqmwtag.sprintf("%02x%02x",$bch,$byte);
+
+my $i=0;
+for ($i=0; $i<scalar(@offset); $i++) {
+    $lqmwtag=$lqmwtag.sprintf("%08x",hex($offset[$i]));
+}
+
+for($i=0;$i<4-scalar(@offset);$i++){
+    $lqmwtag=$lqmwtag.sprintf("%08x",0);
+}
+
+#print "lqmwtag=$lqmwtag\n";
+printf OUTFILE pack("H*", $lqmwtag);
+
+
+$exehead=$TAG_START|$FLAG_SDBG;
+$exehead=$exehead|(0xffff-($exehead>>16));
+$exehead=sprintf("%08x",$exehead).sprintf("%08x%08x",0x4,0);
+printf OUTFILE pack("H*", $exehead);
+
+close(INFILE1);
+close(OUTFILE);
+
+
+
diff --git a/scripts_platform/mk_mxl_tail.pl b/scripts_platform/mk_mxl_tail.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_mxl_tail.pl
@@ -0,0 +1,165 @@
+#!/usr/bin/perl 
+use bignum;
+use Getopt::Std;
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+my $TAG_SOCMODE=0x88000000;
+my $TAG_CHKSUM=0x99000000;
+my $TAG_LQHDR=0xAA000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+my $ddr="";
+my $input="";
+my $output="";
+my $jumpaddr=0;
+my $socmode=0;
+
+sub usage()
+{
+   print "mk_mxl_tail.pl -[options]\n";
+   print "   -d  ddrconfig   ddr configuration file\n";
+   print "   -i  inputfile   input file\n";
+   print "   -o  outputfile  output file\n";
+   print "   -j  address     jump address\n";
+   print "   -m  mode        soc mode 0/1/2\n"; 
+   exit;
+}
+
+
+# declare the perl command line flags/options we want to allow
+my %options=();
+getopts("d:i:o:j:m:h", \%options);
+
+usage() if $options{h};
+ 
+# test for the existence of the options on the command line.
+# in a normal program you'd do more than just print these.
+#print "-h $options{h}\n" if defined $options{h};
+#print "-j $options{j}\n" if defined $options{j};
+#print "-d $options{d}\n" if defined $options{d};
+#print "-i $options{i}\n" if defined $options{i};
+#print "-o $options{o}\n" if defined $options{o};
+#print "-m $options{m}\n" if defined $options{m};
+$ddr=$options{d} if defined $options{d};
+$input=$options{i} if defined $options{i};
+$output=$options{o} if defined $options{o};
+$jumpaddr=$options{j} if defined $options{j};
+$socmode=$options{m} if defined $options{m};
+
+
+if($input eq ''){
+   print "no input file specified!\n";
+   usage();
+}
+
+if($output eq ''){
+   print "no output file specified!\n";
+   usage();
+}
+
+
+
+open(INFILE2, "<$input") || die("\ninput open fail\n");
+open(OUTFILE, ">$output") || die("\nOutput file open fail\n");
+
+if ($ddr){
+   open(INFILE1, "<$ddr") || die("\ninput open fail\n");
+  
+   #form a REGCFG head
+   $head=$TAG_REGCFG|$FLAG_SDBG|$FLAG_DBG;
+   $head=$head|(0xffff-($head>>16));
+ 
+   $string="";
+   $count=0;
+   while ($line = <INFILE1>){
+            if($line=~/\w/){
+             if($line!~/[;#\*]/){
+                  chomp($line);
+                  $line=~s/\t//;
+                  @array=split(/ +/,$line);
+                  $j=0;
+                  while(@array[$j]!~/\w/)
+                  {
+                    $j=$j+1;
+                  }
+                  $addr=@array[$j];
+                  $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+                  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+    }
+   $head=sprintf("%08x",$head).sprintf("%08x",$count*8);
+   print OUTFILE pack("H*",$head.$string);
+}
+
+#form a TAG_DWNLD head
+$head=$TAG_DWNLD|$FLAG_SDBG|$FLAG_START;
+$head=$head|(0xffff-($head>>16));
+$head=sprintf("%08x",$head);
+$datafile_size=(-s $input) + 4;
+#printf "datafilesize=$datafile_size\n";
+$datafile_size=sprintf("%08x",$datafile_size);
+$start_address=sprintf("%08x",hex($jumpaddr));
+print OUTFILE pack("H*",$head.$datafile_size.$start_address);
+binmode(INFILE2,":raw");
+binmode(OUTFILE,":raw");
+#while(<INFILE2>){
+#  printf OUTFILE $_;
+#}
+read(INFILE2,$buf,(-s $input));
+print OUTFILE $buf;
+close(INFILE2);
+#********************************************************************************************
+
+open ($INFILE2, $input);
+binmode $INFILE2;
+$WIDTH = 4;   # number of bytes to read per loop
+$packFormat  = "H" . 2 * $WIDTH;  # must use big "H" ie high nibble first
+$chksum = 0;
+while ( read $INFILE2, $buf, $WIDTH )
+{
+    $dword = unpack $packFormat, $buf;
+    $dword = hex($dword);
+    $chksum += $dword;
+    $chksum &= 0xFFFFFFFF;
+}
+
+# note that tag-length-data format is the basis of bstrap protocol
+# length is in bytes
+
+$socmodetag=$TAG_SOCMODE;
+$socmodetag=$socmodetag|(0xffff-($socmodetag>>16));
+$socmodetag=sprintf("%08x",$socmodetag).sprintf("%08x%08x",0x4,hex($socmode));
+print OUTFILE pack("H*", $socmodetag);
+
+$cstag=$TAG_CHKSUM;
+$cstag=$cstag|(0xffff-($cstag>>16));
+$cstag=sprintf("%08x",$cstag).sprintf("%08x%08x",0x4,$chksum);
+print OUTFILE pack("H*", $cstag);
+
+$exehead=$TAG_START|$FLAG_SDBG;
+$exehead=$exehead|(0xffff-($exehead>>16));
+$exehead=sprintf("%08x",$exehead).sprintf("%08x%08x",0x4,hex($jumpaddr));
+print OUTFILE pack("H*", $exehead);
+
+
+
+
diff --git a/scripts_platform/mk_sb_envimg.sh b/scripts_platform/mk_sb_envimg.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_sb_envimg.sh
@@ -0,0 +1,78 @@
+#!/bin/bash
+#Build uboot environment block image
+#To be used in u-boot root directory of UGW package
+#Copyright (C) 2007-2010 Lantiq Asia Pacific Pte. Ltd
+#Revision history
+#10/07/2012 Wu Qi Ming Qi-Ming.Wu@lantiq.com
+#Usage: mk_sb_envimg.sh target_file
+
+# set -x
+
+packhex(){
+    PACK_DATA_LEN=`echo $1 |wc -c`
+    let PACK_DATA_LEN=$PACK_DATA_LEN-1
+    PACK_START=1
+    PACK_RESULT=
+    while [ $PACK_START -le $PACK_DATA_LEN ]
+    do
+      PACK_TMP=`echo $1 | awk '{print substr($0, '$PACK_START', 2)}'`
+      PACK_RESULT="${PACK_RESULT}\x${PACK_TMP}"
+      let PACK_START=$PACK_START+2
+    done
+    echo $PACK_RESULT
+}
+
+
+OUTPUT=$1
+
+ADDRHEX=`sed -e '/default_environment/!d' u-boot-2.sym |awk '{print substr($1,length($1)-4,5)}'`
+
+ADDR=`echo $((16#$ADDRHEX))`
+
+
+LENHEX=`sed -e '/default_environment/!d' u-boot-2.sym |awk '{print $2}'`
+
+LEN=`echo $((16#$LENHEX))`
+
+
+dd if=u-boot.bin of=env.tmp ibs=1 skip=$ADDR count=$LEN
+
+# secure boot env remove protection of some variables:
+# NOTE: hardcode for now
+# 1. ipaddr variable unprotect
+sed -i.bak 's/ipaddr=\([^\x0]\+\)\x0//' env.tmp
+# 2. ethaddr variable unprotect
+sed -i.bak 's/ethaddr=\([^\x0]\+\)\x0//' env.tmp
+# 3. serverip variable unprotect
+sed -i.bak 's/serverip=\([^\x0]\+\)\x0//' env.tmp
+# 4. fullimage variable unprotect
+sed -i.bak 's/fullimage=\([^\x0]\+\)\x0//' env.tmp
+
+# now this guy is in .config
+CONFIG_ENV_SIZE=$(grep -r CONFIG_ENV_SIZE .config | awk -F'=' '{print $2}')
+ENV_HDR_SIZE=4
+
+# REDUND=`grep -r CONFIG_ENV_REDUND .config | awk -F'=' '{print $2}'`
+# the flg ENV_REDUND is no longer in .config but definitely we use it for lgm 
+REDUND="y"
+
+if [ "$REDUND" = "y" ];then
+   ENV_HDR_SIZE=$(( ENV_HDR_SIZE += 1 ))
+fi
+ENV_SIZE=$(( CONFIG_ENV_SIZE - ENV_HDR_SIZE  ))
+
+SCRIPTDIR=${0%/*}
+$SCRIPTDIR/pad2align.sh -n ${ENV_SIZE} env.tmp
+
+CRC=`tools/envcrc env.tmp`
+
+echo -en `packhex $CRC` >$OUTPUT
+if [ "$REDUND" = "y" ];then
+   echo -en "\x1" >>$OUTPUT
+fi
+
+cat env.tmp >>$OUTPUT
+
+rm -rf env.tmp
+
+# set +x
diff --git a/scripts_platform/mk_sf.pl b/scripts_platform/mk_sf.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_sf.pl
@@ -0,0 +1,89 @@
+#!/usr/bin/perl
+#perl script to generate spi bootable u-boot using binary file
+#Revision history
+#1/7/2009 Author Wu Qi Ming
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+
+
+if(@ARGV < 2){
+	print "not enough arguments\n";
+	print "Syntax: ./mk_sf.pl config data address output\n";
+	print "example: ./mk_sf.pl ram.conf u-boot.ifx 0xa0100000 u-boot.sflash\n";
+	exit;
+}
+print "converting now, please wait...\n";
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[3]") || die("\nOutput file open fail\n");
+
+#form a REGCFG head
+$head=$TAG_REGCFG|$FLAG_SDBG|$FLAG_DBG;
+$head=$head|(0xffff-($head>>16));
+
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+$head=sprintf("%08x",$head).sprintf("%08x",$count*8);
+printf OUTFILE pack("H*",$head.$string);
+
+#form a TAG_DWNLD head
+$head=$TAG_DWNLD|$FLAG_SDBG|$FLAG_START;
+$head=$head|(0xffff-($head>>16));
+$head=sprintf("%08x",$head);
+$datafile_size=(-s $ARGV[1]) + 4;
+#printf "datafilesize=$datafile_size\n";
+$datafile_size=sprintf("%08x",$datafile_size);
+$start_address=sprintf("%08x",hex($ARGV[2]));
+printf OUTFILE pack("H*",$head.$datafile_size.$start_address);
+binmode(INFILE2,":raw");
+binmode(OUTFILE,":raw");
+#while(<INFILE2>){
+#  printf OUTFILE $_;
+#}
+read(INFILE2,$buf,(-s $ARGV[1]));
+print OUTFILE $buf;
+
+$exehead=$TAG_START|$FLAG_SDBG;
+$exehead=$exehead|(0xffff-($exehead>>16));
+$exehead=sprintf("%08x",$exehead).sprintf("%08x%08x",0x4,hex($ARGV[2]));
+
+printf OUTFILE pack("H*", $exehead);
diff --git a/scripts_platform/mk_sf_image.pl b/scripts_platform/mk_sf_image.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_sf_image.pl
@@ -0,0 +1,165 @@
+#!/usr/bin/perl 
+use bignum;
+use Getopt::Std;
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+my $TAG_SOCMODE=0x88000000;
+my $TAG_CHKSUM=0x99000000;
+my $TAG_LQHDR=0xAA000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+my $ddr="";
+my $input="";
+my $output="";
+my $jumpaddr=0;
+my $socmode=0;
+
+sub usage()
+{
+   print "mk_sf_image.pl -[options]\n";
+   print "   -d  ddrconfig   ddr configuration file\n";
+   print "   -i  inputfile   input file\n";
+   print "   -o  outputfile  output file\n";
+   print "   -j  address     jump address\n";
+   print "   -m  mode        soc mode 0/1/2\n"; 
+   exit;
+}
+
+
+# declare the perl command line flags/options we want to allow
+my %options=();
+getopts("d:i:o:j:m:h", \%options);
+
+usage() if $options{h};
+ 
+# test for the existence of the options on the command line.
+# in a normal program you'd do more than just print these.
+#print "-h $options{h}\n" if defined $options{h};
+#print "-j $options{j}\n" if defined $options{j};
+#print "-d $options{d}\n" if defined $options{d};
+#print "-i $options{i}\n" if defined $options{i};
+#print "-o $options{o}\n" if defined $options{o};
+#print "-m $options{m}\n" if defined $options{m};
+$ddr=$options{d} if defined $options{d};
+$input=$options{i} if defined $options{i};
+$output=$options{o} if defined $options{o};
+$jumpaddr=$options{j} if defined $options{j};
+$socmode=$options{m} if defined $options{m};
+
+
+if($input eq ''){
+   print "no input file specified!\n";
+   usage();
+}
+
+if($output eq ''){
+   print "no output file specified!\n";
+   usage();
+}
+
+
+
+open(INFILE2, "<$input") || die("\ninput open fail\n");
+open(OUTFILE, ">$output") || die("\nOutput file open fail\n");
+
+if ($ddr){
+   open(INFILE1, "<$ddr") || die("\ninput open fail\n");
+  
+   #form a REGCFG head
+   $head=$TAG_REGCFG|$FLAG_SDBG|$FLAG_DBG;
+   $head=$head|(0xffff-($head>>16));
+ 
+   $string="";
+   $count=0;
+   while ($line = <INFILE1>){
+            if($line=~/\w/){
+             if($line!~/[;#\*]/){
+                  chomp($line);
+                  $line=~s/\t//;
+                  @array=split(/ +/,$line);
+                  $j=0;
+                  while(@array[$j]!~/\w/)
+                  {
+                    $j=$j+1;
+                  }
+                  $addr=@array[$j];
+                  $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+                  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+    }
+   $head=sprintf("%08x",$head).sprintf("%08x",$count*8);
+   printf OUTFILE pack("H*",$head.$string);
+}
+
+#form a TAG_DWNLD head
+$head=$TAG_DWNLD|$FLAG_SDBG|$FLAG_START;
+$head=$head|(0xffff-($head>>16));
+$head=sprintf("%08x",$head);
+$datafile_size=(-s $input) + 4;
+#printf "datafilesize=$datafile_size\n";
+$datafile_size=sprintf("%08x",$datafile_size);
+$start_address=sprintf("%08x",hex($jumpaddr));
+printf OUTFILE pack("H*",$head.$datafile_size.$start_address);
+binmode(INFILE2,":raw");
+binmode(OUTFILE,":raw");
+#while(<INFILE2>){
+#  printf OUTFILE $_;
+#}
+read(INFILE2,$buf,(-s $input));
+print OUTFILE $buf;
+close(INFILE2);
+#********************************************************************************************
+
+open ($INFILE2, $input);
+binmode $INFILE2;
+$WIDTH = 4;   # number of bytes to read per loop
+$packFormat  = "H" . 2 * $WIDTH;  # must use big "H" ie high nibble first
+$chksum = 0;
+while ( read $INFILE2, $buf, $WIDTH )
+{
+    $dword = unpack $packFormat, $buf;
+    $dword = hex($dword);
+    $chksum += $dword;
+    $chksum &= 0xFFFFFFFF;
+}
+
+# note that tag-length-data format is the basis of bstrap protocol
+# length is in bytes
+
+$socmodetag=$TAG_SOCMODE;
+$socmodetag=$socmodetag|(0xffff-($socmodetag>>16));
+$socmodetag=sprintf("%08x",$socmodetag).sprintf("%08x%08x",0x4,hex($socmode));
+printf OUTFILE pack("H*", $socmodetag);
+
+$cstag=$TAG_CHKSUM;
+$cstag=$cstag|(0xffff-($cstag>>16));
+$cstag=sprintf("%08x",$cstag).sprintf("%08x%08x",0x4,$chksum);
+printf OUTFILE pack("H*", $cstag);
+
+$exehead=$TAG_START|$FLAG_SDBG;
+$exehead=$exehead|(0xffff-($exehead>>16));
+$exehead=sprintf("%08x",$exehead).sprintf("%08x%08x",0x4,hex($jumpaddr));
+printf OUTFILE pack("H*", $exehead);
+
+
+
+
diff --git a/scripts_platform/mk_vr9_nand.sh b/scripts_platform/mk_vr9_nand.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_vr9_nand.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+touch scripts_platform/dummy
+scripts_platform/sgct scripts_platform/dummy board/vr9/bootrom.rec u-boot.nand
+scripts_platform/pad2align.sh -n 2048 u-boot.nand
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' ram.conf | awk '{printf "%s %s\n", $1, $2}' >tmp
+scripts_platform/gen_ram.pl tmp ram_tmp
+scripts_platform/pad2align.sh -n 2048 ram_tmp
+cat ram_tmp >>u-boot.nand
+cat u-boot.ifx >>u-boot.nand
+rm tmp ram_tmp u-boot.ifx
diff --git a/scripts_platform/mk_vr9_sf.sh b/scripts_platform/mk_vr9_sf.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mk_vr9_sf.sh
@@ -0,0 +1,10 @@
+#!/bin/sh
+touch scripts_platform/dummy
+scripts_platform/sgct scripts_platform/dummy board/vr9/sf_bootrom.rec u-boot.sflash
+scripts_platform/pad2align.sh -n 2048 u-boot.sflash
+sed -e '/^[[:space:]]*$/d' -e '/^#/d' -e's/0x//g' ram.conf | awk '{printf "%s %s\n", $1, $2}' >tmp
+scripts_platform/gen_ram.pl tmp ram_tmp
+scripts_platform/pad2align.sh -n 2048 ram_tmp
+cat ram_tmp >>u-boot.sflash
+cat u-boot.ifx >>u-boot.sflash
+rm tmp ram_tmp u-boot.ifx
diff --git a/scripts_platform/mktestfile b/scripts_platform/mktestfile
new file mode 100755
--- /dev/null
+++ b/scripts_platform/mktestfile
@@ -0,0 +1,14 @@
+#!/bin/sh
+#for 16bit Verilog Memory Model
+usage() {
+echo "$0 file_name start_address"
+}
+
+START_ADDRESS=$2
+SOURCE_FILE=$1
+
+scripts_platform/ikos_ram_ddr_file_gen ${SOURCE_FILE} ${START_ADDRESS} $3
+
+cp -f ${SOURCE_FILE}.txt.00 grx500_ddr2_h.asc
+cp -f ${SOURCE_FILE}.txt.01 grx500_ddr2_l.asc
+cp -f ${SOURCE_FILE}.txt.02 grx500_ddr3.asc
diff --git a/scripts_platform/pad2align.sh b/scripts_platform/pad2align.sh
new file mode 100755
--- /dev/null
+++ b/scripts_platform/pad2align.sh
@@ -0,0 +1,65 @@
+#!/bin/bash
+#pad file to align with specific alignments
+#Revision history
+#30/4/2009 Author: Wu Qi Ming Qi-Ming.Wu@infineon.com
+#26/08/2011 Modified to accept hex number input  Wu Qi Ming Qi-Ming.Wu@lantiq.com
+
+Usage(){
+  echo "Usage: pad2align [option]...[file]..."
+  echo "Pad file to align with specified number of bytes"
+  echo "-n  --number bytes    specify alignment boundary"
+  echo "-h  --help            print help information"
+  return
+}
+
+ALIGNMENT=
+ALIGNFILE=
+
+parse_args() {
+  while [ "$#" -gt "0" ]
+  do
+     case $1 in
+	        --number | -n)
+		        ALIGNMENT=$2
+		        ALIGNFILE=$3		
+				;;
+			--help | -h)
+				Usage
+				exit 1
+				;;
+	 esac			
+	 shift
+  done
+  return
+}
+ 
+
+
+parse_args $@
+
+if [ "$ALIGNFILE" == "" ]; then
+      echo "no file specified!"
+	  exit 1;
+fi
+
+TMP=`echo $2 | sed -n "/0x/p"`
+if [ "$TMP" ];
+then
+   TMP=`echo $2 | sed "s/0x//g"`
+   TMP=${TMP^^}
+   ALIGNMENT=`echo 'ibase=16;' $TMP | bc`
+else
+   ALIGNMENT=$2
+fi
+
+
+FILESIZE=`wc -c $ALIGNFILE | awk '{print $1}'`
+MODULO=`expr $FILESIZE % $ALIGNMENT`
+
+
+if [ $MODULO != 0 ];then
+  PADSIZE=`expr $ALIGNMENT - $MODULO` 
+  dd if=/dev/zero of=$ALIGNFILE.tmppad bs=$PADSIZE count=1
+  cat $ALIGNFILE.tmppad >>$ALIGNFILE
+  rm $ALIGNFILE.tmppad
+fi
diff --git a/scripts_platform/sgct b/scripts_platform/sgct
new file mode 100755
--- /dev/null
+++ b/scripts_platform/sgct
@@ -0,0 +1,131 @@
+#!/usr/bin/perl
+#perl script to generate spi bootable u-boot
+#Revision history
+#03/27/08 Author Wu Qi Ming
+
+my $TAG_DEBUG=0x11000000;
+my $TAG_REGCFG=0x22000000;
+my $TAG_IDWNLD=0x33000000;
+my $TAG_CDWNLD=0x44000000;
+my $TAG_DWNLD=0x55000000;
+my $TAG_IFCFG=0x66000000;
+my $TAG_START=0x77000000;
+
+my $FLAG_RST=0x00800000;
+my $FLAG_CFG=0x00700000;
+my $FLAG_CFG2=0x00400000;
+my $FLAG_CFG1=0x00200000;
+my $FLAG_CFG0=0x00100000;
+my $FLAG_SDBG=0x00080000;
+my $FLAG_DBG=0x00040000;
+my $FLAG_DEC=0x00020000;
+my $FLAG_START=0x00010000;
+
+
+
+if(@ARGV < 2){
+	print "not enough arguments\n";
+	print "Syntax: ./sgct input output\n";
+	print "example: ./sgct ddr_setting.conf u-boot.srec u-boot.sflash\n";
+	exit;
+}
+print "converting now, please wait...\n";
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[2]") || die("\nOutput file open fail\n");
+
+#form a REGCFG head
+$head=$TAG_REGCFG|$FLAG_SDBG|$FLAG_DBG;
+$head=$head|(0xffff-($head>>16));
+
+$string="";
+$count=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  $string=$string.sprintf("%08x%08x",hex($addr),hex($regval));
+                  $count=$count+1;
+               }
+             }
+}
+
+$head=sprintf("%08x",$head).sprintf("%08x",$count*8);
+printf OUTFILE pack("H*",$head.$string);
+
+#form a TAG_DWNLD head
+$head=$TAG_DWNLD|$FLAG_SDBG|$FLAG_START;
+$head=$head|(0xffff-($head>>16));
+
+$firsttime=1;
+$count=0;
+while($aline=<INFILE2>){
+	$aline=uc($aline);
+	chomp($aline);
+	next if($aline=~/^S0/);
+        ($lineid, $length, $address, @bytes) = unpack"A2A2A8"."A2"x300, $aline;
+        $length = hex($length);
+        $address = hex($address);
+	$i=0;
+        if($lineid eq "S3")
+        { 
+         if($firsttime==1)
+          {
+             $addstr = sprintf("%x", $address); 
+             $count=$count+4;
+             
+             $string=$addstr;
+             $loadaddr=$address;
+             $firsttime=0;
+          }
+          $length=$length-4;
+          while($length>1){
+           $bytes[$i]=~tr/ABCDEF/abcdef/;
+	   #printf ("length=%d,i=%d,byte=%02x\n",$length,$i,hex(@bytes[$i]));
+           $string=$string.@bytes[$i];
+           #printf ("string=%s\n",$string);
+	   $length=$length-1;
+           $i=$i+1;
+           $count++;
+          }
+        }
+        elsif($lineid eq "S7")
+        {
+           $exehead=$TAG_START|$FLAG_SDBG;
+           $exehead=$exehead|(0xffff-($exehead>>16));
+           $exehead=sprintf("%08x",$exehead).sprintf("%08x%08x",0x4,$address);
+	   #print $exehead
+        }
+}
+
+
+$head=sprintf("%08x",$head).sprintf("%08x",$count);
+@bytes=unpack"A2"x8,$head;
+for ($i=0;$i<8;$i++){
+    printf OUTFILE pack("H2",$bytes[$i]);  
+}
+@bytes=unpack"A2"x$count,$string;
+for ($i=0;$i<$count;$i++){
+    printf OUTFILE pack("H2",$bytes[$i]);  
+}
+@bytes=unpack"A2"x12,$exehead;
+for ($i=0;$i<12;$i++){
+    printf OUTFILE pack("H2",$bytes[$i]);  
+}
+
+
+
+
+
diff --git a/scripts_platform/swap_bin.pl b/scripts_platform/swap_bin.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/swap_bin.pl
@@ -0,0 +1,25 @@
+#!/usr/bin/perl
+
+if(@ARGV < 2){
+     die("\n not enough arguments\n Syntax: ./swap_bin.pl input output\n");
+	}
+		
+open(INFILE, "<$ARGV[0]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[1]") || die("\nOutput file open fail\n");
+
+binmode INFILE;
+binmode OUTFILE;
+
+
+while (read (INFILE, $buffer, 4))
+{
+   ($b1,$b2,$b3,$b4)=unpack("C*",$buffer);
+   
+   print OUTFILE pack("C*",$b4);
+   print OUTFILE pack("C*",$b3);
+   print OUTFILE pack("C*",$b2);
+   print OUTFILE pack("C*",$b1);
+};
+
+close INFILE;
+close OUTFILE;
diff --git a/scripts_platform/uart_bin2asc.pl b/scripts_platform/uart_bin2asc.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/uart_bin2asc.pl
@@ -0,0 +1,226 @@
+#!/usr/bin/perl
+my $aline;
+my $lineid;
+my $length;
+my $address;
+my @bytes;
+my $addstr;
+my $chsum=0;
+my $count=0;
+my $firstime=1;
+my $i;
+my $currentaddr;
+my $tmp;
+my $holder="";
+my $loadaddr;
+my $socmode;
+my $datastr;
+
+if(@ARGV < 5){
+	print "\n not enough arguments";
+	print "\n Syntax: ./build_asc_gphy.pl <ddr-config> <u-boot.bin> <u-boot-start-addr> <gphy-firmware> <gphy-firmware-addr> <output> <socmode>\n";
+}
+
+
+
+open(INFILE1, "<$ARGV[0]") || die("\ninput open fail\n");
+open(INFILE2, "<$ARGV[1]") || die("\ninput open fail\n");
+open(GPHYFILE, "<$ARGV[3]") || die("\ninput open fail\n");
+open(OUTFILE, ">$ARGV[5]") || die("\nOutput file open fail\n");
+$socmode = hex($ARGV[6]);
+
+
+
+binmode INFILE2;
+binmode GPHYFILE;
+
+$i=0;
+while ($line = <INFILE1>){
+            if($line=~/\w/){
+	     if($line!~/[;#\*]/){
+                  if($i eq 0){
+		  printf OUTFILE ("33333333");
+		  }
+		  chomp($line);
+		  $line=~s/\t//;
+		  @array=split(/ +/,$line);
+                  $j=0;
+		  while(@array[$j]!~/\w/)
+		  {
+                    $j=$j+1;
+
+		  }
+		  $addr=@array[$j];
+	          $regval=@array[$j+1];
+                  $addr=~s/0x//;
+                  $regval=~s/0x//;
+		  printf OUTFILE ("%08x%08x",hex($addr),hex($regval));
+                  $i=$i+1;
+		  if($i eq 8)
+		  {
+                      $i=0;
+		      printf OUTFILE ("\n");
+		  }
+
+               }
+             }
+
+	    }
+
+        while($i lt 8 && $i gt 0){
+            	printf OUTFILE "00"x8;
+		    $i=$i+1;
+		}
+
+###################
+# u-boot-gphy.bin #
+###################
+
+$i=0;
+$addr=$ARGV[2];
+$addr=hex($addr);
+$loadaddr = sprintf("%x",$addr);
+
+
+
+while (read (INFILE2, $buffer, 4))
+{
+   if(($i % 16) eq 0)
+   {
+	if($ARGV[0] eq "dummy")
+	{
+		if($firstime eq 1)
+		{
+     			printf OUTFILE ("%08x",$addr);
+			$firstime = 0;
+		}
+		else
+		{
+     			printf OUTFILE ("\n%08x",$addr);
+				
+		}
+	}
+	else
+	{
+     		printf OUTFILE ("\n%08x",$addr);
+
+	}
+
+	 $addrstr = sprintf("%08x", $addr);
+     addchsum($addrstr);
+     $addr+=0x40;
+   }
+   $i+=1;
+   $data=unpack("H*",$buffer);
+   $data=hex($data);
+   printf OUTFILE ("%08x",$data);
+   $datastr = sprintf("%08x", $data);
+   addchsum($datastr);
+}
+
+while ( ($i % 16) != 0 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+################
+# gphyfirmware #
+################
+
+$i=0;
+$addr=$ARGV[4];
+$addr=hex($addr);
+
+
+
+if($ARGV[3] eq "dummy")
+{
+}
+else
+{
+
+while (read (GPHYFILE, $buffer, 4))
+{
+   if(($i % 16) eq 0)
+   {
+     printf OUTFILE ("\n%08x",$addr);
+     $addrstr = sprintf("%08x", $addr);
+     addchsum($addrstr);
+     $addr+=0x40;
+   }
+   $i+=1;
+   $data=unpack("H*",$buffer);
+   $data=hex($data);
+   printf OUTFILE ("%08x",$data);
+   $datastr = sprintf("%08x", $data);
+   addchsum($datastr);
+}
+
+
+while ( ($i % 16) != 0 )
+{
+   printf OUTFILE ("%08x",0);
+   $i+=1;
+}
+
+}
+
+
+
+printf OUTFILE ("\n");
+
+
+##############
+# SOCMODE_IND
+##############
+print OUTFILE "55"x4;
+$socmode = sprintf("%08X", $socmode);
+print OUTFILE $socmode;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+
+##############
+# CHECKSUM_IND
+##############
+print OUTFILE "11"x4;
+use integer;
+$chsum=$chsum & 0xffffffff;
+$chsum = sprintf("%X", $chsum);
+$chsum = "0"x(8-length($chsum)).$chsum;
+$chsum =~tr/ABCDEF/abcdef/;
+print OUTFILE $chsum;
+print OUTFILE "00"x60;
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+##############
+# TERMINATING_ADDR
+##############
+print OUTFILE "99"x4;
+print OUTFILE $loadaddr;
+
+$datafile_size=(-s $ARGV[1]);
+printf OUTFILE ("%08x",$datafile_size);
+print OUTFILE "00"x56;
+
+print OUTFILE "\n";
+#print OUTFILE "\r";
+
+
+close OUTFILE;
+#END of Program
+
+
+
+sub addchsum{
+	my $cc=$_[0];
+	$holder=$holder.$cc;
+	if(length($holder)==8){
+		$holder = hex($holder);
+		$chsum+=$holder;
+		$holder="";
+	}
+}
+#END
+
+
diff --git a/scripts_platform/vr9_ddr.pl b/scripts_platform/vr9_ddr.pl
new file mode 100755
--- /dev/null
+++ b/scripts_platform/vr9_ddr.pl
@@ -0,0 +1,101 @@
+#!/usr/bin/perl -w
+
+use strict;
+
+####################################################################################################
+# this perl script is used to convert vr9 chiptest/palladium image to support new ddr model in vr9 #
+####################################################################################################
+
+my $versioninfo = "V1.0.0 29 Oct 2008";
+
+my $infile = "";
+my $outfile = "";
+
+my $read_line;
+my $line1;
+my $line2;
+my $line3;
+my $line4;
+
+#
+# Verify the input/output parameters 
+#
+
+if (($#ARGV + 1) != 2 ) {
+    die "Usage: $0 <input asc file> <output asc file>\n"
+}
+
+$infile = shift(@ARGV);
+$outfile = shift(@ARGV);
+
+#
+# Read/Write file handler
+#
+open (INFILE, $infile) || go_die("Can't open $infile fo read :$!", 1);
+
+open (OUTFILE, ">$outfile") || go_die("Can't open $outfile for write :$!", 1);
+
+#
+# Force it to binary mode 
+#
+binmode (INFILE);
+
+binmode (OUTFILE);
+
+#
+# to skip @00000000, so that it still inherits the original address
+#
+$read_line = <INFILE>;  
+print OUTFILE $read_line;
+while (1) {
+    
+    if (eof(INFILE)){
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }
+    $line1 = <INFILE>;
+    if (eof(INFILE)){
+        print OUTFILE $line1;
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }    
+    $line2 = <INFILE>;
+    if (eof(INFILE)){
+        print OUTFILE $line1;
+        print OUTFILE $line2;        
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }   
+    $line3 = <INFILE>;
+    
+    if (eof(INFILE)){
+        print OUTFILE $line3;
+        print OUTFILE $line1;
+        print OUTFILE $line2;        
+        go_die ("$0: Convert $infile to $outfile", 1)
+    }    
+    $line4 = <INFILE>;    
+    
+    print OUTFILE $line3;
+    print OUTFILE $line4;
+    print OUTFILE $line1;
+    print OUTFILE $line2;
+
+}
+
+#********************************************************************************************
+
+sub go_die
+{
+    my($message, $supressformat) = @_;
+
+    if ($message) {
+        print "$message";
+    }
+
+    close (INFILE);
+    close (OUTFILE);
+    
+    print " done\n";
+    exit (0);
+}
+
+
+
diff --git a/tools/Kconfig b/tools/Kconfig
--- a/tools/Kconfig
+++ b/tools/Kconfig
@@ -14,6 +14,10 @@ config TOOLS_CRC32
 	help
 	  Enable CRC32 support in the tools builds
 
+config TOOLS_HOST_CRC32
+	bool "Compile CHD CRC image tool"
+	default y
+
 config TOOLS_LIBCRYPTO
 	bool "Use OpenSSL's libcrypto library for host tools"
 	default y
diff --git a/tools/Makefile b/tools/Makefile
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -35,6 +35,7 @@ CONFIG_ARCH_SUNXI = y
 endif
 
 subdir-$(HOST_TOOLS_ALL) += gdb
+subdir-$(CONFIG_VENDOR_MAXLINEAR) += mxltools/bch
 
 # Merge all the different vars for envcrc into one
 ENVCRC-$(CONFIG_ENV_IS_EMBEDDED) = y
@@ -44,6 +45,8 @@ ENVCRC-$(CONFIG_ENV_IS_IN_ONENAND) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_NAND) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_NVRAM) = y
 ENVCRC-$(CONFIG_ENV_IS_IN_SPI_FLASH) = y
+ENVCRC-$(CONFIG_ENV_IS_IN_MMC) = y
+ENVCRC-$(CONFIG_ENV_IS_IN_UBI) = y
 CONFIG_BUILD_ENVCRC ?= $(ENVCRC-y)
 
 hostprogs-$(CONFIG_SPL_GENERATE_ATMEL_PMECC_HEADER) += atmel_pmecc_params
@@ -53,8 +56,12 @@ hostprogs-$(CONFIG_VIDEO_LOGO) += bmp_lo
 HOSTCFLAGS_bmp_logo.o := -pedantic
 
 hostprogs-$(CONFIG_BUILD_ENVCRC) += envcrc
+HOSTCFLAGS_envcrc.o += -include $(srctree)/include/generated/autoconf.h
 envcrc-objs := envcrc.o lib/crc32.o env/embedded.o lib/sha1.o
 
+hostprogs-$(CONFIG_TOOLS_HOST_CRC32) += hostcrc32
+hostcrc32-objs := lib/crc32.o crctool.o
+
 hostprogs-$(CONFIG_CMD_NET) += gen_eth_addr
 HOSTCFLAGS_gen_eth_addr.o := -pedantic
 
@@ -174,8 +181,8 @@ endif
 ifneq ($(CONFIG_MX23)$(CONFIG_MX28)$(CONFIG_ARMADA_38X)$(CONFIG_TOOLS_LIBCRYPTO),)
 HOSTCFLAGS_kwbimage.o += \
 	$(shell pkg-config --cflags libssl libcrypto 2> /dev/null || echo "")
-HOSTLDLIBS_mkimage += \
-	$(shell pkg-config --libs libssl libcrypto 2> /dev/null || echo "-lssl -lcrypto")
+# fixes issue with OpenWRT build, this is needed for dumpimage
+HOSTLDLIBS_mkimage += -lssl -lcrypto
 
 # OS X deprecate openssl in favour of CommonCrypto, supress deprecation
 # warnings on those systems
diff --git a/tools/crctool.c b/tools/crctool.c
new file mode 100644
--- /dev/null
+++ b/tools/crctool.c
@@ -0,0 +1,78 @@
+#include <errno.h>
+#include <stdio.h>
+
+/* Copyright (c) 2019, Intel Corporation.
+ *
+ * Host crc32 wrapper software
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <u-boot/crc.h>
+
+void help(char *filename)
+{
+	printf("%s input.bin output.bin\n", filename);
+}
+
+int main(int argc, char *argv[])
+{
+	FILE *fin = NULL;
+	FILE *fout = NULL;
+	int filesize;
+	int ret;
+	unsigned char *data = (unsigned char *)NULL;
+	uint32_t *output = (uint32_t *)NULL;
+	uint32_t crc32_value;
+
+	if (argc != 3)
+	{
+		help(argv[0]);
+		return 0;
+	}    
+
+	if ((fin = fopen(argv[1], "rb")) == NULL)
+	{
+		printf("File error : %s\n", argv[1]);
+	} 
+
+	if ((fout = fopen(argv[2], "wb+")) == NULL)
+	{
+		printf("File error : %s\n", argv[2]);
+	} 
+
+	// determine filesize of input file
+	fseek(fin, 0, SEEK_END);
+	filesize = ftell(fin);
+	fseek(fin, 0, SEEK_SET);
+	
+	printf("input filesize = %d\n", filesize);
+	
+	data = malloc(filesize+4);
+	
+	ret = fread(data, filesize, 1, fin);
+	if (ret)
+		printf("Nothing read\n");
+
+	crc32_value = crc32(0, data, filesize);
+
+	printf("crc32 = 0x%08x\n", crc32_value);
+	
+	output = (uint32_t *)data;
+	output[filesize/4] = crc32_value;
+	
+	fwrite(data, (filesize+4), 1, fout);
+
+	free(data);
+	data = NULL;
+
+	fclose(fin);
+	fclose(fout);
+	
+	return 0;
+}
+
diff --git a/tools/default_image.c b/tools/default_image.c
--- a/tools/default_image.c
+++ b/tools/default_image.c
@@ -26,7 +26,7 @@ static image_header_t header;
 
 static int image_check_image_types(uint8_t type)
 {
-	if (((type > IH_TYPE_INVALID) && (type < IH_TYPE_FLATDT)) ||
+	if (((type > IH_TYPE_INVALID) && (type <= IH_TYPE_UBOOT)) ||
 	    (type == IH_TYPE_KERNEL_NOLOAD) || (type == IH_TYPE_FIRMWARE_IVT))
 		return EXIT_SUCCESS;
 	else
