# HG changeset patch
# Parent  a78f70c5dd43203e11127d0ce8aee80e1bc074c0

diff --git a/lib/bootstrap/LzmaDecode.c b/lib/bootstrap/LzmaDecode.c
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/LzmaDecode.c
@@ -0,0 +1,621 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+//#include <config.h>
+
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+
+#if 0
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return result; } \
+  BufferLim = Buffer + size; if (size == 0) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }}
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { return result; } \
+  BufferLim = Buffer + size; if (size == 0) { return LZMA_RESULT_DATA_ERROR; } }}
+#endif
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#if 0
+#define RC_TEST { if (Buffer == BufferLim) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }
+#else
+#define RC_TEST { if (Buffer == BufferLim) { return LZMA_RESULT_DATA_ERROR; } }
+#endif
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+            {
+			  
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+              printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+              return LZMA_RESULT_DATA_ERROR;
+            }
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+      {
+		
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+        printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
+
diff --git a/lib/bootstrap/LzmaDecode.h b/lib/bootstrap/LzmaDecode.h
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/LzmaDecode.h
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
diff --git a/lib/bootstrap/LzmaTypes.h b/lib/bootstrap/LzmaTypes.h
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/LzmaTypes.h
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+typedef size_t SizeT;
+#else
+typedef UInt32 SizeT;
+#endif
+#endif
+
+#endif
diff --git a/lib/bootstrap/LzmaWrapper.c b/lib/bootstrap/LzmaWrapper.c
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/LzmaWrapper.c
@@ -0,0 +1,237 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.c
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#define LZMA_NO_STDIO
+#ifndef LZMA_NO_STDIO
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+//#include <config.h>
+#include <common.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+
+#include "LzmaDecode.h"
+#include "LzmaWrapper.h"
+
+//#define DEBUG_ENABLE_BOOTSTRAP_PRINTF
+
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+static const char *kCantReadMessage = "Can not read from source buffer";
+static const char *kCantAllocateMessage = "Not enough buffer for decompression";
+#endif
+
+static size_t rpos=0;
+
+static int MyReadFileAndCheck(unsigned char *src, void *dest, size_t size)
+{
+  if (size == 0)
+    return 0;
+#if defined(CONFIG_X86)
+  asm("sfence");
+#else
+  asm("sync");
+#endif
+  memcpy(dest, src + rpos, size);
+  rpos += size;
+  return 1;
+}
+
+int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need >= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0;
+  SizeT outSizeFull;
+  unsigned char *outStream;
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+  rpos = 0;
+
+  SizeT compressedSize;
+  unsigned char *inStream;
+
+  CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+  int res = 1;
+
+  if (sizeof(UInt32) < 4)
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("LZMA decoder needs correct UInt32\n");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  {
+    long length=s_len;
+    if ((long)(SizeT)length != length)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Too big compressed stream\n");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    compressedSize = (SizeT)(length - (LZMA_PROPERTIES_SIZE + 8));
+  }
+
+  /* Read LZMA properties for compressed stream */
+#if defined(CONFIG_X86)
+  asm("sfence");
+#else
+  asm("sync");
+#endif
+  if (!MyReadFileAndCheck(source, properties, sizeof(properties)))
+  {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("%s\n", kCantReadMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Read uncompressed size */
+  {
+    int i;
+    for (i = 0; i < 8; i++)
+    {
+      unsigned char b;
+      if (!MyReadFileAndCheck(source, &b, 1))
+      {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+        printf("%s\n", kCantReadMessage);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+      if (b != 0xFF)
+        waitEOS = 0;
+      if (i < 4)
+        outSize += (UInt32)(b) << (i * 8);
+      else
+        outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+    }
+    
+    if (waitEOS)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Stream with EOS marker is not supported");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    outSizeFull = (SizeT)outSize;
+    if (sizeof(SizeT) >= 8)
+      outSizeFull |= (((SizeT)outSizeHigh << 16) << 16);
+    else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Too big uncompressed stream");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+  {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("Incorrect stream properties");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+  if (outSizeFull == 0)
+    outStream = 0;
+  else
+  {
+    if (outSizeFull > (int)d_len)
+      outStream = 0;
+    else
+      outStream = dest;
+  }
+
+  if (compressedSize == 0)
+    inStream = 0;
+  else
+  {
+    if ((compressedSize+rpos) > s_len )
+      inStream = 0;
+    else
+      inStream = source + rpos;
+  }
+
+  if (state.Probs == 0 
+    || (outStream == 0 && outSizeFull != 0)
+    || (inStream == 0 && compressedSize != 0)
+    )
+  {
+    free(state.Probs);
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("%s\n", kCantAllocateMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Decompress */
+  if(compressedSize != 0)
+  {
+    SizeT inProcessed = 0;
+    SizeT outProcessed = 0;
+    res = LzmaDecode(&state,
+      inStream, compressedSize, &inProcessed,
+      outStream, outSizeFull, &outProcessed);
+    if (res != 0)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("\nDecoding error = %d\n", res);
+#endif
+      res = 1;
+    }
+    else
+    {
+      *d_len = outProcessed;
+    }
+  }
+
+  free(state.Probs);
+  return res;
+}
+
diff --git a/lib/bootstrap/LzmaWrapper.h b/lib/bootstrap/LzmaWrapper.h
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/LzmaWrapper.h
@@ -0,0 +1,36 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.h
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#ifndef  __LZMA_WRAPPER_H__
+#define  __LZMA_WRAPPER_H__
+
+#ifndef LZMA_RESULT_OK
+#define LZMA_RESULT_OK 0
+#endif
+#ifndef LZMA_RESULT_DATA_ERROR
+#define LZMA_RESULT_DATA_ERROR 1
+#endif
+
+extern int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len);
+
+#endif /*__LZMA_WRAPPER_H__*/
diff --git a/lib/bootstrap/Makefile b/lib/bootstrap/Makefile
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/Makefile
@@ -0,0 +1,66 @@
+-include include/config/auto.conf
+
+ifdef CONFIG_NAND_BOOT
+archdir = $(srctree)/arch/$(ARCH)/mach-lantiq/$(CONFIG_SYS_SOC)
+curdir = $(srctree)/lib/bootstrap
+OBJS = $(srctree)/lib/string.o $(curdir)/LzmaDecode.o
+OBJS += $(curdir)/LzmaWrapper.o
+OBJS += $(srctree)/lib/crc32.o $(archdir)/start_uncomp.o
+OBJS += $(srctree)/lib/ctype.o $(curdir)/nand_spl_board.o
+DEPENDS = depends
+LIB = libbootstrap.a
+
+INCLUDEDIR = -Iinclude -I$(srctree)/arch/mips/include \
+			-I$(srctree)/arch/mips/include/asm/mach-generic \
+			-I$(srctree)/include
+
+CFLAGS = $(UBOOTINCLUDE)
+
+CFLAGS +=  -g  -Os -fomit-frame-pointer -D__KERNEL__ -Wall -Wstrict-prototypes -Wno-format-security \
+		-fno-builtin -ffreestanding -Os -fno-stack-protector \
+		-fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral \
+		-EB -mabi=32 -D__MIPS__ -G 0 -mabicalls -fpic \
+		-msoft-float -ffunction-sections -fdata-sections
+
+all: $(DEPENDS) $(LIB)
+
+$(DEPENDS): $(curdir)/LzmaDecode.o $(curdir)/LzmaWrapper.o $(curdir)/nand_spl_board.o \
+		$(archdir)/start_uncomp.o $(srctree)/lib/string.o \
+		$(srctree)/lib/ctype.o $(srctree)/lib/crc32.o
+
+$(srctree)/lib/string.o:
+	$(CC) $(PLATFORM_CPPFLAGS) $(CFLAGS) $(INCLUDEDIR) $(@:.o=.c) -c -o $@
+
+$(srctree)/lib/ctype.o:
+	$(CC) $(PLATFORM_CPPFLAGS) $(CFLAGS) $(INCLUDEDIR) $(@:.o=.c) -c -o $@
+
+$(srctree)/lib/crc32.o:
+	$(CC) $(PLATFORM_CPPFLAGS) $(CFLAGS) $(INCLUDEDIR) $(@:.o=.c) -c -o $@
+
+$(archdir)/start_uncomp.o:
+	$(CC) $(PLATFORM_CPPFLAGS) $(CFLAGS) $(INCLUDEDIR) $(@:.o=.c) -c -o $@
+
+$(curdir)/LzmaDecode.o:
+	$(CC) $(PLATFORM_CPPFLAGS) $(CFLAGS) $(INCLUDEDIR) $(@:.o=.c) -c -o $@
+
+$(curdir)/LzmaWrapper.o:
+	$(CC) $(PLATFORM_CPPFLAGS) $(CFLAGS) $(INCLUDEDIR) $(@:.o=.c) -c -o $@
+
+$(curdir)/nand_spl_board.o:
+	$(CC) $(PLATFORM_CPPFLAGS) $(CFLAGS) $(INCLUDEDIR) $(@:.o=.c) -c -o $@
+
+$(archdir)/start_uncomp.o:
+	$(CC) -D__ASSEMBLY__ $(CFLAGS) $(INCLUDEDIR) $(@:.o=.S) -c -o $@
+
+$(LIB): $(DEPENDS)
+	$(AR) crv $(curdir)/$@ $(OBJS)
+
+endif
+
+obj-$(CONFIG_SPI_BOOT) += LzmaDecode.o LzmaWrapper.o
+obj-$(CONFIG_QSPI_BOOT) += LzmaDecode.o LzmaWrapper.o
+
+ifdef CONFIG_SPL_BUILD
+obj-$(CONFIG_NOR_BOOT) += bootstrap_board.o LzmaDecode.o LzmaWrapper.o
+endif
+
diff --git a/lib/bootstrap/bootstrap_board.c b/lib/bootstrap/bootstrap_board.c
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/bootstrap_board.c
@@ -0,0 +1,309 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <stdio_dev.h>
+#include <timestamp.h>
+#include <version.h>
+#include <net.h>
+#include <environment.h>
+
+#include <lzma/LzmaTypes.h>
+#include <lzma/LzmaDec.h>
+#include <lzma/LzmaTools.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define	TOTAL_MALLOC_LEN	CONFIG_SYS_MALLOC_LEN
+
+#undef DEBUG
+
+#define REG32(addr)           *((volatile u32 *)(addr))
+
+extern ulong uboot_end_data;
+extern ulong uboot_end;
+
+static int init_func_ram (void)
+{
+	gd->ram_size =(1024*1024*CONFIG_IFX_MEMORY_SIZE);
+    return (0);
+}
+
+
+int checkboard (void)
+{
+     ulong addr, addr_sp;
+    
+#ifdef CONFIG_TUNE_DDR
+  #ifdef CONFIG_LTQ_BOOT_FROM_NOR
+   if(REG32(CONFIG_TUNING_STATUS)==0x0 ||REG32(CONFIG_TUNING_STATUS)==0x1 || REG32(CONFIG_TUNING_STATUS)==0x2){
+       return 0; /*already tuned, return*/
+    }
+   else{
+   /*not tuned, ddr need to be tuned*/
+   addr_sp=CONFIG_TUNING_SP;
+   addr=CONFIG_DDR_TUNING_TEXT_BASE;
+   relocate_code (addr_sp, 0, addr);
+  }
+ #endif
+#endif
+
+     return 0;
+}
+
+static int initf_malloc(void)
+{
+#ifdef CONFIG_SYS_MALLOC_F_LEN
+    assert(gd->malloc_base);    /* Set up by crt0.S */
+    gd->malloc_limit = CONFIG_SYS_MALLOC_F_LEN;
+    gd->malloc_ptr = 0;
+#endif
+
+    return 0;
+}
+
+/*
+ * Breath some life into the board...
+ *
+ * The first part of initialization is running from Flash memory;
+ * its main purpose is to initialize the RAM so that we
+ * can relocate the monitor code to RAM.
+ */
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependend #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+init_fnc_t *init_sequence[] = {
+	init_func_ram,
+	checkboard,
+	initf_malloc,
+	NULL,
+};
+
+void board_init_f(ulong bootflag)
+{
+	gd_t gd_data, *id;
+	bd_t *bd;
+	init_fnc_t **init_fnc_ptr;
+	ulong addr, addr_sp, len = (ulong)&uboot_end - CONFIG_BOOTSTRAP_TEXT_BASE;
+	ulong *s;
+
+	/* Pointer is writable since we allocated a register for it.
+	 */
+	gd = &gd_data;
+	/* compiler optimization barrier needed for GCC >= 3.4 */
+	__asm__ __volatile__("": : :"memory");
+
+	memset ((void *)gd, 0, sizeof (gd_t));
+
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang();
+		}
+	}
+
+	//while((REG32(0xBE2300f0) != 0xbabeface));
+
+	/*
+	 * Now that we have DRAM mapped and working, we can
+	 * relocate the code and continue running from DRAM.
+	 */
+	addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;
+
+	/* We can reserve some RAM "on top" here.
+	 */
+
+	/* round down to next 4 kB limit.
+	 */
+	addr &= ~(4096 - 1);
+	debug ("Top of RAM usable for U-Boot at: %08lx\n", addr);
+
+	/* Reserve memory for U-Boot code, data & bss
+	 * round down to next 64 kB limit
+	 */
+	addr -= len;
+	addr &= ~(64 * 1024 - 1);
+    
+	debug ("Reserving %ldk for U-Boot at: %08lx\n", len >> 10, addr);
+
+	 /* Reserve memory for malloc() arena.
+	 */
+	addr_sp = addr - TOTAL_MALLOC_LEN;
+	debug ("Reserving %dk for malloc() at: %08lx\n",
+			TOTAL_MALLOC_LEN >> 10, addr_sp);
+
+	/*
+	 * (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr_sp -= sizeof(bd_t);
+	bd = (bd_t *)addr_sp;
+	gd->bd = bd;
+	debug ("Reserving %zu Bytes for Board Info at: %08lx\n",
+			sizeof(bd_t), addr_sp);
+
+	addr_sp -= sizeof(gd_t);
+	id = (gd_t *)addr_sp;
+	debug ("Reserving %zu Bytes for Global Data at: %08lx\n",
+			sizeof (gd_t), addr_sp);
+
+	/* Reserve memory for boot params.
+	 */
+	addr_sp -= CONFIG_SYS_BOOTPARAMS_LEN;
+	bd->bi_boot_params = addr_sp;
+	debug ("Reserving %dk for boot params() at: %08lx\n",
+			CONFIG_SYS_BOOTPARAMS_LEN >> 10, addr_sp);
+
+	/*
+	 * Finally, we set up a new (bigger) stack.
+	 *
+	 * Leave some safety gap for SP, force alignment on 16 byte boundary
+	 * Clear initial stack frame
+	 */
+	addr_sp -= 16;
+	addr_sp &= ~0xF;
+	s = (ulong *)addr_sp;
+	*s-- = 0;
+	*s-- = 0;
+	addr_sp = (ulong)s;
+	debug ("Stack Pointer at: %08lx\n", addr_sp);
+
+	/*
+	 * Save local variables to board info struct
+	 */
+	bd->bi_memstart	= CONFIG_SYS_SDRAM_BASE;	/* start of  DRAM memory */
+	bd->bi_memsize	= gd->ram_size;		/* size  of  DRAM memory in bytes */
+	//bd->bi_baudrate	= gd->baudrate;		/* Console Baudrate */
+
+	memcpy (id, (void *)gd, sizeof (gd_t));
+
+	relocate_code (addr_sp, id, addr);
+
+	/* NOTREACHED - relocate_code() does not return */
+}
+/************************************************************************
+ *
+ * This is the next part if the initialization sequence: we are now
+ * running from RAM and have a "normal" C environment, i. e. global
+ * data can be written, BSS has been cleared, the stack size in not
+ * that critical any more, etc.
+ *
+ ************************************************************************
+ */
+
+void board_init_r (gd_t *id, ulong dest_addr)
+{
+	ulong	addr;
+	ulong	data, len, checksum;
+	ulong	*len_ptr;
+	unsigned int destLen;
+	image_header_t header;
+	image_header_t *hdr = &header;
+	int (*fn)();
+
+	mem_malloc_init(dest_addr-TOTAL_MALLOC_LEN, TOTAL_MALLOC_LEN);
+
+#ifdef CONFIG_VENDOR_MAXLINEAR
+	gd->malloc_base = 0x2000000;
+#else
+	gd->malloc_base = 0x82000000;
+#endif
+
+	addr = (char *)(CONFIG_BOOTSTRAP_TEXT_BASE + ((ulong)&uboot_end_data - dest_addr));
+
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+		return;
+	}
+
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+	hdr->ih_hcrc = 0;
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+   asm("sync");
+#endif
+	if (crc32 (0, (char *)data, len) != checksum) {
+		return;
+	}
+
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+	asm("sync");
+#endif
+
+	data = addr + sizeof(image_header_t);
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+	asm("sync");
+#endif
+
+	len  = ntohl(hdr->ih_size);
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+	asm("sync");
+#endif
+
+	len_ptr = (ulong *)data;
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+	asm("sync");
+#endif
+
+	destLen = 0x0; 
+
+/*
+   int ret = lzmaBuffToBuffDecompress(
+                    (char*)ntohl(hdr->ih_load),
+                    &destLen, (char *)data, len);
+*/
+	lzma_inflate ((unsigned char *)data, len, (unsigned char*)ntohl(hdr->ih_load), &destLen);
+
+	fn = ntohl(hdr->ih_load);
+
+	(*fn)();
+
+	hang ();
+}
+
diff --git a/lib/bootstrap/efuse_handling.c b/lib/bootstrap/efuse_handling.c
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/efuse_handling.c
@@ -0,0 +1,203 @@
+
+#include <common.h>
+#include <command.h>
+
+//#ifdef VBG400_COMPILE_EFUSE
+
+#define VBG400_MAC_HT_EXTENSION_BASE	    0x001F0000 /*hyp_mac_top: base addr for 'select addr' and 'fix value' for shram*/
+#define VBG400_EMERALD_ENV_BASE		        0x00180000 /*CPU system I/F: base addr for 'select addr' and 'fix value' for other memories*/
+
+/*the next registers are in the "shared reg"*/
+#define VBG400_EFUSE_DATA_OFFSET		    0x120
+#define VBG400_EFUSE_ADDR_OFFSET		    0x124
+#define VBG400_EFUSE_CONTROL_OFFSET	        0x128
+#define VBG400_EFUSE_STATUS_OFFSET	        0x12C
+#define VBG400_EFUSE_PD_OFFSET		        0x13C
+/*the next registers are in the "MAC_HT_extensions"( 0x001f0000)*/
+#define VBG400_MAC_HT_EXT_SHRAM_RM_OFFSET	0x178
+#define VBG400_MAC_HT_EXT_RAMS_RM_OFFSET	0x17C
+/*the next registers are in the "emerald_env regs" (0x00180000)*/
+#define VBG400_BIST_RED_FIX_SEL_OFFSET		0xE0
+#define VBG400_RED_FIX_LOAD_VAL_OFFSET		0xEC
+/*other definitions*/
+#define VBG400_EFUSE_STATUS_CTRL_BUSY_FIELD	0x1
+#define VBG400_EFUSE_STATUS_WR_RD_FIELD		0x2
+#define VBG400_EFUSE_MEM_FIX_MAX           18
+#define VBG400_EFUSE_CALIBRATION_MAX		18
+//#define VBG400_EFUSE_BYTES_READ_MAX (VBG400_EFUSE_MEM_FIX_MAX+ VBG400_EFUSE_CALIBRATION_MAX)
+#define VBG400_EFUSE_BYTES_READ_MAX VBG400_EFUSE_MEM_FIX_MAX
+/*point to cell in array*/
+#define EFUSE_OFFSET_SELECT_INDEX   0
+#define EFUSE_OFFSET_DATA_INDEX   1
+
+/* There are some HW limitations that make the code complicated:
+*   1. fix vector (8bits) of RAM is written to one or more locations (ram type dependent).
+*      efuse_loops_per_ram[] - holds number of addresses per RAM.
+*      efuse_ram_select[][] - holds the ram index to use per RAM.
+*   2. different base address for SHRAM than other RAMs
+*      efuse_base[] is used for it.
+*   3. different offset for SHRAM than other RAMs.
+*      efuse_offset[][] - holds the offsets (addr+data) per RAM
+*/
+
+/*any uninitialize data is put in bss section. bss is outside of bootstrap image (after uboot_end_data).
+* u-boot.ltq is built of bootstrp.bin and u-boot.lzimg. When bootstrap uses uninitialized param it
+* overwrite lzma header and u-boot.lzimg.
+* Therefore, efuse_data is initialized to dummy value (1) to force it to other memory section*/
+static u32 efuse_data[VBG400_EFUSE_BYTES_READ_MAX] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+
+static u32 efuse_loops_per_ram[18] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 4};
+
+#define _NULL 0
+
+static u32 efuse_ram_select[18][4] = {{0,_NULL,_NULL,_NULL},    /*shram0*/
+                                         {2,_NULL,_NULL,_NULL},    /*shram1*/
+                                         {4,_NULL,_NULL,_NULL},    /*shram2*/
+                                         {6,_NULL,_NULL,_NULL},    /*shram3*/
+                                         {0x10,_NULL,_NULL,_NULL}, /*cpu_ram0*/
+                                         {0x12,_NULL,_NULL,_NULL}, /*cpu_ram1*/
+                                         {0x14,_NULL,_NULL,_NULL}, /*cpu_ram2*/
+                                         {0x16,_NULL,_NULL,_NULL}, /*cpu_ram3*/
+                                         {0x18,_NULL,_NULL,_NULL}, /*cpu_ram4*/
+                                         {0x1a,_NULL,_NULL,_NULL}, /*cpu_ram5*/
+                                         {0x1C,_NULL,_NULL,_NULL}, /*cpu_ram6*/
+                                         {0x1E,_NULL,_NULL,_NULL}, /*cpu_ram7*/
+                                         {0x20,_NULL,_NULL,_NULL}, /*cpu_ram8*/
+                                         {0x22,_NULL,_NULL,_NULL}, /*cpu_ram9*/
+                                         {0x24,_NULL,_NULL,_NULL}, /*cpu_ram10*/
+                                         {0x8,0x9,_NULL,_NULL},    /*dcache0*/
+                                         {0xa,0xb,_NULL,_NULL},    /*dcache1*/
+                                         {0,1,2,3}};               /*icache*/
+
+static u32 efuse_base[] =            {VBG400_MAC_HT_EXTENSION_BASE,\
+                                         VBG400_MAC_HT_EXTENSION_BASE,\
+                                         VBG400_MAC_HT_EXTENSION_BASE,\
+                                         VBG400_MAC_HT_EXTENSION_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE,\
+                                         VBG400_EMERALD_ENV_BASE};
+
+static u32 efuse_offset[18][2] =        {{VBG400_MAC_HT_EXT_SHRAM_RM_OFFSET, VBG400_MAC_HT_EXT_RAMS_RM_OFFSET},
+                                         {VBG400_MAC_HT_EXT_SHRAM_RM_OFFSET, VBG400_MAC_HT_EXT_RAMS_RM_OFFSET},
+                                         {VBG400_MAC_HT_EXT_SHRAM_RM_OFFSET, VBG400_MAC_HT_EXT_RAMS_RM_OFFSET},
+                                         {VBG400_MAC_HT_EXT_SHRAM_RM_OFFSET, VBG400_MAC_HT_EXT_RAMS_RM_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET},
+                                         {VBG400_BIST_RED_FIX_SEL_OFFSET, VBG400_RED_FIX_LOAD_VAL_OFFSET}};
+
+
+/**********************************************************************
+*  read_efuse()
+*  Description: read eFuse and write the fix vector in order to fix RAMs
+*  Algorithm:
+*    Read eFuse
+*      1.	Disable PD bit in Efuse_PD register by writing "0"
+*      2.	Check BSY bit is cleared and DONE bit is set by reading STATUS register
+*      3.	Write the Byte Address in the ADDR register
+*      4.	Write "0" to the efuse_control register.
+*      5.	Poll the EFUSE_STATUS register until the BSY bit is cleared
+*      6.	Read the value from the EFUSE_DATA register (for more bytes do 1-6 in a loop)
+*      7.	Enable PD bit in Efuse_PD register by writing "1".
+*    Write the vector
+*    "fix vector" is compressed into 8 bits. It holds bit fix number +1, only one fix bit exist.
+*    It has to '-1' and change it to 32 bits having the appropriated bit set
+*    Every "fix vectore" may have one target address (RAM address to write the vector) and up to 4 addresses.
+*    Every address holds "fix vector" is 32 bits size.
+*      1.	data = "fix vector" - 1
+*      2.	if more than one target address:
+*        2.1	select proper address out of max 4
+*        2.2	data is 32 bits aligned, calculate new data based on it's target address
+*/
+void read_efuse(void)
+{
+    u32 data;
+    int i;
+    int ram_field_index;
+    int vector;
+
+    /*Read eFuse:
+    * loop on all redundancy fix information bytes (what about calibrations?),
+    * start from byte 2
+    */
+    for (i=2; i< VBG400_EFUSE_BYTES_READ_MAX+2; i++)
+    {
+        WriteReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_PD_OFFSET, 0);
+        data=ReadReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_STATUS_OFFSET);
+        /*wait for done bit set and busy bit to clear */
+        while ( ! (data & VBG400_EFUSE_STATUS_WR_RD_FIELD) &&
+                (data & VBG400_EFUSE_STATUS_CTRL_BUSY_FIELD))
+        {
+            //OPEN - use timer to failure?
+            data=ReadReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_STATUS_OFFSET);
+        }
+        /*to read the next byte advance address by 8*/
+        WriteReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_ADDR_OFFSET, i<<3);
+        WriteReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_CONTROL_OFFSET, 0);
+        data=ReadReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_STATUS_OFFSET);
+        while (data & VBG400_EFUSE_STATUS_CTRL_BUSY_FIELD)
+        {
+            //OPEN - use timer to failure?
+            data=ReadReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_STATUS_OFFSET);
+        }
+        efuse_data[i-2]=ReadReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_DATA_OFFSET);
+    }
+    WriteReg(VBG400_SYS_INTERFACE_BASE_ADDR, VBG400_EFUSE_PD_OFFSET, 1);
+    
+    /*Fix RAMs:
+    * write the "fix vectors" to the RAMs allocated address
+    */
+    for (i=0; i< VBG400_EFUSE_MEM_FIX_MAX; i++)
+    {
+        /*only if fix is needed*/
+        if (efuse_data[i] != 0)
+        {
+            ram_field_index = 0;
+            data = efuse_data[i] - 1;
+            if (efuse_loops_per_ram[i] > 1) {
+                /*vector target bigger than 1 address (value can be higher than 32),
+                  find the address to write to and chnage fix accordingly (data is 32 bits aliged up to 128 bits)*/
+                if (efuse_data[i] > 32) {
+                    data = efuse_data[i] - 1 - 32;
+                    ram_field_index = 1;
+                }
+                else if (efuse_data[i] > 64) {
+                    data = efuse_data[i] - 1 - 64;
+                    ram_field_index = 2;
+                }
+                else if (efuse_data[i] > 96) {
+                    data = efuse_data[i] - 1 - 96;
+                    ram_field_index = 3;
+                }
+            }
+            /*At this stage we have fixed value to create vector from
+            */
+            vector = 1<<data;
+            WriteReg(efuse_base[i], efuse_offset[i][EFUSE_OFFSET_SELECT_INDEX], efuse_ram_select[i][ram_field_index]);
+            WriteReg(efuse_base[i], efuse_offset[i][EFUSE_OFFSET_DATA_INDEX], vector);
+        }
+    }
+}
+//#endif VBG400_COMPILE_EFUSE
diff --git a/lib/bootstrap/nand_spl_board.c b/lib/bootstrap/nand_spl_board.c
new file mode 100644
--- /dev/null
+++ b/lib/bootstrap/nand_spl_board.c
@@ -0,0 +1,166 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <version.h>
+#include <environment.h>
+#include <watchdog.h>
+
+extern int lzma_inflate(unsigned char *source, 
+			int s_len, unsigned char *dest, int *d_len);
+
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+/*
+ * The Malloc area is immediately below the monitor copy in DRAM
+ */
+void mem_malloc_init(ulong start, ulong size)
+{
+	mem_malloc_end = start + size;
+	mem_malloc_start = start;
+	mem_malloc_brk = start;
+
+	memset ((void *) mem_malloc_start, 0, mem_malloc_end - mem_malloc_start);
+}
+
+void *malloc(unsigned int size)
+{
+	if(size < (mem_malloc_end - mem_malloc_start))
+	{
+		mem_malloc_start += size;
+		return (void *)(mem_malloc_start - size);
+	}
+
+	return NULL;
+}
+
+void *realloc(void *src,unsigned int size)
+{
+	return NULL;
+}
+
+void free(void *src)
+{
+	return;
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+	ulong old = mem_malloc_brk;
+	ulong new = old + increment;
+
+	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+		return (NULL);
+	}
+
+	mem_malloc_brk = new;
+	return ((void *) old);
+}
+
+void hw_watchdog_reset(void) {}
+
+void uncompress(void)
+{
+	ulong   addr;
+	ulong   data, len, checksum;
+	int destLen;
+	image_header_t header;
+	image_header_t *hdr = &header;
+	int (*fn)(void);
+
+#ifdef CONFIG_VENDOR_MAXLINEAR
+	mem_malloc_init(0x2000000-TOTAL_MALLOC_LEN, TOTAL_MALLOC_LEN);
+#else
+	mem_malloc_init(0x82000000-TOTAL_MALLOC_LEN, TOTAL_MALLOC_LEN);
+#endif
+
+	addr = (ulong)(CONFIG_BOOTSTRAP_TEXT_BASE+10240); /*10k bytes for lzma uncompression code*/
+
+#ifdef CONFIG_VENDOR_MAXLINEAR
+/* TODO: check for memmove on x86 */
+	memcpy (&header, (char *)addr, sizeof(image_header_t));
+#else
+	memmove (&header, (char *)addr, sizeof(image_header_t));
+#endif
+	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
+		return;
+	}
+
+	data = (ulong)&header;
+	len  = sizeof(image_header_t);
+
+	checksum = ntohl(hdr->ih_hcrc);
+   hdr->ih_hcrc = 0;
+
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+	asm("sync");
+#endif
+	if (crc32 (0, (unsigned char *)data, len) != checksum) {
+		return;
+	}
+
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+	asm("sync");
+#endif
+
+	data = addr + sizeof(image_header_t);
+
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+	asm("sync");
+#endif
+
+	len = ntohl(hdr->ih_size);
+
+#if defined(CONFIG_X86)
+	asm("sfence");
+#else
+	asm("sync");
+#endif
+
+	destLen = 0x0; 
+
+	lzma_inflate ((unsigned char *)data, len, 
+				(unsigned char*)ntohl(hdr->ih_load), &destLen);
+
+	fn = (void *) ntohl(hdr->ih_load);
+
+	(*fn)();
+
+	hang ();
+
+	return;
+}
+
+void hang(void)
+{
+	for(;;);
+}
