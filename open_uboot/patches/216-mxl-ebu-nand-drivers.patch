# HG changeset patch
# Parent  4e06a7ac955a253be852fca6fb248e8b5a07a514

diff --git a/drivers/mtd/nand/raw/mxl_ebu_nand.c b/drivers/mtd/nand/raw/mxl_ebu_nand.c
new file mode 100644
--- /dev/null
+++ b/drivers/mtd/nand/raw/mxl_ebu_nand.c
@@ -0,0 +1,1250 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2016 Intel Technology Asia Pte Ltd
+ * Copyright (C) 2022 Maxlinear Corporation 
+ *
+ * EBU (parallel) NAND flash interface driver
+ *
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/arch/project.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/cache.h>
+#include <asm/lib_dma.h>
+#include <linux/delay.h>
+#include <linux/mtd/rawnand.h>
+
+#define TRACE_EBU_NAND	debug
+/* define local driver trace */
+/*#define TRACE_EBU_NAND	DRV_TRACE */
+
+#define RX_CHAN_NO	0x8
+#define TX_CHAN_NO	0x9
+#define DMA_HSNAND_PORT_NUM	0x4
+#define NUM_RX_DESC 2
+#define NUM_TX_DESC 2
+#define DMA_BYTE_OFFSET_MASK 0x3
+
+#define ND_PARA0_PAGE_V8192	0x3
+#define ND_PARA0_PIB_V256	(0x3 << 4)
+#define ND_PARA0_BYP_EN_NP	0x0
+#define ND_PARA0_BYP_DEC_NP	0x0
+#define ND_PARA0_ADEP_EN	BIT(21)
+#define ND_CTL_ECC_OFF_V8TH	BIT(11)
+#define ND_CTL_CKFF_EN		0
+#define ND_CTL_MSG_EN		BIT(17)
+#define NAND_ROW_ADDR_3		0x00004000
+
+/* The ECC Bits Status for MXIC_MX30LF1GE8AB */
+#define NAND_ECC_STATUS_0_1_BIT_ERR     0x00
+#define NAND_ECC_STATUS_2_BIT_ERR       0x10
+#define NAND_ECC_STATUS_3_BIT_ERR       0x08
+#define NAND_ECC_STATUS_4_BIT_ERR       0x18
+
+/* BBT options */
+#define BBT_VERSION_OFFSET	7
+#define BBT_TABLE_OFFSET	3
+#define BBT_OFFS 	3
+#define VER_OFFS	7
+
+/* optimal hardcoded EBU_BUSCON value */
+#if defined (CONFIG_MXL_EBU_NAND_16BIT)
+/**
+ * PW[17:16] = External Device Data Width : 0 = 8-bit, 1 = 16-bit
+ * LEGACY_16B[11] = Legacy 16 bit mode : 0 = Legacy Mode (command and address is 8 bit and data is 16 bit)
+ *                                       1 = Non-Legacy Mode (all command, address and data are 16bit)
+ */
+#define DEFAULT_EBU_CON_CONFIG 0x0041CA95
+#else
+#define DEFAULT_EBU_CON_CONFIG 0x0040C295
+#endif
+
+
+struct mxl_controller_priv {
+	int addr_cnt;
+	int latchcmd;
+	int current_cmd;
+	int pib;
+	int cs;
+
+	struct tx_desc_2dw *tx_desc_ptr;
+	struct rx_desc_2dw *rx_desc_ptr;
+};
+
+#ifdef CONFIG_MXL_HW_BCH
+static int hsnand_tx_num, hsnand_rx_num;
+#if !defined(CONFIG_SPL_BUILD)
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr smallpage_flashbased = {
+	.options = NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+
+static struct nand_bbt_descr largepage_flashbased = {
+	.options = NAND_BBT_SCAN2NDPAGE,
+	.offs = 0,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = BBT_OFFS,
+	.len = 4,
+	.veroffs = VER_OFFS,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = BBT_OFFS,
+	.len = 4,
+	.veroffs = VER_OFFS,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+#endif /* CONFIG_SPL_BUILD */
+#endif /* CONFIG_MXL_HW_BCH */
+
+static void mxl_nand_write_byte(struct mtd_info *mtd, u_char byte);
+static void mxl_nand_write_byte16(struct mtd_info *mtd, uint8_t byte);
+
+extern int ebu_nand_gpio_init(unsigned int cs);
+
+#ifdef CONFIG_SPL_BUILD
+static void mxl_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	return;
+}
+#endif /* CONFIG_SPL_BUILD*/
+
+
+
+#ifdef CONFIG_MXL_EBU_BENAND
+
+/* moved defines from 2016 u-boot/include/linux/mtd/nand.h */
+#define NAND_STATUS_RECOM_REWRT 0x08
+#define NAND_MXIC_ECC_FREE  0x04000000
+
+int nand_read_page_benand(struct mtd_info *mtd, struct nand_chip *chip,
+				uint8_t *buf, int oob_required, int page)
+{
+	unsigned int max_bitflips = 0;
+
+	chip->read_buf(mtd, buf, mtd->writesize);
+	if (oob_required)
+		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* cannot enable this until we have samples */
+#if !defined(CONFIG_SPL_BUILD)
+	uint8_t status;
+
+	/* Check Read Status */
+	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	status = chip->read_byte(mtd);
+
+	if (status & NAND_STATUS_FAIL) {
+		/* uncorrectable error */
+		mtd->ecc_stats.failed++;
+	} else if (status & NAND_STATUS_RECOM_REWRT) {
+		if (chip->options & NAND_MXIC_ECC_FREE) {
+			/* MXIC recommends to
+			 * rewrite when 3~4 bits error been corrected
+			 */
+			if (status & NAND_ECC_STATUS_3_BIT_ERR) {
+				mtd->ecc_stats.corrected += 3;
+				max_bitflips = 3;
+			} else if ((status & NAND_ECC_STATUS_4_BIT_ERR)
+					== NAND_ECC_STATUS_4_BIT_ERR) {
+				mtd->ecc_stats.corrected += 4;
+				max_bitflips = 4;
+			}
+		} else {
+			/* Toshiba BENAND max bitflips*/
+			mtd->ecc_stats.corrected += 8;
+			max_bitflips = 8;
+		}
+	}
+#endif
+	return max_bitflips;
+}
+
+int nand_read_subpage_benand(struct mtd_info *mtd, struct nand_chip *chip,
+			uint32_t data_offs, uint32_t readlen, uint8_t *buf,
+			int page)
+{
+	uint8_t *p;
+	unsigned int max_bitflips = 0;
+
+	if (data_offs != 0)
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_offs, -1);
+
+	p = buf + data_offs;
+	chip->read_buf(mtd, p, readlen);
+
+	/* cannot enable this until we have samples */
+#if !defined(CONFIG_SPL_BUILD)
+	uint8_t status;
+
+	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	status = chip->read_byte(mtd);
+
+	if (status & NAND_STATUS_FAIL) {
+		/* uncorrectable error */
+		mtd->ecc_stats.failed++;
+	} else if (status & NAND_STATUS_RECOM_REWRT) {
+		if (chip->options & NAND_MXIC_ECC_FREE) {
+			/* MXIC recommends to
+			 * rewrite when 3~4 bits error been corrected
+			 */
+			if (status & NAND_ECC_STATUS_3_BIT_ERR) {
+				mtd->ecc_stats.corrected += 3;
+				max_bitflips = 3;
+			} else if ((status & NAND_ECC_STATUS_4_BIT_ERR)
+					== NAND_ECC_STATUS_4_BIT_ERR) {
+				mtd->ecc_stats.corrected += 4;
+				max_bitflips = 4;
+			}
+		} else {
+			/* Toshiba BENAND max bitflips*/
+			mtd->ecc_stats.corrected += 8;
+			max_bitflips = 8;
+		}
+	}
+#endif
+	return max_bitflips;
+}
+
+#endif /* CONFIG_MXL_EBU_BENAND */
+
+
+#ifdef CONFIG_MXL_HW_BCH
+static void hsnand_controller_config(struct mtd_info *mtd, unsigned int cmd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct mxl_controller_priv *info = chip->priv;
+	u32 writesize = mtd->writesize;
+	u32 blocksize = mtd->erasesize;
+	u32 pagesize, pg_per_blk, bch_alg;
+
+	bch_alg = CONFIG_BCH_ECC_STRENGTH << ND_PARA0_BCH_ALG_POS;
+
+	pagesize = fls(writesize >> 11);
+	pg_per_blk = fls((blocksize / writesize) >> 6);
+
+	writel((u32)(cmd & 0xff), NAND_ECC_EXTENSION_NAND_CTL1);
+	writel(0, NAND_ECC_EXTENSION_NDAC_CTL2);
+
+	writel((ND_CTL_MSG_EN | ND_CTL_CKFF_EN | ND_CTL_ECC_OFF_V8TH
+		| (info->cs << ND_CTL_CE_SEL_POS)
+		| CONST_ND_CTL_MODE_ECC), NAND_ECC_EXTENSION_ND_CTL);
+
+ 	writel((bch_alg | ND_PARA0_ADEP_EN
+		| pg_per_blk << 4 | pagesize), NAND_ECC_EXTENSION_ND_PARA0);
+
+	/* clear first, will update later */
+	writel(0xFFFFFFFF, NAND_ECC_EXTENSION_ND_CMSG_0);
+	writel(0xFFFFFFFF, NAND_ECC_EXTENSION_ND_CMSG_1);
+}
+
+static int get_ecc_strength(void)
+{
+	int ecc_config = CONFIG_BCH_ECC_STRENGTH;
+
+	switch (ecc_config) {
+	case 0:
+	case 1:
+		return 1;
+	case 2:
+		return 4;
+	case 3:
+		return 8;
+	case 4:
+		return 24;
+	case 5:
+		return 32;
+	case 6:
+		return 40;
+	case 7:
+		return 60;
+	default:
+		printf("Unknown ecc configurations\n");
+	}
+
+	return -1;
+}
+
+void update_address_cycle(struct nand_chip *chip, int cmd)
+{
+	struct mxl_controller_priv *info = chip->priv;
+
+	/*It is an address byte, record it in the register*/
+	switch (info->addr_cnt) {
+	case 0:
+		writel((readl(NAND_ECC_EXTENSION_NAND_CTL1)
+			| (cmd & 0xff) << 8), NAND_ECC_EXTENSION_NAND_CTL1);
+		info->addr_cnt++;
+		break;
+	case 1:
+		writel((readl(NAND_ECC_EXTENSION_NAND_CTL1)
+			| (cmd & 0xff) << 16), NAND_ECC_EXTENSION_NAND_CTL1);
+		info->addr_cnt++;
+		break;
+	case 2:
+		writel((readl(NAND_ECC_EXTENSION_NAND_CTL1)
+			| (cmd & 0xff) << 24), NAND_ECC_EXTENSION_NAND_CTL1);
+		info->addr_cnt++;
+		break;
+	case 3:
+		writel(readl(NAND_ECC_EXTENSION_NDAC_CTL2)
+			| (cmd & 0xff), NAND_ECC_EXTENSION_NDAC_CTL2);
+		info->addr_cnt++;
+		break;
+	case 4:
+		writel((readl(NAND_ECC_EXTENSION_NDAC_CTL2)
+			| (cmd & 0xff) << 8), NAND_ECC_EXTENSION_NDAC_CTL2);
+		info->addr_cnt++;
+		break;
+	}
+}
+
+static void update_address_via_ebu(struct mtd_info *mtd, int address_cycle)
+{
+	u8 cmd;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+
+	switch (address_cycle) {
+	case 0:
+		cmd = (readl(NAND_ECC_EXTENSION_NAND_CTL1) >> 8) & 0xff;
+		chip->write_byte(mtd, cmd);
+		break;
+
+	case 1:
+		cmd = (readl(NAND_ECC_EXTENSION_NAND_CTL1) >> 16) & 0xff;
+		chip->write_byte(mtd, cmd);
+		break;
+
+	case 2:
+		cmd = (readl(NAND_ECC_EXTENSION_NAND_CTL1) >> 24) & 0xff;
+		chip->write_byte(mtd, cmd);
+		break;
+
+	case 3:
+		cmd = readl(NAND_ECC_EXTENSION_NDAC_CTL2) & 0xff;
+		chip->write_byte(mtd, cmd);
+		break;
+
+	case 4:
+		cmd = (readl(NAND_ECC_EXTENSION_NDAC_CTL2) >> 8) & 0xff;
+		chip->write_byte(mtd, cmd);
+		break;
+	}
+}
+#endif /* CONFIG_MXL_HW_BCH */
+
+/**
+ * mxl_nand_cmd_ctrl - nand command
+ */
+
+static void mxl_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct mxl_controller_priv *info = chip->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if(ctrl & NAND_ALE) {
+			NAND_CLRCLE;
+			NAND_SETALE;
+			info->latchcmd = WRITE_ADDR;
+		}
+		else if(ctrl & NAND_CLE) {
+			NAND_CLRALE;
+			NAND_SETCLE;
+			info->latchcmd = WRITE_CMD;
+		}
+		else {
+			NAND_CLRALE;
+			NAND_CLRCLE;
+			info->latchcmd = WRITE_DATA;
+		}
+	}
+
+#ifdef CONFIG_MXL_HW_BCH
+	/* based on the sequence of address/ctrl updates in nand_base.c */
+	if (cmd != NAND_CMD_NONE) {
+		if ((cmd == NAND_CMD_SEQIN || cmd == NAND_CMD_READ0)
+			&& (ctrl & NAND_CLE)) {
+			info->current_cmd = cmd;
+			info->addr_cnt = 0;
+			hsnand_controller_config(mtd, cmd);
+		} else if ((cmd == NAND_CMD_READSTART) && (ctrl & NAND_CLE)) {
+			/* update address count into register */
+			writel(readl(NAND_ECC_EXTENSION_NDAC_CTL2)
+				| (((info->addr_cnt == 5) ? 2 : 1) << 16),
+				NAND_ECC_EXTENSION_NDAC_CTL2);
+			info->current_cmd = NAND_CMD_NONE;
+		} else if ((cmd == NAND_CMD_PAGEPROG)
+			&& (ctrl & NAND_CLE)
+			&& (info->addr_cnt != 0)) {
+			/* Skip program command
+			 * if the operation is done by dma.
+			 * Address cycles count will be cleared
+			 * after dma access to the page */
+			info->addr_cnt = 0;
+			info->current_cmd = NAND_CMD_NONE;
+		} else {
+			if (info->current_cmd != NAND_CMD_NONE)
+				/* update addr count */
+				update_address_cycle(chip, cmd);
+			else
+				chip->write_byte(mtd, cmd);
+		}
+	}
+#else
+	if (cmd != NAND_CMD_NONE)
+		chip->write_byte(mtd, cmd);
+#endif
+
+	if (cmd == NAND_CMD_NONE) {
+		TRACE_EBU_NAND("\n EBU_NAND: <NAND_CMD_NONE> \n");
+		return;
+	}
+}
+
+/**
+ * mxl_nand_wait_ready -
+ *
+ * nand device ready
+ */
+static int mxl_nand_wait_ready(struct mtd_info *mtd)
+{
+	NAND_WAIT_READY();
+	return 1;
+}
+
+/**
+ * mxl_nand_read_byte - [DEFAULT] read one byte from the chip
+ * @mtd: MTD device structure
+ *
+ * Default read function for 8bit buswidth
+ */
+static u_char mxl_nand_read_byte(struct mtd_info *mtd)
+{
+	u_char data8;
+
+	NAND_READ(READ_DATA, data8);
+
+	return data8;
+}
+
+/**
+ * mxl_nand_read_byte16 - [DEFAULT] read one byte endianness aware from the chip
+ * @mtd: MTD device structure
+ *
+ * Default read function for 16bit buswidth with endianness conversion.
+ *
+ */
+static uint8_t mxl_nand_read_byte16(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	u16 data16;
+
+	data16 = readw((u32)chip->IO_ADDR_W | READ_DATA);
+	while((readl(NAND_CONTROLLER_NAND_WAIT) & 0x08) == 0);
+	return (uint8_t) data16;
+}
+
+/**
+ * mxl_nand_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd: MTD device structure
+ * @buf: buffer to store date
+ * @len: number of bytes to read
+ *
+ * Default read function for 8bit buswidth.
+ */
+static void mxl_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		NAND_READ(READ_DATA, buf[i]);
+	}
+}
+
+/**
+ * mxl_nand_read_buf16 - [DEFAULT] read chip data into buffer
+ * @mtd: MTD device structure
+ * @buf: buffer to store date
+ * @len: number of bytes to read
+ *
+ * Default read function for 16bit buswidth.
+ */
+static void mxl_nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	int i;
+	u16 *p16 = (u16 *) buf;
+
+	for (i = 0; i < (len >> 1); i++) {
+		p16[i]= readw((u32)chip->IO_ADDR_W | READ_DATA);
+		while((readl(NAND_CONTROLLER_NAND_WAIT) & 0x08) == 0);
+	}
+}
+
+/**
+ * mxl_nand_write_byte - [DEFAULT] write single byte to chip
+ * @mtd: MTD device structure
+ * @byte: value to write
+ *
+ * Default function to write a byte to I/O[7:0]
+ */
+static void mxl_nand_write_byte(struct mtd_info *mtd, u_char byte)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct mxl_controller_priv *info = chip->priv;
+
+	*(volatile u8*)((u32)chip->IO_ADDR_W | info->latchcmd) = byte;
+	while((readl(NAND_CONTROLLER_NAND_WAIT) & 0x08) == 0);
+}
+
+/**
+ * mxl_nand_write_byte16 - [DEFAULT] write single byte to a chip with width 16
+ * @mtd: MTD device structure
+ * @byte: value to write
+ *
+ * Default function to write a byte to I/O[7:0] on a 16-bit wide chip.
+ */
+static void mxl_nand_write_byte16(struct mtd_info *mtd, uint8_t byte)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct mxl_controller_priv *info = chip->priv;
+
+	writew((u16)byte, ((u32)chip->IO_ADDR_W | info->latchcmd));
+	while((readl(NAND_CONTROLLER_NAND_WAIT) & 0x08) == 0);
+}
+
+#ifndef CONFIG_SPL_BUILD
+/**
+ * mxl_nand_write_buf - [DEFAULT] write buffer to chip
+ * @mtd: MTD device structure
+ * @buf: data buffer
+ * @len: number of bytes to write
+ *
+ * Default write function for 8bit buswidth.
+ */
+static void mxl_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		WRITE_NAND(buf[i]);
+	}
+}
+
+/**
+ * mxl_nand_write_buf16 - [DEFAULT] write buffer to chip
+ * @mtd: MTD device structure
+ * @buf: data buffer
+ * @len: number of bytes to write
+ *
+ * Default write function for 16bit buswidth.
+ */
+static void mxl_nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct mxl_controller_priv *info = chip->priv;
+	int i;
+	u16 *p = (u16 *) buf;
+
+	for (i = 0; i < (len >> 1); i++) {
+		writew(p[i], ((u32)chip->IO_ADDR_W | info->latchcmd));
+		while((readl(NAND_CONTROLLER_NAND_WAIT) & 0x08) == 0);
+	}
+}
+
+#endif /* !CONFIG_SPL_BUILD */
+
+/**
+ * mxl_nand_select_chip - control -CE line
+ *      Forbid driving -CE manually permitting the NAND controller to do this.
+ *      Keeping -CE asserted during the whole sector reads interferes with the
+ *      NOR flash and PCMCIA drivers as it causes contention on the static bus.
+ *      We only have to hold -CE low for the NAND read commands since the flash
+ *      chip needs it to be asserted during chip not ready time but the NAND
+ *      controller keeps it released.
+ *
+ * @mtd:        MTD device structure
+ * @chip:       chipnumber to select, -1 for deselect
+ */
+static void mxl_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	switch(chip) {
+		case -1:
+			NAND_CE_CLEAR;
+			writel(readl(NAND_CONTROLLER_NAND_CON) & ~(0x1),
+				NAND_CONTROLLER_NAND_CON);
+		  break;
+		case 0:
+			writel(readl(NAND_CONTROLLER_NAND_CON) | (0x1),
+				NAND_CONTROLLER_NAND_CON);
+			NAND_CE_SET;
+		  break;
+		default:
+		  break;
+	}
+}
+
+#ifdef CONFIG_MXL_HW_BCH
+static int mxl_nand_read_oob(struct mtd_info *mtd,
+			struct nand_chip *chip,
+			int page)
+{
+	int i, cmd;
+	struct mxl_controller_priv *info = chip->priv;
+
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+	NAND_SETCLE;
+
+	info->latchcmd = WRITE_CMD;
+	cmd = NAND_CMD_READ0;
+	chip->write_byte(mtd, cmd);
+
+	NAND_CLRCLE;
+	NAND_SETALE;
+
+	info->latchcmd = WRITE_ADDR;
+
+	for(i = 0; i < info->addr_cnt; i++)
+		update_address_via_ebu(mtd, i);
+
+	NAND_CLRALE;
+	NAND_SETCLE;
+
+	if (mtd->writesize > 512) {
+		info->latchcmd = WRITE_CMD;
+		cmd = NAND_CMD_READSTART;
+		chip->write_byte(mtd, cmd);
+	}
+
+	NAND_CLRCLE;
+	while(!NAND_READY);
+
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	info->addr_cnt = 0;
+	return 0;
+}
+
+static int mxl_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+				int page)
+{
+	int i, cmd;
+	int length = mtd->oobsize;
+	const uint8_t *buf = chip->oob_poi;
+	struct mxl_controller_priv *info = chip->priv;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	NAND_SETCLE;
+
+	info->latchcmd = WRITE_CMD;
+	cmd = NAND_CMD_SEQIN;
+	chip->write_byte(mtd, cmd);
+
+	NAND_CLRCLE;
+	NAND_SETALE;
+
+	info->latchcmd = WRITE_ADDR;
+
+	for(i = 0; i < info->addr_cnt; i++)
+		update_address_via_ebu(mtd, i);
+
+	NAND_CLRALE;
+	while(!NAND_READY);
+
+	info->latchcmd = WRITE_DATA;
+	chip->write_buf(mtd, buf, length);
+
+	NAND_SETCLE;
+
+	info->latchcmd = WRITE_CMD;
+	cmd = NAND_CMD_PAGEPROG;
+	chip->write_byte(mtd, cmd);
+
+	NAND_CLRCLE;
+	while(!NAND_READY);
+
+	info->addr_cnt = 0;
+	/* Send a fake command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	return 0;
+
+}
+
+#ifndef CONFIG_LGM_C0_ADEP_ENDIAN_RESOLVED
+static void clear_adep_bit(void)
+{
+	u32 reg;
+	
+	reg = readl(NAND_ECC_EXTENSION_ND_PARA0) & (~ND_PARA0_ADEP_EN);
+	writel(reg, NAND_ECC_EXTENSION_ND_PARA0);
+}
+#endif
+
+static void set_adep_bit(void) 
+{
+	u32 reg;
+
+	reg = readl(NAND_ECC_EXTENSION_ND_PARA0) | ND_PARA0_ADEP_EN;
+	writel(reg, NAND_ECC_EXTENSION_ND_PARA0);		
+}
+
+#ifndef CONFIG_LGM_C0_ADEP_ENDIAN_RESOLVED
+static void hw_bch_set_LE(void)
+{
+	writel((readl(NAND_ECC_EXTENSION_ND_PARA0) & (~(1 <<
+		ND_PARA0_BCH_END_POS))), NAND_ECC_EXTENSION_ND_PARA0);
+}
+#endif
+
+static void hw_bch_set_BE(void)
+{
+	writel((readl(NAND_ECC_EXTENSION_ND_PARA0) | (1 <<
+		ND_PARA0_BCH_END_POS)), NAND_ECC_EXTENSION_ND_PARA0);
+}
+
+static int mxl_nand_read_page_hwecc(struct mtd_info *mtd,
+					struct nand_chip *chip, u8 *buf,
+					int oob_required, int page)
+{
+	int flag = 0;
+	struct rx_desc_2dw * rx_desc;
+	struct mxl_controller_priv *info = chip->priv;
+	u8 *tmp_buf = NULL;
+	u32 reg;
+#ifndef CONFIG_LGM_C0_ADEP_ENDIAN_RESOLVED
+	u32 offset = page * (mtd->writesize);	
+#endif
+
+#ifdef CONFIG_LGM_C0_ADEP_ENDIAN_RESOLVED
+	/* workaround no longer needed after fixes in LGM C0 bootrom */
+	set_adep_bit();
+	hw_bch_set_BE();
+#else		
+	/* need to do this because ROM needs ADEP bit == 0 , make sure use little endian within pad size*/
+	if (offset < (CONFIG_COPIES_OF_RBE * CONFIG_SPL_PAD_SIZE))
+	{
+		clear_adep_bit();
+		hw_bch_set_LE();
+	}
+	else
+	{
+		set_adep_bit();
+		hw_bch_set_BE();
+	}
+#endif	
+
+	rx_desc = (struct rx_desc_2dw *)(info->rx_desc_ptr
+				+ hsnand_rx_num);
+
+	dma_sync_cache_range((void *)rx_desc,
+			sizeof(struct rx_desc_2dw));
+
+	/* update dma rx */
+	while(rx_desc->status.field.own);
+	rx_desc->status.word = 0;
+	rx_desc->status.field.sop = 0;
+	rx_desc->status.field.eop = 0;
+	rx_desc->status.field.c = 0;
+	rx_desc->status.field.data_len = mtd->writesize;
+
+	if((u32)buf & 0x1f) {
+		flag = 1;
+		tmp_buf = (uchar *)memalign(32, mtd->writesize);
+		rx_desc->data_pointer = (u32)tmp_buf;
+	} else {
+		rx_desc->data_pointer = (u32)buf;
+	}
+
+	rx_desc->status.field.own = 1;
+	wmb();
+
+	/* open the DMA rx channel */
+	writel(RX_CHAN_NO, DMA_PERI_DMA_CS);
+	writel((readl(DMA_PERI_DMA_CCTRL) | 0x1),
+			DMA_PERI_DMA_CCTRL);
+
+	NAND_SETALE;
+	writel(readl(NAND_ECC_EXTENSION_INT_MSK_CTL) | (1 << 4),
+		NAND_ECC_EXTENSION_INT_MSK_CTL);
+	writel((readl(NAND_ECC_EXTENSION_NDAC_CTL2)
+		| ((info->addr_cnt == 5) ? 2 : 1) << 16),
+		NAND_ECC_EXTENSION_NDAC_CTL2);
+	writel((readl(NAND_ECC_EXTENSION_ND_CTL) & ~(1<<10)),
+		NAND_ECC_EXTENSION_ND_CTL);
+
+	/*invalidate cache here*/
+	dma_sync_cache_range((void *)rx_desc->data_pointer	,
+					mtd->writesize * 4);
+	udelay(20);
+
+	/* trigger nand read */
+	writel((readl(NAND_ECC_EXTENSION_ND_CTL) | 1 << 2),
+		NAND_ECC_EXTENSION_ND_CTL);
+
+	/* wait for complete */
+	while(rx_desc->status.field.own) {
+		dma_sync_cache_range((void *)rx_desc,
+				sizeof(struct rx_desc_2dw));
+		udelay(100);
+	};
+
+	/* close DMA channel */
+	writel((readl(DMA_PERI_DMA_CCTRL) & ~0x1),
+		DMA_PERI_DMA_CCTRL);
+
+	/* TODO: check error interrupt and handle error correction */
+	reg = readl(NAND_ECC_EXTENSION_INT_STA);
+	if (reg & 0x60) {
+		printf("ECC error (0x%08x) at page: %d\n", reg, page);
+	}
+
+	if (flag) {
+		memcpy(buf, tmp_buf, mtd->writesize);
+		free(tmp_buf);
+	}
+
+	hsnand_rx_num++;
+	if (hsnand_rx_num == NUM_RX_DESC)
+		hsnand_rx_num = 0;
+
+	NAND_CLRALE;
+
+	/* clear interrupts status */
+	writel((readl(NAND_ECC_EXTENSION_INT_STA) | 0x7),
+		NAND_ECC_EXTENSION_INT_STA);
+
+	if (oob_required)
+		chip->ecc.read_oob(mtd, chip, page);
+
+	return 0;
+}
+
+static int mxl_nand_write_page_hwecc(struct mtd_info *mtd,
+					 struct nand_chip *chip, const u8 *buf,
+					 int oob_required, int page)
+{
+	struct mxl_controller_priv *info = chip->priv;
+	u32 reg;
+	struct tx_desc_2dw * tx_desc;
+#ifndef CONFIG_LGM_C0_ADEP_ENDIAN_RESOLVED
+	u32 offset = page * (mtd->writesize);
+#endif
+
+#ifdef CONFIG_LGM_C0_ADEP_ENDIAN_RESOLVED
+	/* workaround no longer needed after fixes in LGM C0 bootrom */
+	set_adep_bit();
+	hw_bch_set_BE();
+#else
+	/* need to do this because ROM needs ADEP bit == 0 , make sure use little endian within pad size*/
+	if (offset < (CONFIG_COPIES_OF_RBE * CONFIG_SPL_PAD_SIZE))
+	{
+		clear_adep_bit();
+		hw_bch_set_LE();
+	}
+	else
+	{
+		set_adep_bit();
+		hw_bch_set_BE();
+	}
+#endif
+
+	tx_desc = (struct tx_desc_2dw *)
+			(info->tx_desc_ptr + hsnand_tx_num);
+
+	/* descriptor not available, wait here */
+	while (tx_desc->status.field.own);
+	tx_desc->status.word = 0;
+	tx_desc->status.field.sop = 1;
+	tx_desc->status.field.eop = 1;
+	tx_desc->status.field.c = 0;
+	tx_desc->status.field.data_len = mtd->writesize;
+	tx_desc->status.field.byte_offset = (u32)buf & DMA_BYTE_OFFSET_MASK;
+	tx_desc->data_pointer = (u32)(buf - tx_desc->status.field.byte_offset);
+	tx_desc->status.field.own = 1;
+	wmb();
+
+	if (oob_required) {
+		reg = (chip->oob_poi[3] << 24)
+			| (chip->oob_poi[2] << 16)
+			| (chip->oob_poi[1] << 8)
+			| chip->oob_poi[0];
+
+		writel(reg, NAND_ECC_EXTENSION_ND_CMSG_0);
+
+		reg = (chip->oob_poi[7] << 24)
+			| (chip->oob_poi[6] << 16)
+			| (chip->oob_poi[5] << 8)
+			| chip->oob_poi[4];
+
+		writel(reg, NAND_ECC_EXTENSION_ND_CMSG_1);
+	}
+
+	hsnand_tx_num++;
+	if (hsnand_tx_num == NUM_TX_DESC)
+		hsnand_tx_num = 0;
+
+	dma_sync_cache_range((void *)tx_desc->data_pointer,
+				mtd->writesize);
+
+	dma_sync_cache_range((void *)(tx_desc),
+				sizeof(struct tx_desc_2dw));
+	udelay(20);
+
+	/* open dma tx channel */
+	writel(TX_CHAN_NO, DMA_PERI_DMA_CS);
+	writel(readl(DMA_PERI_DMA_CCTRL) | 0x1,
+		DMA_PERI_DMA_CCTRL);
+
+	NAND_SETALE;
+	writel(readl(NAND_ECC_EXTENSION_INT_MSK_CTL) | (1 << 4),
+		NAND_ECC_EXTENSION_INT_MSK_CTL);
+	writel(readl(NAND_ECC_EXTENSION_ND_CTL) | (1 << 10),
+		NAND_ECC_EXTENSION_ND_CTL);
+	writel((readl(NAND_ECC_EXTENSION_NDAC_CTL2)
+		| ((info->addr_cnt == 5) ? 2 : 1) << 16),
+		NAND_ECC_EXTENSION_NDAC_CTL2);
+
+	/* trigger write */
+	writel(readl(NAND_ECC_EXTENSION_ND_CTL) | 1 << 2,
+		NAND_ECC_EXTENSION_ND_CTL);
+
+	/* wait for wr_c bit */
+	while (!(readl(NAND_ECC_EXTENSION_INT_STA) & (1 << 4)));
+
+	/* clear wr_c bit */
+	writel(readl(NAND_ECC_EXTENSION_INT_STA) | (1 << 4),
+			NAND_ECC_EXTENSION_INT_STA);
+
+	/* close DMA channel */
+	writel((readl(DMA_PERI_DMA_CCTRL) & ~0x1),
+		DMA_PERI_DMA_CCTRL);
+
+	NAND_CLRALE;
+
+	return 0;
+}
+
+static int mxl_nand_read_page_raw(struct mtd_info *mtd,
+				struct nand_chip *chip,
+				uint8_t *buf, int oob_required, int page)
+{
+	int i, cmd;
+	struct mxl_controller_priv *info = chip->priv;
+
+	NAND_SETCLE;
+
+	info->latchcmd = WRITE_CMD;
+	cmd = NAND_CMD_READ0;
+
+	chip->write_byte(mtd, cmd);
+
+	NAND_CLRCLE;
+	NAND_SETALE;
+
+	info->latchcmd = WRITE_ADDR;
+
+	for (i = 0; i < info->addr_cnt; i++)
+		update_address_via_ebu(mtd, i);
+
+	NAND_CLRALE;
+	NAND_SETCLE;
+
+	if (mtd->writesize > 512) {
+		info->latchcmd = WRITE_CMD;
+		cmd = NAND_CMD_READSTART;
+		chip->write_byte(mtd, cmd);
+	}
+
+	NAND_CLRCLE;
+	while(!NAND_READY);
+
+	chip->read_buf(mtd, buf, mtd->writesize);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	info->addr_cnt = 0;
+	return 0;
+}
+
+static int mxl_nand_write_page_raw(struct mtd_info *mtd,
+				struct nand_chip *chip,
+				const uint8_t *buf,
+				int oob_required, int page)
+{
+	/* OOB required and page num not used */
+	return chip->ecc.write_page(mtd, chip, buf, 0, 0);
+}
+
+#if !defined(CONFIG_SPL_BUILD)
+static int default_hw_bbt_layout(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+
+	if (!chip->bbt_td) {
+		chip->bbt_td = &bbt_main_descr;
+		chip->bbt_md = &bbt_mirror_descr;
+	}
+
+	if (!chip->badblock_pattern) {
+		chip->badblock_pattern = (mtd->writesize > 512)
+		? &largepage_flashbased : &smallpage_flashbased;
+	}
+
+	chip->bbt_td->offs = BBT_TABLE_OFFSET;
+	chip->bbt_td->veroffs = BBT_VERSION_OFFSET;
+	chip->bbt_md->offs = BBT_TABLE_OFFSET;
+	chip->bbt_md->veroffs = BBT_VERSION_OFFSET;
+
+	return nand_default_bbt(mtd);
+}
+#endif /* CONFIG_SPL_BUILD */
+
+static void hsnand_dma_setup(struct nand_chip *chip)
+{
+	int i;
+	u32 reg;
+	struct mxl_controller_priv *info = chip->priv;
+
+	mxl_dma_w32_mask(0, (1 << DMA_CTRL_RST_POS),
+			DMA_PERI_DMA_CTRL);
+
+	/* Port configuration */
+	writel(DMA_HSNAND_PORT_NUM, DMA_PERI_DMA_PS);
+	/* RXENDI_B3_B2_B1_B0 , 8DWBL*/
+	writel(0x03c, DMA_PERI_DMA_PCTRL);
+
+	/* configure RX CHAN */
+	writel(RX_CHAN_NO, DMA_PERI_DMA_CS);
+	reg = (CONST_DMA_CTRL_ENBE_ENABLED << DMA_CTRL_ENBE_POS);
+	writel(reg, DMA_PERI_DMA_CTRL);
+
+	/* off rx chan */
+	writel(0x10000, DMA_PERI_DMA_CCTRL);
+	writel((u32)info->rx_desc_ptr, DMA_PERI_DMA_CDBA);
+	writel(NUM_RX_DESC, DMA_PERI_DMA_CDLEN);
+	writel(0x0, DMA_PERI_DMA_CIE);
+	writel(0x80000080, DMA_PERI_DMA_CPOLL);
+
+	/* configure TX chan */
+	writel(TX_CHAN_NO, DMA_PERI_DMA_CS);
+	reg = (CONST_DMA_CTRL_ENBE_ENABLED << DMA_CTRL_ENBE_POS);
+	writel(reg, DMA_PERI_DMA_CTRL);
+	writel(0x30100, DMA_PERI_DMA_CCTRL);
+	writel((u32)info->tx_desc_ptr, DMA_PERI_DMA_CDBA);
+	writel(NUM_TX_DESC, DMA_PERI_DMA_CDLEN);
+	writel(0x0, DMA_PERI_DMA_CIE);
+	writel(0x80000080, DMA_PERI_DMA_CPOLL);
+
+	hsnand_tx_num = 0;
+	hsnand_rx_num = 0;
+
+	for (i=0;i < NUM_RX_DESC; i++) {
+		struct rx_desc_2dw * rx_desc = (struct rx_desc_2dw *)
+					(info->rx_desc_ptr + i);
+
+		rx_desc->status.word=0;
+		rx_desc->status.field.own = 0;
+		rx_desc->status.field.data_len = 0;   /* 1536  */
+		rx_desc->data_pointer = 0;
+
+		dma_sync_cache_range((void *)(rx_desc),
+				sizeof(struct rx_desc_2dw));
+	}
+	udelay(200);
+}
+#endif /* CONFIG_MXL_HW_BCH */
+
+/**
+ * mxl_ebu_nand_chip_init -
+ */
+static void mxl_ebu_nand_chip_init(struct nand_chip *chip)
+{
+	u32 reg;
+	struct mxl_controller_priv *info = chip->priv;
+
+	reg = readl(RCU_RST_REQ_PERI);
+	reg &= 0xFFFFFFFC;
+	writel(reg, RCU_RST_REQ_PERI);
+	/* EBU_N_EBU_CLC - enable EBU */
+	writel(EBU_CLC_RST, NAND_CONTROLLER_EBU_CLC);
+	/* EBU_N_EBU_CON - default setting */
+	writel(EBU_CON_RST, NAND_CONTROLLER_EBU_CON);
+	/* EBU_N_EBU_ADDR_SEL_0: CS0 -> NOR 0xFFF00000 */
+	writel(0x17400051, NAND_CONTROLLER_EBU_ADDR_SEL_0);
+	/* EBU_N_EBU_ADDR_SEL_1: CS1 -> NAND 0xE1400000 */
+	writel(0x17C00051, NAND_CONTROLLER_EBU_ADDR_SEL_1);
+
+#ifdef CONFIG_NAND_CS0
+	writel(DEFAULT_EBU_CON_CONFIG, NAND_CONTROLLER_EBU_CON_0);
+	/* EBU_N_NAND_CON - CS0 selected, all active low except CLE & ALE */
+	writel(0x000000F3, NAND_CONTROLLER_NAND_CON);
+	/* configure gpio */
+	ebu_nand_gpio_init(EBU_CHIP_SELECT_0);
+#else
+	writel(DEFAULT_EBU_CON_CONFIG, NAND_CONTROLLER_EBU_CON_1);
+	/* EBU_N_NAND_CON - CS1 selected, all active low except CLE & ALE */
+	writel(0x000005F3, NAND_CONTROLLER_NAND_CON);
+	/* configure gpio */
+	ebu_nand_gpio_init(EBU_CHIP_SELECT_1);
+#endif
+
+#if 0 /* reg debug print */
+printf("\n\nEBU CLC Register Value           : 0x%08x\n", REG32(NAND_CONTROLLER_EBU_CLC));
+printf("EBU CON Register Value           : 0x%08x\n", REG32(NAND_CONTROLLER_EBU_CON));
+printf("EBU ADR SEL 0 Register Value     : 0x%08x\n", REG32(NAND_CONTROLLER_EBU_ADDR_SEL_0));
+printf("EBU ADR SEL 1 Register Value     : 0x%08x\n", REG32(NAND_CONTROLLER_EBU_ADDR_SEL_1));
+printf("EBU CON 0 Register Value         : 0x%08x\n", REG32(NAND_CONTROLLER_EBU_CON_0));
+printf("EBU CON 1 Register Value         : 0x%08x\n", REG32(NAND_CONTROLLER_EBU_CON_1));
+printf("NAND_CON Register Value          : 0x%08x\n\n", REG32(NAND_CONTROLLER_NAND_CON));
+#endif
+
+#ifdef CONFIG_NAND_CS0
+	info->cs = CONST_ND_CTL_CE_SEL_CS0;
+#else
+	info->cs = CONST_ND_CTL_CE_SEL_CS1;
+#endif
+
+#ifdef CONFIG_MXL_HW_BCH
+	hsnand_dma_setup(chip);
+#endif
+}
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardware specific function for accessing control-lines
+ * - dev_ready: hardware specific function for  accessing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transferring data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+int board_nand_init(struct nand_chip *nand)
+{
+#if defined(CONFIG_MXL_HW_BCH)
+	struct mxl_controller_priv *info;
+
+	/*clear ecc error status*/
+	writel(0x70, NAND_ECC_EXTENSION_INT_STA);
+
+	info = malloc(sizeof(struct mxl_controller_priv));
+	if (!info) {
+		printf("No memory allocated for nand priv data\n");
+		return -ENOMEM;
+	}
+
+	memset(info, 0, sizeof(struct mxl_controller_priv));
+	info->current_cmd = NAND_CMD_NONE;
+
+	nand->priv = info;
+
+	info->rx_desc_ptr = (struct rx_desc_2dw *)
+				memalign(64, sizeof(struct rx_desc_2dw)
+						* NUM_RX_DESC);
+	info->tx_desc_ptr = (struct tx_desc_2dw *)
+				memalign(64, sizeof(struct tx_desc_2dw)
+					* NUM_TX_DESC);
+	if (!info->rx_desc_ptr || !info->tx_desc_ptr) {
+		printf("Unable to allocate memory for nand drv\n");
+		return -ENOMEM;
+	}
+
+	memset(info->tx_desc_ptr, 0,
+		sizeof(struct rx_desc_2dw) * NUM_TX_DESC);
+#endif /* CONFIG_MXL_HW_BCH */
+
+	/* insert callbacks */
+	nand->IO_ADDR_R = (void *)NAND_BASE_ADDRESS;
+	nand->IO_ADDR_W = (void *)NAND_BASE_ADDRESS;
+
+#ifndef CONFIG_SPL_BUILD
+	nand->write_buf	= mxl_nand_write_buf;
+#endif
+
+	mxl_ebu_nand_chip_init(nand);
+
+	nand->write_byte = mxl_nand_write_byte;
+	nand->read_byte	= mxl_nand_read_byte;
+	nand->read_buf = mxl_nand_read_buf;
+	nand->cmd_ctrl = mxl_nand_cmd_ctrl;
+	nand->dev_ready	= mxl_nand_wait_ready;
+	nand->select_chip = mxl_nand_select_chip;
+
+#if defined(CONFIG_MXL_HW_BCH)
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->options |= NAND_NO_SUBPAGE_WRITE;
+	nand->ecc.read_page = mxl_nand_read_page_hwecc;
+	nand->ecc.write_page = mxl_nand_write_page_hwecc;
+	nand->ecc.write_page_raw = mxl_nand_write_page_raw;
+	nand->ecc.read_page_raw = mxl_nand_read_page_raw;
+	nand->ecc.read_oob = mxl_nand_read_oob;
+	nand->ecc.write_oob = mxl_nand_write_oob;
+
+	nand->ecc.strength = get_ecc_strength();
+	if (nand->ecc.strength <= 8)
+		nand->ecc.size = 512;
+	else
+		nand->ecc.size = 1024;
+
+#ifndef CONFIG_SPL_BUILD
+	/* special oob layout due to hardware ecc */
+	nand->scan_bbt = default_hw_bbt_layout;
+#endif /* CONFIG_SPL_BUILD */
+
+#elif defined(CONFIG_MXL_EBU_BENAND)
+	nand->ecc.mode = NAND_ECC_NONE; //BENAND has built-in hardware ECC
+	nand->ecc.read_page = nand_read_page_benand;
+	nand->ecc.read_subpage = nand_read_subpage_benand;
+#endif /* CONFIG_MXL_HW_BCH */
+
+	nand->bbt_options |= NAND_BBT_USE_FLASH;
+
+#ifdef CONFIG_SPL_BUILD
+	nand->ecc.hwctl = mxl_enable_hwecc;
+#endif /* CONFIG_SPL_BUILD */
+
+#if defined(CONFIG_MXL_EBU_NAND_16BIT)
+	/* NAND bus width determines access functions used by upper layer */
+	nand->options |= NAND_BUSWIDTH_16;
+#endif
+
+	if (nand->options & NAND_BUSWIDTH_16) {
+#ifndef CONFIG_SPL_BUILD
+		nand->write_buf = mxl_nand_write_buf16;
+#endif
+		nand->write_byte = mxl_nand_write_byte16;
+		nand->read_byte = mxl_nand_read_byte16;
+		nand->read_buf = mxl_nand_read_buf16;
+	}
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/raw/nand_base.c b/drivers/mtd/nand/raw/nand_base.c
--- a/drivers/mtd/nand/raw/nand_base.c
+++ b/drivers/mtd/nand/raw/nand_base.c
@@ -38,6 +38,7 @@
 #include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/compat.h>
+#include <linux/math64.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/rawnand.h>
 #include <linux/mtd/nand_ecc.h>
@@ -92,6 +93,35 @@ static struct nand_ecclayout nand_oob_12
 		{.offset = 2,
 		 .length = 78} }
 };
+
+static struct nand_ecclayout nand_oob_448 = {
+	.eccbytes = 168,
+	.eccpos = {
+			280, 281, 282, 283, 284, 285, 286, 287,
+			288, 289, 290, 291, 292, 293, 294, 295,
+			296, 297, 298, 299, 300, 301, 302, 303,
+			304, 305, 306, 307, 308, 309, 310, 311,
+			312, 313, 314, 315, 316, 317, 318, 319,
+			320, 321, 322, 323, 324, 325, 326, 327,
+			328, 329, 330, 331, 332, 333, 334, 335,
+			336, 337, 338, 339, 340, 341, 342, 343,
+			344, 345, 346, 347, 348, 349, 350, 351,
+			352, 353, 354, 355, 356, 357, 358, 359,
+			360, 361, 362, 363, 364, 365, 366, 367,
+			368, 369, 370, 371, 372, 373, 374, 375,
+			376, 377, 378, 379, 380, 381, 382, 383,
+			384, 385, 386, 387, 388, 389, 390, 391,
+			392, 393, 394, 395, 396, 397, 398, 399,
+			400, 401, 402, 403, 404, 405, 406, 407,
+			408, 409, 410, 411, 412, 413, 414, 415,
+			416, 417, 418, 419, 420, 421, 422, 423,
+			424, 425, 426, 427, 428, 429, 430, 431,
+			432, 433, 434, 435, 436, 437, 438, 439,
+			440, 441, 442, 443, 444, 445, 446, 447},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 278} }
+};
 #endif
 
 static int nand_get_device(struct mtd_info *mtd, int new_state);
@@ -2484,6 +2514,100 @@ read_retry:
 	return max_bitflips;
 }
 
+#ifndef CONFIG_SPL_BUILD
+int nand_write_partial (struct mtd_info *mtd, loff_t offset,
+			uint64_t len, uint64_t *retlen, const u_char * buf)
+{
+	unsigned long sect_addr;
+	size_t sector_size;
+	unsigned char *sect_buf = NULL;
+	int f_start_partial=0;
+	int f_end_partial=0;
+	int f_malloc=0;
+	int total_sect_num=0;
+	struct erase_info erase;
+	int i;
+	u32 remain_start, remain_end;
+	sector_size = mtd->erasesize;
+
+	div_u64_rem(offset, sector_size, &remain_start);
+	if (remain_start)
+		f_start_partial = 1;
+
+	div_u64_rem(offset + len, sector_size, &remain_end);
+	if (remain_end)
+		f_end_partial = 1;
+
+	total_sect_num = lldiv(offset + len - 1, sector_size) - lldiv(offset, sector_size) + 1;
+	sect_addr = lldiv(offset, sector_size);
+	sect_buf = (unsigned char *) buf;
+
+	for (i = 0; i < total_sect_num; i++) {
+		/* Skip bad blocks */
+		while (1) {
+			memset(&erase, 0, sizeof(erase));
+			erase.mtd  = mtd;
+			erase.addr = (sect_addr + i) * sector_size;
+			erase.len  = sector_size;
+			erase.state = 0;
+
+			if (nand_block_checkbad(mtd, erase.addr, 1)) {
+				printf("Skipping badblock at 0x%llx\n", erase.addr);
+				sect_addr++;
+				continue;
+			}
+			break;
+		}
+
+		if ((f_start_partial && i == 0) ||
+			(f_end_partial && total_sect_num == 1)) {
+			sect_buf=(uchar *)memalign(32, sector_size);
+
+			mtd_read(mtd, (sect_addr + i) * sector_size,
+					  sector_size, (size_t *) retlen, sect_buf);
+			if (min((uint64_t)(sector_size
+				- (uint64_t)remain_start), len) > (sector_size - remain_start)) {
+				printf("Partial write %d to a larger size\n", i);
+				return -EINVAL;
+			}
+			memcpy(sect_buf + remain_start, buf,
+			       min((uint64_t)(sector_size - (uint64_t)remain_start), len));
+			f_malloc = 1;
+		}
+		else if (f_end_partial && i == total_sect_num -1 && i!= 0) {
+			sect_buf=(uchar *)memalign(32, sector_size);
+			mtd_read(mtd, (sect_addr + i) * sector_size, sector_size,
+					  (size_t *) retlen, sect_buf);
+			/* check src/dest buf overflow */
+			if (remain_end > sector_size
+				 || (i * sector_size - remain_start + remain_end) > len) { 
+				printf("Partial write %d to buffer overrun\n", i);
+				return -EINVAL;
+			}
+			memcpy(sect_buf, buf + i * sector_size - remain_start,
+			       remain_end);
+			f_malloc=1;
+		}
+
+		nand_erase_nand(mtd, &erase,0);
+		mtd_write(mtd, (sect_addr + i) * sector_size, sector_size,
+					  (size_t *) retlen, sect_buf);
+
+		if (f_malloc) {
+			free(sect_buf);
+			f_malloc = 0;
+		}
+
+		sect_buf = (unsigned char *)buf + (i + 1) * sector_size -
+			   remain_start;
+	} /* for */
+
+	*retlen = (uint64_t)len;
+	return 0;
+}
+
+#endif /* CONFIG_SPL_BUILD */
+
 /**
  * nand_read_oob_std - [REPLACEABLE] the most common OOB data read function
  * @mtd: mtd info structure
@@ -4501,9 +4625,9 @@ ident_done:
 		 * Check, if buswidth is correct. Hardware drivers should set
 		 * chip correct!
 		 */
-		pr_info("device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\n",
+		printf("device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\n",
 			*maf_id, *dev_id);
-		pr_info("%s %s\n", nand_manuf_ids[maf_idx].name, mtd->name);
+		printf("%s %s\n", nand_manuf_ids[maf_idx].name, mtd->name);
 		pr_warn("bus width %d instead %d bit\n",
 			   (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
 			   busw ? 16 : 8);
@@ -4536,32 +4660,32 @@ ident_done:
 	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
 		chip->cmdfunc = nand_command_lp;
 
-	pr_info("device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\n",
+	printf("device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\n",
 		*maf_id, *dev_id);
 
 #ifdef CONFIG_SYS_NAND_ONFI_DETECTION
 	if (chip->onfi_version)
-		pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
+		printf("%s %s\n", nand_manuf_ids[maf_idx].name,
 				chip->onfi_params.model);
 	else if (chip->jedec_version)
-		pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
+		printf("%s %s\n", nand_manuf_ids[maf_idx].name,
 				chip->jedec_params.model);
 	else
-		pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
+		printf("%s %s\n", nand_manuf_ids[maf_idx].name,
 				type->name);
 #else
 	if (chip->jedec_version)
-		pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
+		printf("%s %s\n", nand_manuf_ids[maf_idx].name,
 				chip->jedec_params.model);
 	else
-		pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
+		printf("%s %s\n", nand_manuf_ids[maf_idx].name,
 				type->name);
 
-	pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
+	printf("%s %s\n", nand_manuf_ids[maf_idx].name,
 		type->name);
 #endif
 
-	pr_info("%d MiB, %s, erase size: %d KiB, page size: %d, OOB size: %d\n",
+	printf("%d MiB, %s, erase size: %d KiB, page size: %d, OOB size: %d\n",
 		(int)(chip->chipsize >> 20), nand_is_slc(chip) ? "SLC" : "MLC",
 		mtd->erasesize >> 10, mtd->writesize, mtd->oobsize);
 	return type;
@@ -5044,8 +5168,13 @@ int nand_scan_tail(struct mtd_info *mtd)
 			ecc->layout = &nand_oob_64;
 			break;
 		case 128:
+		case 256:
 			ecc->layout = &nand_oob_128;
 			break;
+		case 448:
+		case 744:
+			ecc->layout = &nand_oob_448;
+			break;
 #endif
 		default:
 			pr_warn("No oob scheme defined for oobsize %d\n",
