# HG changeset patch
# Parent  8165c1e4576315ed41a90e038c47375a967eb9a9

diff --git a/drivers/net/lightning_mountain_combophy.c b/drivers/net/lightning_mountain_combophy.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/lightning_mountain_combophy.c
@@ -0,0 +1,728 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright © 2022 MaxLinear, Inc.
+ *
+ * Lightning Mountain Slim Ethernet Driver
+ *
+ */
+#include <common.h>
+#include <config.h>
+#include <dm.h>
+#include <malloc.h>
+#include <net.h>
+#include <time.h>
+#include <asm/io.h>
+#include <asm/arch/project.h>
+#include <asm/lib_dma.h>
+#include <asm/cache.h>
+#include <linux/delay.h>
+
+#include "lightning_mountain_sw.h"
+#include "lightning_mountain_combophy.h"
+
+#define LJPLL3_LOCK_POLL_CNT	5000
+#define PHY_RXADAPT_POLL_CNT	5000
+
+extern int pon_eth_sel;
+extern u32 combo_phy_cr_base(struct combo_port *paddr, int port);
+extern void init_xpcs(int p0_id, int p1_id, int p0_spd, int p1_spd);
+extern int verify_reset_status(int p0_id, int p1_id);
+
+u32 combo_phy_app_base(struct combo_port *paddr, int port)
+{
+	return paddr[port].port_to_addr.phy_app_base;
+}
+
+void init_combo_base(struct combo_port *combo_port,
+			int port)
+{
+	struct combo_addr_map *paddr = &combo_port->port_to_addr;
+	switch (port) {
+	case COMBO_PORT10:
+	default:
+		LGM_NET_DBG("COMBO HSIOL Port10 global config\n");
+		paddr->phy_app_base = COMBO_HSIOL_PHY10_APP_BASE;
+		paddr->phy_cr_base = COMBO_HSIOL_PHY10_CR_BASE;
+		break;
+	case COMBO_PORT11:
+		LGM_NET_DBG("COMBO HSIOL Port11 global config\n");
+		paddr->phy_app_base = COMBO_HSIOL_PHY11_APP_BASE;
+		/*paddr->phy_cr_base = COMBO_HSIOL_PHY11_CR_BASE; //Not accessible. Use PHY10 for LANE1 access. */
+		break;
+	case COMBO_PORT20:
+		LGM_NET_DBG("COMBO HSIOR Port20 global config\n");
+		paddr->phy_app_base = COMBO_HSIOR_PHY20_APP_BASE;
+		paddr->phy_cr_base = COMBO_HSIOR_PHY20_CR_BASE;
+		break;
+	case COMBO_PORT21:
+		LGM_NET_DBG("COMBO HSIOR Port21 global config\n");
+		paddr->phy_app_base = COMBO_HSIOR_PHY21_APP_BASE;
+		paddr->phy_cr_base = COMBO_HSIOR_PHY20_CR_BASE;
+		/*paddr->phy_cr_base = COMBO_HSIOR_PHY21_CR_BASE; //Not accessible. Use PHY20 for LANE1 access. */
+		break;
+	case PON_WAN_PORT4:
+		LGM_NET_DBG("PON WAN Port4 global config\n");
+		paddr->phy_app_base = PON_WAN_PHY_APP_BASE;
+		paddr->phy_cr_base = PON_WAN_PHY_CR_BASE;
+		break;
+	case P34X_PORT5:
+		LGM_NET_DBG("P34X Port5 global config\n");
+		paddr->phy_app_base = PHY5_APP_BASE;
+		/*paddr->phy_cr_base = PHY5_CR_BASE; */
+		break;
+	}
+}
+
+void ljpll3_cfg_frac_eth(void)
+{
+	int i;
+
+	LGM_NET_DBG("Start LJPLL3 Fraction 156.25+15.5ppm refclk for CDR bring-up config: LJPLL3_CFG0\n");
+
+	LGM_NET_DBG("Clear PLL3_CFG0 and disable LJPLL3\n");
+	/*LJPLL3_CFG0 */
+	/*#define PLL3_CFG0	(0xE020 00E0) */
+	u32 LJPLL_CFG0_LOCAL = (CGU_LJPLL3_CFG0);
+	/*To Disble the LJPLL3 */
+	REG32(LJPLL_CFG0_LOCAL) &= ~(0xFFFFFFFF << 0); /*Clear all BITs to '0' */
+	LGM_NET_DBG("PLL3_CFG0 0x%08x\n", REG32(LJPLL_CFG0_LOCAL));	/*Should get back 0x0 */
+
+	LGM_NET_DBG("Start PLL3_CFG2 config\n");
+	/*LJPLL3_CFG2 */
+	/*#define LJPLL3_CFG2	(0xE020 00E8) */
+	u32 LJPLL_CFG2_LOCAL = (CGU_LJPLL3_CFG2);
+	REG32(LJPLL_CFG2_LOCAL) &= ~(0xFFF << 0);
+	/*REG32(LJPLL_CFG2_LOCAL) |= 124 << 0 ; //FBDIV Bit 11:0 LJPLL Feedback Divider (124 = 0x7C). 5G FVCO */
+	REG32(LJPLL_CFG2_LOCAL) |= 250 << 0 ; /*FBDIV Bit 11:0 LJPLL Feedback Divider (250 = 0xFA). 10G FVCO */
+	REG32(LJPLL_CFG2_LOCAL) &= ~(0x3F << 18);
+	REG32(LJPLL_CFG2_LOCAL) |= 1 << 18; /*REFDIV Bit 23:18 PLL Reference Clock Input Divider (1 = 0x1) */
+	REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 24); /*BYPASS0 Bit 24 FOUT0 Bypass */
+	REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 25); /*BYPASS0 Bit 25 FOUT1 Bypass */
+	REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 26); /*BYPASS0 Bit 26 FOUT2 Bypass */
+	REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 27); /*BYPASS0 Bit 27 FOUT3 Bypass */
+	REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 28);
+	REG32(LJPLL_CFG2_LOCAL) |= 0x1 << 28; /*FREFCMLEN Bit 28 0h = CMOS Mode; 1h = CML Mode. Enable Reference Clock CML Mode */
+	LGM_NET_DBG("PLL3_CFG2 REG32(0x%08x) = 0x%08x\n", LJPLL_CFG2_LOCAL, REG32(LJPLL_CFG2_LOCAL));
+
+	LGM_NET_DBG("Start PLL3_CFG0 config\n");
+	/*To configure */
+	REG32(LJPLL_CFG0_LOCAL) &= ~(0xFFFFFF << 2); /*FRAC Bit 25:2 FLL Fractional Divider */
+	/*REG32(LJPLL_CFG0_LOCAL) |= (0xD4FDF4 << 2); //Bit 25:2 = FRAC Bit 23:0 LJPLL Fractional Divider (0.832/2^-24 = 13958644 = 0xD4FDF4). 10G VCO */
+	/*REG32(LJPLL_CFG0_LOCAL) |= (65012 << 2); //Bit 25:2 = FRAC Bit 23:0 LJPLL Fractional Divider (0.003875/2^-24 = 65012 = 0xFDF4). 10G VCO; exact 156.25MHz */
+	/*REG32(LJPLL_CFG0_LOCAL) |= (62915 << 2); //Bit 25:2 = FRAC Bit 23:0 LJPLL Fractional Divider (0.0075/2^-24 = 62915 = 0xF5C3). 5G VCO; +15ppm */
+	REG32(LJPLL_CFG0_LOCAL) |= (125830 << 2); /*Bit 25:2 = FRAC Bit 23:0 LJPLL Fractional Divider (0.0075/2^-24 = 125830 = 0x1EB86). 10G VCO; +15ppm */
+	REG32(LJPLL_CFG0_LOCAL) &= ~(0x1 << 28);
+	REG32(LJPLL_CFG0_LOCAL) |= 0x1 << 28; /*DSMEN Bit 28 (0h Integer Mode, 1h Fractional ;Delta-Sigma Modulator) */
+	REG32(LJPLL_CFG0_LOCAL) &= ~(0x1 << 30);
+	REG32(LJPLL_CFG0_LOCAL) |= 0x1 << 30; /*DACEN Bit 30 (0h DAC is disable, 1h DAC is enable) */
+	REG32(LJPLL_CFG0_LOCAL) &= ~(0x1 << 31);
+	REG32(LJPLL_CFG0_LOCAL) |= 0x1 << 31; /*LD Bit 31 (0h No operation, 1h Load action) */
+	LGM_NET_DBG("PLL3_CFG0 0x%08x\n", REG32(LJPLL_CFG0_LOCAL));	/*Should get back 0x4000 0003 */
+
+	LGM_NET_DBG("Start LJPLL3 config: LJPLL3_CFG1\n");
+	/*LJPLL3_CFG1 */
+	/*#define PLL3_CFG1		(0xE020 00E8) */
+	u32 LJPLL_CFG1_LOCAL = (CGU_LJPLL3_CFG1);
+	/*#### DIV0 25MHz */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 0);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 0; //POST_DIV0A Bit 2:0 First post divide value for FOUTCML0P/N (nominal 50% duty cycle) 40MHz */
+	REG32(LJPLL_CFG1_LOCAL) |= 0x7 << 0; /*POST_DIV0A Bit 2:0 First post divide value for FOUTCML0P/N (nominal 50% duty cycle) 25MHz */
+	/*REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 3); */
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 3; //POST_DIV0B Bit 5:3 2nd post divide value for FOUTCML0P/N (nominal 50% duty cycle). VCO 5G 40MHz */
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 3; //POST_DIV0B Bit 5:3 2nd post divide value for FOUTCML0P/N (nominal 50% duty cycle). VCO 10G 40MHz */
+	REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 3; /*POST_DIV0B Bit 5:3 2nd post divide value for FOUTCML0P/N (nominal 50% duty cycle). VCO 10G 25MHz */
+
+	/*#### DIV1 156.25MHz */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 6);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x7 << 6; //POST_DIV1A Bit 8:6 First post divide value for FOUTCML1P/N (nominal 50% duty cycle) FMX */
+	REG32(LJPLL_CFG1_LOCAL) |= 0x3 << 6; /*POST_DIV1A Bit 8:6 First post divide value for FOUTCML1P/N (nominal 50% duty cycle) LGM */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 9);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x0 << 9; //POST_DIV1B Bit 11:9 2nd post divide value for FOUTCML1P/N (nominal 50% duty cycle). VCO 5G */
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 9; //POST_DIV1B Bit 11:9 2nd post divide value for FOUTCML1P/N (nominal 50% duty cycle). VCO 10G FMX */
+	REG32(LJPLL_CFG1_LOCAL) |= 0x3 << 9; /*POST_DIV1B Bit 11:9 2nd post divide value for FOUTCML1P/N (nominal 50% duty cycle). VCO 10G LGM */
+
+	/*#### DIV2 1250MHz */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 12);
+	REG32(LJPLL_CFG1_LOCAL) |= 0x0 << 12; /*POST_DIV2A Bit 14:12 First post divide value for FOUTCML2P/N (nominal 50% duty cycle) */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 15);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 15; //POST_DIV2B Bit 17:15 2nd post divide value for FOUTCML2P/N (nominal 50% duty cycle). VCO 5G */
+	REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 15; /*POST_DIV2B Bit 17:15 2nd post divide value for FOUTCML2P/N (nominal 50% duty cycle). VCO 10G */
+
+	/*#### DIV3 500MHz */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 18);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 18; //POST_DIV3A Bit 20:18 First post divide value for FOUTCML3P/N (nominal 50% duty cycle) FMX */
+	REG32(LJPLL_CFG1_LOCAL) |= 0x0 << 18; /*POST_DIV3A Bit 20:18 First post divide value for FOUTCML3P/N (nominal 50% duty cycle) LGM */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 21);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 21; //POST_DIV3B Bit 23:21 2nd post divide value for FOUTCML3P/N (nominal 50% duty cycle). VCO 5G */
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x0 << 21; //POST_DIV3B Bit 23:21 2nd post divide value for FOUTCML3P/N (nominal 50% duty cycle). VCO 10G FMX */
+	REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 21; /*POST_DIV3B Bit 23:21 2nd post divide value for FOUTCML3P/N (nominal 50% duty cycle). VCO 10G LGM */
+
+	/*#### FOUT[3:0]EN */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 24);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 24; //FOUT0EN Bit 24 PLL Clock Output 0 Enable */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 25);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 25; //FOUT1EN Bit 25 PLL Clock Output 1 Enable */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 26);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 26; //FOUT2EN Bit 26 PLL Clock Output 2 Enable */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 27);
+	/*REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 27; //FOUT3EN Bit 27 PLL Clock Output 3 Enable */
+
+	/*#### POST_DIV0PRE for FOUT0 ONLY divide 2.5 when turn on. */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 29);
+	REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 29; /*POST_DIV0PRE Bit 29 Enable for Pre-Divide for FOUTCML0N/P */
+	LGM_NET_DBG("PLL3_CFG1 0x%08x\n", REG32(LJPLL_CFG1_LOCAL));
+
+	/*To Enable the LJPLL3 */
+	REG32(LJPLL_CFG0_LOCAL) &= ~(0x1 << 0); /*PLLEN Bit 0 (0h Disable, 1h Enable) */
+	REG32(LJPLL_CFG0_LOCAL) |= 0x1 << 0; /*PLLEN Bit 0 (0h Disable, 1h Enable) */
+	LGM_NET_DBG("LJPLL_CFG0_LOCAL 0x%08x\n", REG32(LJPLL_CFG0_LOCAL));
+
+	/*To wait for LJPLL3 lock status */
+	#define LJPLL3_LOCK BIT(1) /*LJPLL3 Lock Bit */
+
+	/* LJPLL_CFG0 */
+
+	for (i = 0; i < LJPLL3_LOCK_POLL_CNT; i++) {
+		if ((REG32(LJPLL_CFG0_LOCAL) & BIT(1)))
+		{
+			LGM_NET_DBG("LJPLL3_CFG0 0x%08x LJPLL3_LOCK %s\n",
+			REG32(LJPLL_CFG0_LOCAL), (REG32(LJPLL_CFG0_LOCAL) & LJPLL3_LOCK)? "set": "clr");
+			break;
+		}
+		udelay(10);
+	}
+
+	if (i >= LJPLL3_LOCK_POLL_CNT)
+		LGM_NET_DBG("LJPLL3 Lock failed\n");
+	else {
+		LGM_NET_DBG("LJPLL3 Lock succeed\n");
+	}
+
+	LGM_NET_DBG("Enable all the LJPLL3_CFG1 FOUT0-3\n");
+	/*Enable all FOUT0-3 after PLL lock. */
+	/*#define LJPLL3_CFG1		(0xE02000C4) */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 24);
+	REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 24; /*FOUT0EN Bit 24 PLL Clock Output 0 Enable */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 25);
+	REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 25; /*FOUT1EN Bit 25 PLL Clock Output 1 Enable */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 26);
+	REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 26; /*FOUT2EN Bit 26 PLL Clock Output 2 Enable */
+	REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 27);
+	REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 27; /*FOUT3EN Bit 27 PLL Clock Output 3 Enable */
+	LGM_NET_DBG("LJPLL3_CFG1 0x%08x\n", REG32(LJPLL_CFG1_LOCAL)); /*Check bit 7 = 3 and Bit 0 = 8. */
+
+}
+
+void hsiotop_clk_gate_cfg(int port, int dis)
+{
+	if (port == 0) {
+		/*SET_X_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis); */
+		REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis);
+
+		LGM_NET_DBG("HSIOL Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	} else if(port == 1) {
+		/*SET_X_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis); */
+		REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+		LGM_NET_DBG("HSIOL Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	} else if(port == 2) {
+		/*SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis); */
+		REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis);
+		LGM_NET_DBG("HSIOR Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	} else if(port == 3) {
+		/*SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis); */
+		REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+		LGM_NET_DBG("HSIOR Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	}
+}
+
+int combophy_mode(int port, int mode)
+{
+	u32 BASE_ADDR = 0;
+
+	if (port == 0 || port == 1) {
+		BASE_ADDR = HSIOL_TOP_BASE + ETHSATA_COMBOPHY_MODE;
+		SET_X_BITS(REG32(BASE_ADDR),
+			ETHSATA_COMBOPHY_MODE_POS,
+			ETHSATA_COMBOPHY_MODE_WIDTH, mode);
+	} else if (port == 2 || port == 3) {
+		BASE_ADDR = HSIOR_TOP_BASE + ETHSATA_COMBOPHY_MODE;
+		SET_X_BITS(REG32(BASE_ADDR), ETHSATA_COMBOPHY_MODE_POS,
+			ETHSATA_COMBOPHY_MODE_WIDTH, mode);
+	} else if (port == P34X_PORT5) {
+		set_reset(RST_REQ_ETHNOC, REQ_XPCS5_CPHY);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_CPHY Reset BIT17 Asserted\n");
+	} else {
+		LGM_NET_DBG("Error setting combophy mode on port %d\n", port);
+		return -1;
+	}
+
+	LGM_NET_DBG("HSIO%s_TOP.ETHSATA_COMBOPHY_MODE BIT2:0 REG32(0x%08x) = 0x%08x\n",
+			(port == 0 || port == 1) ? "L" : "R",
+			BASE_ADDR, GET_X_BITS(REG32(BASE_ADDR),
+			ETHSATA_COMBOPHY_MODE_POS,
+			ETHSATA_COMBOPHY_MODE_WIDTH));
+	return 0;
+}
+
+void pon_aon_clk_gate_cfg(int pon_wan, int en)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base = combo_phy_app_base(paddr, PON_WAN_PORT4);
+	u32 BASE_ADDR;
+	BASE_ADDR = phy_app_base + PON_SHELL_GEN_CTRL;
+
+	/* bit 13,12,5 is set to 0 */
+	/* rd_data |= ((1 << 11) | (1 << 4) | (1 << 2)); */
+	if (pon_wan == PON_MODE) {
+		SET_X_BITS(REG32(BASE_ADDR), AON_CLK_GATE_POS, AON_CLK_GATE_WIDTH, 0x1);
+		SET_X_BITS(REG32(BASE_ADDR), PON_CLK_GATE_POS, PON_CLK_GATE_WIDTH, en);
+		SET_X_BITS(REG32(BASE_ADDR), CR_PARA_CLK_GATE_POS, CR_PARA_CLK_GATE_WIDTH, en);
+		if (en == 0)
+			LGM_NET_DBG("PON_SHELL_GEN_CTRL: Enable PON_CLK & CR_PARA_CLK\n");
+		else
+			LGM_NET_DBG("PON_SHELL_GEN_CTRL: Disable PON_CLK & CR_PARA_CLK\n");
+	} else if (pon_wan == WAN_MODE) {
+		SET_X_BITS(REG32(BASE_ADDR), AON_CLK_GATE_POS, AON_CLK_GATE_WIDTH, en);
+		SET_X_BITS(REG32(BASE_ADDR), PON_CLK_GATE_POS, PON_CLK_GATE_WIDTH, 0x1);
+		SET_X_BITS(REG32(BASE_ADDR), CR_PARA_CLK_GATE_POS, CR_PARA_CLK_GATE_WIDTH, en);
+		if (en == 0)
+			LGM_NET_DBG("PON_SHELL_GEN_CTRL: Enable AON_CLK & CR_PARA_CLK\n");
+		else
+			LGM_NET_DBG("PON_SHELL_GEN_CTRL: Disable AON_CLK & CR_PARA_CLK\n");
+	}
+}
+
+void ponwanphy_mode(int mode, int epon_en)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base = combo_phy_app_base(paddr, PON_WAN_PORT4);
+	u32 BASE_ADDR;
+	BASE_ADDR = phy_app_base + PON_SHELL_MODE_SEL;
+
+	if (mode == PON_MODE) {
+		SET_X_BITS(REG32(BASE_ADDR), PON_ETH_SEL_POS, PON_ETH_SEL_WIDTH, PON_MODE);
+		SET_X_BITS(REG32(BASE_ADDR), LOOP_SYNCE_SEL_POS, LOOP_SYNCE_SEL_WIDTH, LOOP);
+		SET_X_BITS(REG32(BASE_ADDR), SEL_10GEPON_POS, SEL_10GEPON_WIDTH, epon_en);
+		LGM_NET_DBG("PON MODE: PON_SHELL_MODE_SEL REG32(0x%08x) = 0x%08x\n", BASE_ADDR, REG32(BASE_ADDR));
+	} else if (mode == WAN_MODE) {
+		SET_X_BITS(REG32(BASE_ADDR), PON_ETH_SEL_POS, PON_ETH_SEL_WIDTH, WAN_MODE);
+		SET_X_BITS(REG32(BASE_ADDR), LOOP_SYNCE_SEL_POS, LOOP_SYNCE_SEL_WIDTH, SYNCE);
+		/* SET_X_BITS(REG32(BASE_ADDR), LOOP_SYNCE_SEL_POS, LOOP_SYNCE_SEL_WIDTH, LOOP); */
+		SET_X_BITS(REG32(BASE_ADDR), SEL_10GEPON_POS, SEL_10GEPON_WIDTH, 0x0);
+		LGM_NET_DBG("WAN MODE: PON_SHELL_MODE_SEL REG32(0x%08x) = 0x%08x\n", BASE_ADDR, REG32(BASE_ADDR));
+	}
+}
+
+int pon_shell_rst_assert(void)
+{
+	udelay(1);
+	set_reset(RST_REQ_ETHNOC, REQ_PON);
+	LGM_NET_DBG("ETHNOC_REQ PON Reset BIT9 Asserted\n");
+	return 0;
+}
+
+int pon_shell_rst_deassert(void)
+{
+	udelay(1);
+	clear_reset(RST_REQ_ETHNOC, REQ_PON);
+	LGM_NET_DBG("ETHNOC_REQ PON Reset BIT9 Deasserted\n");
+	return 0;
+}
+
+int pon_shell_rst_stat(void)
+{
+	int stat;
+	udelay(1);
+	stat = get_reset_bit_status(RST_STAT_ETHNOC, REQ_PON);
+	stat = get_reset_bit_status(RST_STAT_ETHNOC, REQ_PON);
+	/* LGM_NET_DBG("ETHNOC_REQ PON Reset BIT9 Status = %d\n", stat); */
+	return stat;
+}
+
+int combophy_rst_assert(int port)
+{
+	if (port == COMBO_PORT10 || port == COMBO_PORT11) {
+		set_reset(RST_REQ_HSIOL, REQ_PCIE1X_CPHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE1X_CPHY Reset BIT17 Asserted\n");
+	} else if(port == COMBO_PORT20 || port == COMBO_PORT21){
+		set_reset(RST_REQ_HSIOR, REQ_PCIE2X_CPHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE2X_CPHY Reset BIT17 Asserted\n");
+	} else if(port == P34X_PORT5) {
+		set_reset(RST_REQ_ETHNOC, REQ_XPCS5_CPHY);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_CPHY Reset BIT17 Asserted\n");
+	}
+
+	return 0;
+}
+
+int combophy_rst_deassert(int port)
+{
+	if (port == COMBO_PORT10 || port == COMBO_PORT11) {
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE1X_CPHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE1X_CPHY Reset BIT17 Desserted\n");
+	} else if (port == COMBO_PORT20 || port == COMBO_PORT21) {
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE2X_CPHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE2X_CPHY Reset BIT17 Deasserted\n");
+	} else if (port == P34X_PORT5) {
+		clear_reset(RST_REQ_ETHNOC, REQ_XPCS5_CPHY);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_CPHY Reset BIT17 Deasserted\n");
+	}
+
+	return 0;
+}
+
+int combophy_rst_stat(int port)
+{
+	int stat = 0;
+
+	udelay(1);
+	if(port == COMBO_PORT10 || port == COMBO_PORT11) {
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE1X_CPHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE1X_CPHY);
+		/*LGM_NET_DBG("HSIOL_STAT STAT_PCIE1X_CPHY Reset BIT17 Status = %d\n", stat); */
+	} else if (port == COMBO_PORT20 || port == COMBO_PORT21) {
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE2X_CPHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE2X_CPHY);
+		/*LGM_NET_DBG("HSIOR_STAT STAT_PCIE2X_CPHY Reset BIT17 Status = %d\n", stat); */
+	} else if (port == P34X_PORT5) {
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_CPHY);
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_CPHY);
+		/*LGM_NET_DBG("ETHNOC_STAT STAT_XPCS5_CPHY Reset BIT17 Status = %d\n", stat); */
+	}
+
+	return stat;
+}
+
+int eth_phy_rst_deassert(int port)
+{
+	if (port == COMBO_PORT10 || port == COMBO_PORT11) {
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE10_PHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE10_PHY Reset BIT6 Deasserted\n");
+	} else if (port == COMBO_PORT20 || port == COMBO_PORT21) {
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE20_PHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE20_PHY Reset BIT6 Deasserted\n");
+	} else if (port == P34X_PORT5) {
+		clear_reset(RST_REQ_ETHNOC, REQ_XPCS5_PHY0);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_PHY0 Reset BIT16 Deasserted\n");
+	}
+	return 0;
+}
+
+int eth_phy_rst_stat(int port)
+{
+	int stat = 0;
+
+	udelay(1);
+
+	if (port == COMBO_PORT10 || port == COMBO_PORT11) {
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE10_PHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE10_PHY);
+		/*LGM_NET_DBG("HSIOL_STAT STAT_PCIE10_PHY Reset BIT6 = %d\n", stat); */
+	} else if (port == COMBO_PORT20 || port == COMBO_PORT21){
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE20_PHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE20_PHY);
+		/*LGM_NET_DBG("HSIOR_STAT STAT_PCIE20_PHY Reset BIT6 = %d\n", stat); */
+	} else if (port == P34X_PORT5) {
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_PHY0);
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_PHY0);
+		/*LGM_NET_DBG("ETHNOC_STAT STAT_XPCS5_PHY0 Reset BIT16 = %d\n", stat); */
+	}
+
+	return stat;
+}
+
+int eth_phy_rst_assert(int port)
+{
+	if (port == COMBO_PORT10 || port == COMBO_PORT11) {
+		set_reset(RST_REQ_HSIOL, REQ_PCIE10_PHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE10_PHY Reset BIT6 Asserted\n");
+	} else if (port == COMBO_PORT20 || port == COMBO_PORT21) {
+		set_reset(RST_REQ_HSIOR, REQ_PCIE20_PHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE20_PHY Reset BIT6 Asserted\n");
+	}else if(port == P34X_PORT5){
+		set_reset(RST_REQ_ETHNOC, REQ_XPCS5_PHY0);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_PHY0 Reset BIT16 Asserted\n");
+	}
+	return 0;
+}
+
+void combophy_paraclk_div2_cfg(struct combo_port *paddr, int port, int en)
+{
+	u32 phy_app_base = combo_phy_app_base(paddr, port);
+	u32 BASE_ADDR;
+
+	BASE_ADDR = phy_app_base + PON_SHELL_GEN_CTRL;
+	/* bit 2 to 1 */
+	SET_X_BITS(REG32(BASE_ADDR), CR_PARA_CLK_DIV2_EN_POS,
+			CR_PARA_CLK_DIV2_EN_WIDTH, en);
+	LGM_NET_DBG("PCIE_GEN_CTRL CR_PARA_CLK_DIV2_EN BIT2 REG32(0x%08x) = 0x%08x\n",
+			BASE_ADDR, REG32(BASE_ADDR));
+}
+
+void combophy_sram_bypass_cfg(struct combo_port *paddr, int port, int en)
+{
+	u32 phy_app_base = combo_phy_app_base(paddr, port);
+	u32 BASE_ADDR;
+
+	BASE_ADDR = phy_app_base + PON_SHELL_SRAM_CSR;
+	/*bit 0 to 1 */
+	SET_X_BITS(REG32(BASE_ADDR),
+		SRAM_BYPASS_POS, SRAM_BYPASS_WIDTH, en);
+	LGM_NET_DBG("PCIE_SRAM_CSR SRAM_BYPASS BIT0 REG32(0x%08x) = 0x%08x\n",
+			BASE_ADDR, REG32(BASE_ADDR));
+}
+
+void phy_rxeq_autoadapt(int port, int lane)
+{
+	int i;
+	/*u32 phy_cr_base = combo_phy_cr_base(port), */
+	u32 rd_data;
+
+	if (port!= P34X_PORT5) {
+		LGM_NET_DBG("\nRX value before Adaptation:\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_0 (0x%08x) = 0x%08x\nBIT15:11 EQ_CTLE_BOOST\nBIT10:7 EQ_VGA2_GAIN\nBIT6:3 EQ_VGA1_GAIN\nBIT2:0 EQ_ATT_LVL\n",
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(port, lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(port, lane)));
+		LGM_NET_DBG("\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_1 (0x%08x) = 0x%08x\nBIT10:3 EQ_DFE_TAP1\nBIT2:0 EQ_CTLE_POLE\n",
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(port, lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(port, lane)));
+
+		/*RAWLANEN_DIG_PCS_XF_RX_OVRD_IN_3 */
+		/* 	15		CONT_OVRD_EN = 0
+			14		OFFCAN_CONT = 0
+			13		ADAPT_CONT = 0
+			12		ADAPT_REQ_OVRD_EN = 0
+			11		ADAPT_REQ = 0
+			10		REF_LD_VAL_OVRD_EN = 0
+			9:4		REF_LD_VAL_OVRD = 0
+			3		RX_LOS_THRSHLD_OVRD_EN = 0
+			2:0		RX_LOS_THRSHLD_OVRD_VAL = 0
+		*/
+
+		REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) &= ~(0x3 << 4); /*Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5 */
+		REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) |= 0x3 << 4; /*ADAPT_REQ and ADAPT_REQ_OVRD_EN set to '11' */
+		LGM_NET_DBG("\nRequest for RX Adaptation to start:\n RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2 (0x%08x) = 0x%08x\n",
+			(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)), REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) );
+
+		/*Check for RX Adaptation is done RAWLANEN_DIG_AON_RX_ADAPT_DONE.RX_ADAPT_DONE[0] */
+		for (i = 0; i < PHY_RXADAPT_POLL_CNT; i++) {
+			if ((REG32(RAWLANEN_DIG_PCS_XF_RX_ADAPT_ACK(port, lane))  & BIT(0)))
+				break;
+			udelay(10);
+		}
+		if (i >= PHY_RXADAPT_POLL_CNT)
+			LGM_NET_DBG("RX Adaptation not done %d\n", port);
+		else {
+			LGM_NET_DBG("RX Adaptation done %d\n", port);
+		}
+
+		/*Stop RX Adaptation */
+		REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) &= ~(0x3 << 4); /*Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5 */
+		LGM_NET_DBG("RX Adaptation Turn off after done:\n RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2 (0x%08x) = 0x%08x\n",
+			(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)), REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) );
+
+		/*Display RX Adapt Value in PMA */
+		LGM_NET_DBG("\nRead back on RX Adapted Value\n");
+		/*LANEN_DIG_RX_ADPTCTL_ATT_STATUS ATT Adaptation code */
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_ATT_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_ATT_STATUS(port, lane)), REG32(LANEN_DIG_RX_ADPTCTL_ATT_STATUS(port, lane)) );
+
+		/*LANEN_DIG_RX_ADPTCTL_VGA_STATUS VGA Adaptation code */
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_VGA_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_VGA_STATUS(port, lane)), REG32(LANEN_DIG_RX_ADPTCTL_VGA_STATUS(port, lane)) );
+
+		/*LANEN_DIG_RX_ADPTCTL_CTLE_STATUS CTLE Adaptation code */
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_CTLE_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_CTLE_STATUS(port, lane)), REG32(LANEN_DIG_RX_ADPTCTL_CTLE_STATUS(port, lane)) );
+
+		/*LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS DFE Tap1 Adaptation code */
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS(port, lane)), REG32(LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS(port, lane)) );
+
+		LGM_NET_DBG("\n RX value after Adaptation:\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_0 (0x%08x) = 0x%08x\nBIT15:11 EQ_CTLE_BOOST\nBIT10:7 EQ_VGA2_GAIN\nBIT6:3 EQ_VGA1_GAIN\nBIT2:0 EQ_ATT_LVL\n",
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(port, lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(port, lane)));
+		LGM_NET_DBG("\n LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1 (0x%08x) = 0x%08x\nBIT10:3 EQ_DFE_TAP1\nBIT2:0 EQ_CTLE_POLE\n",
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(port, lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(port, lane)));
+	} else {
+		rd_data = serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane));
+		rd_data &= ~(0x7 << 0); /*Clear BITS 2:0 */
+		serdes_cr_write(port, LANEN_DIG_ASIC_LANE_OVRD_IN_OFFSET(lane), rd_data);
+
+		LGM_NET_DBG("\nRX value before Adaptation:\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_0 (0x%08x) = 0x%08x\nBIT15:11 EQ_CTLE_BOOST\nBIT10:7 EQ_VGA2_GAIN\nBIT6:3 EQ_VGA1_GAIN\nBIT2:0 EQ_ATT_LVL\n",
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane)), serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane)));
+		LGM_NET_DBG("\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_1 (0x%08x) = 0x%08x\nBIT10:3 EQ_DFE_TAP1\nBIT2:0 EQ_CTLE_POLE\n",
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(lane)), serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(lane)));
+
+		/*RAWLANEN_DIG_PCS_XF_RX_OVRD_IN_3 */
+		/* 	15		CONT_OVRD_EN = 0
+			14		OFFCAN_CONT = 0
+			13		ADAPT_CONT = 0
+			12		ADAPT_REQ_OVRD_EN = 0
+			11		ADAPT_REQ = 0
+			10		REF_LD_VAL_OVRD_EN = 0
+			9:4		REF_LD_VAL_OVRD = 0
+			3		RX_LOS_THRSHLD_OVRD_EN = 0
+			2:0		RX_LOS_THRSHLD_OVRD_VAL = 0
+		*/
+		rd_data = serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane));
+		rd_data &= ~(0x3 << 4); /*Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5 */
+		rd_data |= 0x3 << 4; /*ADAPT_REQ and ADAPT_REQ_OVRD_EN set to '11' */
+		serdes_cr_write(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane), rd_data);
+		LGM_NET_DBG("\nRequest for RX Adaptation to start:\n RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2 (0x%08x) = 0x%08x\n",
+			(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane)), serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane)));
+
+		/*Check for RX Adaptation is done RAWLANEN_DIG_AON_RX_ADAPT_DONE.RX_ADAPT_DONE[0] */
+		for (i = 0; i < PHY_RXADAPT_POLL_CNT; i++) {
+			if ((serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_RX_ADAPT_ACK_OFFSET(lane)))  & BIT(0))
+				break;
+			udelay(10);
+		}
+
+		if (i >= PHY_RXADAPT_POLL_CNT) {
+			LGM_NET_DBG("RX port %d Adaptation not done\n", port);
+		} else {
+			LGM_NET_DBG("RX port %d Adaptation done\n", port);
+		}
+
+		/*Stop RX Adaptation */
+		rd_data = serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane));
+		rd_data &= ~(0x3 << 4); /*Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5 */
+		serdes_cr_write(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane), rd_data); /*Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5 */
+		LGM_NET_DBG("RX Adaptation Turn off after done:\n RAWLANEN_DIG_PCS_XF_RX_OVRD_IN_3 (0x%08x) = 0x%08x\n",
+			(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane)), serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane)));
+
+		/*Display RX Adapt Value in PMA */
+		LGM_NET_DBG("\nRead back on RX Adapted Value\n");
+		/*LANEN_DIG_RX_ADPTCTL_ATT_STATUS ATT Adaptation code */
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_ATT_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_ATT_STATUS_OFFSET(lane)), serdes_cr_read(port, LANEN_DIG_RX_ADPTCTL_ATT_STATUS_OFFSET(lane)));
+
+		/*LANEN_DIG_RX_ADPTCTL_VGA_STATUS VGA Adaptation code */
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_VGA_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_VGA_STATUS_OFFSET(lane)), serdes_cr_read(port, LANEN_DIG_RX_ADPTCTL_VGA_STATUS_OFFSET(lane)));
+
+		/*LANEN_DIG_RX_ADPTCTL_CTLE_STATUS CTLE Adaptation code */
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_CTLE_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_CTLE_STATUS_OFFSET(lane)), serdes_cr_read(port, LANEN_DIG_RX_ADPTCTL_CTLE_STATUS_OFFSET(lane)));
+
+		/*LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS DFE Tap1 Adaptation code */
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS_OFFSET(lane)), serdes_cr_read(port, LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS_OFFSET(lane)));
+
+		LGM_NET_DBG("\n RX value after Adaptation:\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_0 (0x%08x) = 0x%08x\nBIT15:11 EQ_CTLE_BOOST\nBIT10:7 EQ_VGA2_GAIN\nBIT6:3 EQ_VGA1_GAIN\nBIT2:0 EQ_ATT_LVL\n",
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane)));
+		LGM_NET_DBG("\n LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1 (0x%08x) = 0x%08x\nBIT10:3 EQ_DFE_TAP1\nBIT2:0 EQ_CTLE_POLE\n",
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(lane)), serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(lane)));
+	}
+}
+
+void ponip_rst_assert(void)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base =  combo_phy_app_base(paddr, PON_WAN_PORT4);
+	SET_X_BITS(REG32(phy_app_base + PON_SHELL_GEN_CTRL), PON_RST_N_POS, PON_RST_N_WIDTH, 0x0);
+	LGM_NET_DBG("PON_SHELL_GEN_CTRL: ponip_rst asserted (0x%08x) = 0x%08x\n \n",
+		REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL));
+}
+
+void ponip_rst_deassert(void)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base =  combo_phy_app_base(paddr, PON_WAN_PORT4);
+	SET_X_BITS(REG32(phy_app_base + PON_SHELL_GEN_CTRL), PON_RST_N_POS, PON_RST_N_WIDTH, 0x1);
+	LGM_NET_DBG("PON_SHELL_GEN_CTRL: ponip_rst deasserted (0x%08x) = 0x%08x\n \n",
+		REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL));
+}
+
+void pon_wan_phy_rst_assert(void)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base =  combo_phy_app_base(paddr, PON_WAN_PORT4);
+	SET_X_BITS(REG32(phy_app_base + PON_SHELL_GEN_CTRL), PHY_RST_N_POS, PHY_RST_N_WIDTH, 0x0);
+	LGM_NET_DBG("PON_SHELL_GEN_CTRL: pon wan phyrst asserted (0x%08x) = 0x%08x\n \n",
+		REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL));
+}
+
+void pon_wan_phy_rst_deassert(void)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base =  combo_phy_app_base(paddr, PON_WAN_PORT4);
+	SET_X_BITS(REG32(phy_app_base + PON_SHELL_GEN_CTRL), PHY_RST_N_POS, PHY_RST_N_WIDTH, 0x1);
+	LGM_NET_DBG("PON_SHELL_GEN_CTRL: pon wan phyrst deasserted (0x%08x) = 0x%08x\n \n",
+		REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL));
+}
+
+void pon_wan_xpcs_rst_assert(void)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base =  combo_phy_app_base(paddr, PON_WAN_PORT4);
+	SET_X_BITS(REG32(phy_app_base + PON_SHELL_GEN_CTRL), XPCS_RST_N_POS, XPCS_RST_N_WIDTH, 0x0);
+	LGM_NET_DBG("PON_SHELL_GEN_CTRL: pon wan xpcs rst asserted (0x%08x) = 0x%08x\n \n",
+		REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL));
+}
+
+void pon_wan_xpcs_rst_deassert(void)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base =  combo_phy_app_base(paddr, PON_WAN_PORT4);
+	SET_X_BITS(REG32(phy_app_base + PON_SHELL_GEN_CTRL), XPCS_RST_N_POS, XPCS_RST_N_WIDTH, 0x1);
+	LGM_NET_DBG("PON_SHELL_GEN_CTRL: pon wan xpcs rst deasserted (0x%08x) = 0x%08x\n \n",
+		REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL));
+}
+
+void pon_shell_wan_init(int epon_en)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_app_base =  combo_phy_app_base(paddr, PON_WAN_PORT4);
+
+	/* u32 BASE_ADDR; */
+	/* BASE_ADDR = phy_app_base + PON_SHELL_GEN_CTRL; */
+
+	/* Disable AON_CLK_GATE and CR_PARA_CLK_GATE */
+	/* Enable Clock for XPCS */
+	pon_aon_clk_gate_cfg(pon_eth_sel, 0); /* 0 means disable glock gate. */
+	udelay(10);
+
+	/* Configuring PON/WAN/EPON Mode */
+	ponwanphy_mode(pon_eth_sel, epon_en); /* 2nd Argument means EPON_EN. 0h means disable. */
+
+	/* Enable PARA_CLK_DIV2_EN for APB Logic Application Logic */
+	/* SET_X_BITS(REG32(phy_app_base+PON_SHELL_GEN_CTRL), CR_PARA_CLK_DIV2_EN_POS, CR_PARA_CLK_DIV2_EN_WIDTH, 0x1); */
+
+	if (pon_eth_sel == WAN_MODE) {
+		/* Assert phy and xpcs reset of pon shell */
+		pon_wan_xpcs_rst_assert();
+		pon_wan_phy_rst_assert();
+		/* Assert PONIP to ensure PONIP reset is not de-asserted */
+		ponip_rst_assert();
+	}
+
+	/* Disable AON_CLK_GATE or PON_CLK_GATE and CR_PARA_CLK_GATE */
+	pon_aon_clk_gate_cfg(pon_eth_sel, 0); /* 0 means disable glock gate. */
+
+	/* [PON MODE ONLY] Deassert PONIP Reset */
+	if(pon_eth_sel == PON_MODE)
+		ponip_rst_deassert();
+
+	udelay(10);
+
+	/* Set PMA and PCS Power Stable. This PCS is Raw PCS in the Serdes? */
+	SET_X_BITS(REG32(phy_app_base + PON_SHELL_EXT_PG_CTRL), PON_SHELL_PMA_PWR_STABLE_POS, PON_SHELL_PMA_PWR_STABLE_WIDTH, 0x1);
+	SET_X_BITS(REG32(phy_app_base + PON_SHELL_EXT_PG_CTRL), PON_SHELL_PCS_PWR_STABLE_POS, PON_SHELL_PCS_PWR_STABLE_WIDTH, 0x1);
+	LGM_NET_DBG("PON SHELL: Set PMA and PCS Power Stable\n");
+	LGM_NET_DBG("PON SHELL PMA PCS PWR STABLE REG(0x%08x): 0x%08x\n", (phy_app_base + PON_SHELL_EXT_PG_CTRL),REG32(phy_app_base + PON_SHELL_EXT_PG_CTRL));
+	udelay(10);	
+
+	/* PON_ETH_INIT configure after Power Stable. xxxPON_INIT configure before pon_ip deassert */
+	/* Configuring PON/WAN/EPON Mode */
+	/* ponwanphy_mode(WAN_MODE, 0); */ /* 2nd Argument means EPON EN. 0h means disable.*/
+
+	/* Output Enable for CML MUX to PHY REFCLK. Set to 1.*/
+	SET_X_BITS(REG32(phy_app_base+PON_SHELL_MODE_SEL), PON_SHELL_REFCLK_EN_POS, PON_SHELL_REFCLK_EN_WIDTH, 0x1);
+	LGM_NET_DBG("Enable CML MUX Output:\n PON_SHELL_MODE_SEL(0x%08x) = 0x%08x\n",(phy_app_base+PON_SHELL_MODE_SEL),REG32(phy_app_base+PON_SHELL_MODE_SEL));
+
+	/* [WAN MODE ONLY] Deassert PHY_RST, XPCS_RST */
+	if(pon_eth_sel == WAN_MODE){
+		pon_wan_xpcs_rst_deassert();
+		pon_wan_phy_rst_deassert();
+	}
+	LGM_NET_DBG("PON_INIT DONE:\n PON_SHELL_GEN_CTRL(0x%08x) = 0x%08x\n",REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL));
+}
+
diff --git a/drivers/net/lightning_mountain_combophy.h b/drivers/net/lightning_mountain_combophy.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lightning_mountain_combophy.h
@@ -0,0 +1,1097 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright © 2022 MaxLinear, Inc.
+ *
+ * Lightning Mountain Slim Ethernet Driver
+ *
+ */
+#ifndef COMBOPHY_H
+#define COMBOPHY_H
+
+#define REQ_PCIE10_PCIE0	0	/*PCIe Controller 10 */
+#define REQ_PCIE11_PCIE1	1	/*PCIe Controller 11 */
+#define REQ_PCIE30_PCIE0	2	/*PCIe Controller 30 */
+#define REQ_PCIE31_PCIE1	3	/*PCIe Controller 31 */
+#define REQ_PCIE10_PHY		6	/*HSIO1 PHY - SERDES */
+#define REQ_PCIE30_PHY		8	/*HSIO3 PHY - SERDES */
+#define REQ_PCIE10_PCS		12	/*PCIE10_PCS */
+#define REQ_PCIE11_PCS		13	/*PCIE11_PCS */
+#define REQ_HSIOL_SATA0		15	/*SATA Controller 0 */
+#define REQ_HSIOL_SATA1		16	/*SATA Controller 1 */
+#define REQ_PCIE1X_CPHY		17	/*PCIE1x_Combo PHY Domain */
+#define REQ_PCIE3X_CPHY		18	/*PCIE3x_Combo PHY Domain */
+#define REQ_PCIE10_PERST	23	/*PCIE10 PERST */
+#define REQ_PCIE11_PERST	24	/*PCIE11 PERST */
+#define REQ_PCIE30_PERST	25	/*PCIE30 PERST */
+#define REQ_PCIE31_PERST	26	/*PCIE31 PERST */
+#define REQ_HSIOL_NOC		31	/*HSIOL_NOC Domain */
+
+#define REQ_PCIE20_PCIE0	0	/*PCIe Controller 20 */
+#define REQ_PCIE21_PCIE1	1	/*PCIe Controller 21 */
+#define REQ_PCIE40_PCIE0	2	/*PCIe Controller 40 */
+#define REQ_PCIE41_PCIE1	3	/*PCIe Controller 41 */
+#define REQ_PCIE20_PHY		6	/*HSIO2 PHY - SERDES */
+#define REQ_PCIE40_PHY		8	/*HSIO4 PHY - SERDES */
+#define REQ_PCIE20_PCS		12	/*PCIE20_PCS */
+#define REQ_PCIE21_PCS		13	/*PCIE21_PCS */
+#define REQ_HSIOR_SATA0		15	/*HSIOR SATA Controller 0 */
+#define REQ_HSIOR_SATA1		16	/*HSIOR SATA Controller 1 */
+#define REQ_PCIE2X_CPHY		17	/*PCIE2x_Combo PHY Domain */
+#define REQ_PCIE4X_CPHY		18	/*PCIE4x_Combo PHY Domain */
+#define REQ_PCIE20_PERST	23	/*PCIE20 PERST */
+#define REQ_PCIE21_PERST	24	/*PCIE21 PERST */
+#define REQ_PCIE40_PERST	25	/*PCIE40 PERST */
+#define REQ_PCIE41_PERST	26	/*PCIE41 PERST */
+#define REQ_HSIOL_NOC		31	/*HSIOR_NOC Domain */
+
+#define REQ_IDMAR1			0	/*IDMAR1 */
+#define REQ_IDMAT0			1	/*IDMAT0 */
+#define REQ_IDMAT1			2	/*IDMAT1 */
+#define REQ_IDMAT2			3	/*IDMAT2 */
+#define REQ_GSWIPO			8	/*GSWIPO */
+#define REQ_PON				9	/*PON */
+#define REQ_CQM				11	/*CQM */
+#define REQ_ARCEM6			12	/*ARCEM6 */
+#define REQ_XPCS5_PCS0		15	/*XPCS5_PCS0 */
+#define REQ_XPCS5_PHY0		16	/*XPCS5_PHY0 */
+#define REQ_XPCS5_CPHY		17	/*XPCS5_CPHY */
+#define REQ_USB_CTRL0		22	/*USB_CTRL0 */
+#define REQ_USB_CTRL1		23	/*USB_CTRL1 */
+#define REQ_USB_PHY0		24	/*USB_PHY0 */
+#define REQ_USB_PHY1		25	/*USB_PHY1 */
+#define REQ_USB_APB0		26	/*USB_APB0 */
+#define REQ_USB_APB1		27	/*USB_APB1 */
+#define REQ_USB0_PHY31		28	/*USB0_PHY31 */
+#define REQ_USB1_PHY31		29	/*USB1_PHY31 */
+#define REQ_ADP_SUP_RST		30	/*USB1_PHY31 */
+#define REQ_ETHNOC			31	/*ETHNOC */
+
+#define RST_STAT_HSIOR	0x64
+
+#define STAT_PCIE20_PCIE0	0	/*PCIe Controller 20 */
+#define STAT_PCIE21_PCIE1	1	/*PCIe Controller 21 */
+#define STAT_PCIE40_PCIE0	2	/*PCIe Controller 40 */
+#define STAT_PCIE41_PCIE1	3	/*PCIe Controller 41 */
+#define STAT_PCIE20_PHY		6	/*HSIO2 PHY - SERDES */
+#define STAT_PCIE40_PHY		8	/*HSIO4 PHY - SERDES */
+#define STAT_PCIE20_PCS		12	/*PCIE20_PCS */
+#define STAT_PCIE21_PCS		13	/*PCIE21_PCS */
+#define STAT_HSIOR_SATA0	15	/*HSIOR SATA Controller 0 */
+#define STAT_HSIOR_SATA1	16	/*HSIOR SATA Controller 1 */
+#define STAT_PCIE2X_CPHY	17	/*PCIE2x_Combo PHY Domain */
+#define STAT_PCIE4X_CPHY	18	/*PCIE4x_Combo PHY Domain */
+#define STAT_PCIE20_PERST	23	/*PCIE20 PERST */
+#define STAT_PCIE21_PERST	24	/*PCIE21 PERST */
+#define STAT_PCIE40_PERST	25	/*PCIE40 PERST */
+#define STAT_PCIE41_PERST	26	/*PCIE41 PERST */
+#define STAT_HSIOL_NOC		31	/*HSIOR_NOC Domain */
+
+#define STAT_IDMAR1			0	/*IDMAR1 */
+#define STAT_IDMAT0			1	/*IDMAT0 */
+#define STAT_IDMAT1			2	/*IDMAT1 */
+#define STAT_IDMAT2			3	/*IDMAT2 */
+#define STAT_GSWIPO			8	/*GSWIPO */
+#define STAT_PON			9	/*PON */
+#define STAT_CQM			11	/*CQM */
+#define STAT_ARCEM6			12	/*ARCEM6 */
+#define STAT_XPCS5_PCS0		15	/*XPCS5_PCS0 */
+#define STAT_XPCS5_PHY0		16	/*XPCS5_PHY0 */
+#define STAT_XPCS5_CPHY		17	/*XPCS5_CPHY */
+#define STAT_USB_CTRL0		22	/*USB_CTRL0 */
+#define STAT_USB_CTRL1		23	/*USB_CTRL1 */
+#define STAT_USB_PHY0		24	/*USB_PHY0 */
+#define STAT_USB_PHY1		25	/*USB_PHY1 */
+#define STAT_USB_APB0		26	/*USB_APB0 */
+#define STAT_USB_APB1		27	/*USB_APB1 */
+#define STAT_USB0_PHY31		28	/*USB0_PHY31 */
+#define STAT_USB1_PHY31		29	/*USB1_PHY31 */
+#define STAT_ADP_SUP_RST	30	/*USB1_PHY31 */
+#define STAT_ETHNOC			31	/*ETHNOC */
+
+#define RST_STAT_HSIOL	0x54
+
+#define STAT_PCIE10_PCIE0	0	/*PCIe Controller 10 */
+#define STAT_PCIE11_PCIE1	1	/*PCIe Controller 11 */
+#define STAT_PCIE30_PCIE0	2	/*PCIe Controller 30 */
+#define STAT_PCIE31_PCIE1	3	/*PCIe Controller 31 */
+#define STAT_PCIE10_PHY		6	/*HSIO1 PHY - SERDES */
+#define STAT_PCIE30_PHY		8	/*HSIO3 PHY - SERDES */
+#define STAT_PCIE10_PCS		12	/*PCIE10_PCS */
+#define STAT_PCIE11_PCS		13	/*PCIE11_PCS */
+#define STAT_HSIOL_SATA0	15	/*HSIOL SATA Controller 0 */
+#define STAT_HSIOL_SATA1	16	/*HSIOL SATA Controller 1 */
+#define STAT_PCIE1X_CPHY	17	/*PCIE1x_Combo PHY Domain */
+#define STAT_PCIE3X_CPHY	18	/*PCIE3x_Combo PHY Domain */
+#define STAT_PCIE10_PERST	23	/*PCIE10 PERST */
+#define STAT_PCIE11_PERST	24	/*PCIE11 PERST */
+#define STAT_PCIE30_PERST	25	/*PCIE30 PERST */
+#define STAT_PCIE31_PERST	26	/*PCIE31 PERST */
+#define STAT_HSIOL_NOC		31	/*HSIOL_NOC Domain */
+
+#define RST_REQ_PPNOC	0x80
+#define RST_STAT_PPNOC	0x84
+
+#define BASEID_WDT_RST_EN	0x90
+#define RST_MISC_CTL	0x94
+
+#define SR_PMA_KR_LD_CEU_LD_INIT		BIT(12)
+#define SR_PMA_KR_LD_CEU_LD_PRST		BIT(13)
+#define SR_PMA_KR_LD_CESTS_LD_RR		BIT(15)
+
+#define SR_PMA_KR_LP_CEU_LP_INIT		BIT(12)
+#define SR_PMA_KR_LP_CEU_LP_PRST		BIT(13)
+#define SR_PMA_KR_LP_CESTS_LP_RR		BIT(15)
+
+#define SR_AN_STS_LP_AN_ABL		BIT(0)
+#define SR_AN_STS_LP_AN_LS		BIT(2)
+#define SR_AN_STS_LD_AN_ABL		BIT(3)
+#define SR_AN_STS_LD_AN_RF	 	BIT(4)
+#define SR_AN_STS_LD_ANC	 	BIT(5)
+#define SR_AN_STS_LD_PR		 	BIT(6)
+#define SR_AN_STS_LD_EXT_NP_STS	 	BIT(7)
+#define SR_AN_STS_LD_PDF	 	BIT(9)
+
+#define SR_PMA_KR_PMD_STS_RCV_STS		BIT(0)
+#define SR_PMA_KR_PMD_STS_FRM_LCK		BIT(1)
+#define SR_PMA_KR_PMD_STS_SU_PR_DTD		BIT(2)
+#define SR_PMA_KR_PMD_STS_TR_FAIL		BIT(3)
+
+#define VR_AN_INTR_AN_INT_CMPLT 	BIT(0)
+#define VR_AN_INTR_AN_INC_LINK		BIT(1)
+#define VR_AN_INTR_AN_PG_RCV		BIT(2)
+
+#define MPLLA_STATE	BIT(13) /*MPLLA */
+#define MPLLB_STATE	BIT(14) /*MPLLB */
+
+#define TX_EQ_MAX TX_10G_SHORT+1
+#define RX_EQ_MAX RX_10G_SHORT+1
+#define PON_MODE_MAX GPON_ASYM+1 /*define up to GPON_ASYM for now */
+
+/* Shift first, then mask, usually for write operation */
+#define SM(_v, _f)		(((_v) << _f##_S) & (_f))
+
+/* Mask first , then shift, usually for read operation */
+#define MS(_v, _f)		(((_v) & (_f)) >> _f##_S)
+enum {
+	COMBO_PORT10 = 0,
+	COMBO_PORT11,
+	COMBO_PORT20,
+	COMBO_PORT21,
+	PON_WAN_PORT4,
+	P34X_PORT5,
+	COMBO_PORT30,  
+	COMBO_PORT31,
+	COMBO_PORT40,
+	COMBO_PORT41,
+	COMBO_PORT_MAX,
+};
+
+/*For combophy mode */
+enum{
+	RXAUI = 2,
+	DUAL_ETH,
+};
+
+/*For PON SHELL Mode */
+enum{
+	PON_MODE = 0,
+	WAN_MODE,
+};
+/*Default '0' for XGSPON and NGPON. 1 = 10G EPON. 2 = Turbo EPON/GPON/NGPON2 asym. 3 = EPON */
+
+enum{
+	XGSPON_SYM = 0,
+	XGSPON_ASYM,
+	EPON_10G_SYM,
+	EPON_10G_ASYM,
+	GPON_SYM,
+	GPON_ASYM,
+	TURBO_EPON,
+	EPON,
+};
+
+enum{
+	SYNCE = 0,
+	LOOP,
+};
+
+enum{
+	LANE0 = 0,
+	LANE1,
+};
+
+enum{
+	BIT8 = 0,
+	BIT10,
+	BIT16,
+	BIT20,
+};
+
+/* The structure will store mapping address to support multiple RC */
+struct combo_addr_map{
+	u32 phy_app_base;
+	u32 phy_cr_base;
+};
+
+struct combo_port {
+	struct combo_addr_map port_to_addr;
+};
+
+enum{
+	TX_PRST_0 = 0,
+	TX_PRST_1,
+	TX_PRST_2,
+	TX_PRST_3,
+	TX_PRST_4,
+	TX_PRST_5,
+	TX_PRST_6,
+	TX_PRST_7,
+	TX_PRST_8,
+	TX_PRST_9,
+	TX_PRST_10,
+	TX_2P5G_CUSTOM,
+	TX_1G_CUSTOM,
+	TX_10G_SHORT,
+};
+
+enum{
+	RX_16G = 0,
+	RX_10G,
+	RX_6P25G,
+	RX_5G,
+	RX_2P5G,
+	RX_1G,
+	RX_10G_SHORT,
+};
+
+enum{
+	SR0_PCIE10_RST,
+	SR1_PCIE11_RST,
+	SR2_PCIE20_RST,
+	SR3_PCIE21_RST,
+	SR4_PCIE30_RST,
+	SR5_PCIE31_RST,
+	SR6_PCIE40_RST,
+	SR7_PCIE41_RST,
+	SR8_TX_DISABLE_1,
+	SR9_TX_DISABLE_2,
+	SR10_TX_DISABLE_3,
+	SR11_TX_DISABLE_4,
+};
+
+struct tx_eq {
+	u32 id;
+	u32 tx_main_cursor;
+	u32 tx_pre_cursor;
+	u32 tx_post_cursor;
+	u32 tx_iboost_lvl;
+	u32 tx_vboost_en;
+	u32 tx_vboost_lvl;
+};
+
+struct rx_eq {
+	u32 id;
+	u32 rx_att_lvl;
+	u32 rx_vga1_gain;
+	u32 rx_vga2_gain;
+	u32 rx_ctle_pole;
+	u32 rx_ctle_boost;
+	u32 rx_dfe_tap1;
+	u32 rx_dfe_bypass;
+	u32 rx_adapt_mode;
+	u32 rx_adapt_sel;
+	u32 rx_vco_temp_comp_en;
+	u32 rx_vco_step_ctrl;
+	u32 rx_vco_frqband;
+	u32 rx_misc;
+	u32 rx_delta_iq;
+	u32 rx_margin_iq;
+	u32 rx_los_threshold;
+};
+
+struct serdes_config {
+	int cr_para_clk_div2_en;
+	int rx_cdr_ssc_en;
+	int rx_term_acdc;
+	u32 tx_rate;
+	u32 rx_rate;
+	int ref_clk_mplla_div2_en;
+	int ref_clk_div2_en;
+	u32 ref_range;
+	u32 mplla_bandwidth;
+	int mplla_tx_clk_div;
+	int mplla_div10_clk_en;
+	int mplla_div16p5_clk_en;
+	int mplla_div8_clk_en;
+	int mplla_div_clk_en;
+	u32 mplla_div_multiplier;
+	u32 mplla_multiplier;
+	u32 rx_vco_ld_val;
+	u32 rx_ref_ld_val;
+	u32 rx_vref_ctrl;
+	u32 ref_repeat_clk_en;
+	u32 sup_misc;
+	u32 tx_width;
+	int tx_mpll_en;
+	int tx_mpllb_sel;
+	int tx_clk_rdy;
+	u32 rx_width;
+	int rx_term_en;
+	int rx_div16p5_clk_en;
+	int rx_adapt_cont;
+	int rx_offcan_count;
+	int rx_adapt_in_prog;
+	int rx_cdr_ppm_max;
+	u32 bs_rx_lvl;
+	int bs_rx_bigswing;
+	int bs_tx_lowswing;
+	struct tx_eq *tx_prst;
+	struct rx_eq *rx_prst;
+};
+/************************************************************ */
+/* All HSIO Combo PHY Serdes Related Registers */
+/************************************************************ */
+#ifdef CONFIG_LGMC_SGMII
+#define HSIO1_CB0PHY0_CR		0xd0a00000
+#define HSIO1_CB0PHY1_CR		0xd0b00000
+#define HSIO3_CB1PHY0_CR		0xd0c00000
+#define HSIO3_CB1PHY1_CR		0xd0d00000
+#define HSIO2_CB2PHY0_CR		0xc0a00000
+#define HSIO2_CB2PHY1_CR		0xc0b00000
+#define HSIO4_CB3PHY0_CR		0xc0c00000
+#define HSIO4_CB3PHY1_CR		0xc0d00000
+
+#define HSIO1_CB0PHY0_CR_SIZE		0x40000
+#define HSIO1_CB0PHY1_CR_SIZE		0x40000
+#define HSIO3_CB1PHY0_CR_SIZE		0x40000
+#define HSIO3_CB1PHY1_CR_SIZE		0x40000
+#define HSIO2_CB2PHY0_CR_SIZE		0x40000
+#define HSIO2_CB2PHY1_CR_SIZE		0x40000
+#define HSIO4_CB3PHY0_CR_SIZE		0x40000
+#define HSIO4_CB3PHY1_CR_SIZE		0x40000
+
+#define HSIO1_CB0PHY0_APP		0xd0a40000
+#define HSIO1_CB0PHY1_APP		0xd0b40000
+#define HSIO3_CB1PHY0_APP		0xd0c40000
+#define HSIO3_CB1PHY1_APP		0xd0d40000
+#define HSIO2_CB2PHY0_APP		0xc0a40000
+#define HSIO2_CB2PHY1_APP		0xc0b40000
+#define HSIO4_CB3PHY0_APP		0xc0c40000
+#define HSIO4_CB3PHY1_APP		0xc0d40000
+
+#define HSIO1_CB0PHY0_APP_SIZE		0x1000
+#define HSIO1_CB0PHY1_APP_SIZE		0x1000
+#define HSIO3_CB1PHY0_APP_SIZE		0x1000
+#define HSIO3_CB1PHY1_APP_SIZE		0x1000
+#define HSIO2_CB2PHY0_APP_SIZE		0x1000
+#define HSIO2_CB2PHY1_APP_SIZE		0x1000
+#define HSIO4_CB3PHY0_APP_SIZE		0x1000
+#define HSIO4_CB3PHY1_APP_SIZE		0x1000
+
+#define APP_XPCS_CTRL			0x130
+#define PCIE_PHY_SRAM_CSR		0x8
+#endif
+/************************************************************ */
+/* Combo PHY Serdes Related Registers */
+/************************************************************ */
+#define COMBO_HSIOL_PHY10_CR_BASE					0xD0A00000UL
+#define COMBO_HSIOL_PHY11_CR_BASE					0xD0B00000UL
+#define COMBO_HSIOR_PHY20_CR_BASE					0xC0A00000UL
+#define COMBO_HSIOR_PHY21_CR_BASE					0xC0B00000UL
+#define PON_WAN_PHY_CR_BASE							0xE7800000UL /*Confirmed Simulation team verified. LSD HTML show PON and WAN Serdes difference base address. */
+/*#define PON_WAN_PHY_CR_BASE						0xE7900000UL //NOC Design does not have 0xE790 0000. Datasheet inaccuracy. */
+/*#define PHY5_CR_BASE								0xE7A00000UL //NOC Design does not have 0xE7A0 0000. Datasheet inaccuracy. */
+
+#define COMBO_HSIOL_PHY10_APP_BASE					0xD0A40000UL
+#define COMBO_HSIOL_PHY11_APP_BASE					0xD0B40000UL
+#define COMBO_HSIOR_PHY20_APP_BASE					0xC0A40000UL
+#define COMBO_HSIOR_PHY21_APP_BASE					0xC0B40000UL
+#define PON_WAN_PHY_APP_BASE						0xE7840000UL /*Need to confirm. LSD HTML show PON and WAN Serdes difference base address. */
+#define PHY5_APP_BASE								0xE7A40000UL /*Need to confirm. NOC Design does not have 0xE7A0 0000 */
+#define PON_IP_SHELL_APB_APP						0xE7843000UL /* To set APB APP Timeout */
+
+#define HSIOR_TOP_BASE								0xE0080000UL
+#define HSIOL_TOP_BASE								0xE00A0000UL
+
+#define ETHSATA_COMBOPHY_MODE						0x0 	/*offset */
+#define ETHSATA_COMBOPHY_MODE_POS					0
+#define ETHSATA_COMBOPHY_MODE_WIDTH					0x3
+
+#ifdef CONFIG_LGMC_SGMII
+#define GEN3_COMBOPHY_MODE						0x200 	/*offset */
+#define GEN3_COMBOPHY_MODE_POS					0
+#define GEN3_COMBOPHY_MODE_WIDTH					0x3
+#endif
+
+#define ETHSATA_PCS0_STAT							0x110
+#define ETHSATA_PCS0_STAT_LINK_STATUS_POS			0
+#define ETHSATA_PCS0_STAT_LINK_STATUS_WIDTH			1
+
+#define ETHSATA_PCS1_STAT							0x114
+#define ETHSATA_PCS1_STAT_LINK_STATUS_POS			0
+#define ETHSATA_PCS1_STAT_LINK_STATUS_WIDTH			1
+
+#define ETHSATA_CLK_DIS_REG							0x124
+
+#define ETHSATA_CLK_DIS_REG_PCIE0_CLK_DIS_POS		0		/*Default 1. Set 0 to enable clock. */
+#define ETHSATA_CLK_DIS_REG_PCIE0_CLK_DIS_WIDTH		1
+
+#define ETHSATA_CLK_DIS_REG_PCIE1_CLK_DIS_POS		1
+#define ETHSATA_CLK_DIS_REG_PCIE1_CLK_DIS_WIDTH		1
+
+#define ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS		2
+#define ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH		1
+
+#define ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS		3
+#define ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH		1
+
+#define ETHSATA_CLK_DIS_REG_STAT0_CLK_DIS_POS		4
+#define ETHSATA_CLK_DIS_REG_SATA0_CLK_DIS_WIDTH		1
+
+#define ETHSATA_CLK_DIS_REG_SATA1_CLK_DIS_POS		5
+#define ETHSATA_CLK_DIS_REG_SATA1_CLK_DIS_WIDTH		1
+
+#define GEN3_CLK_DIS_REG								0x324
+
+#define	XPCS0_XGMII_CLK_CTR	0x0130
+#define	XPCS1_XGMII_CLK_CTR	0x0134
+#define HSIO_TOP_XGMII_CLK_EN	0x1
+
+#define SUP_DIG_REFCLK_OVRD_IN(X)						(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x2 << 2))
+#define SUP_DIG_MPLLA_OVRD_IN_0(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x4 << 2))
+#define SUP_DIG_MPLLA_OVRD_IN_1(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x5 << 2))
+#define SUP_DIG_MPLLA_OVRD_IN_2(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x6 << 2))
+#define SUP_DIG_MPLLA_OVRD_IN_3(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x7 << 2))
+#define SUP_DIG_MPLLA_OVRD_IN_4(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x8 << 2))
+#define SUP_DIG_MPLLB_OVRD_IN_0(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x9 << 2))
+#define SUP_DIG_MPLLB_OVRD_IN_1(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0xa << 2))
+#define SUP_DIG_MPLLB_OVRD_IN_2(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0xb << 2))
+#define SUP_DIG_MPLLB_OVRD_IN_3(X)	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0xc << 2))
+#define SUP_DIG_MPLLB_OVRD_IN_4(X) 	    				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0xd << 2))
+#define SUP_DIG_LVL_OVRD_IN(X) 	        				(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x12 << 2))
+#define SUP_DIG_LVL_OVRD_IN_OFFSET						(0x12)
+#define SUP_DIG_MPLLA_ASIC_IN_0(X) 	        			(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x14 << 2))
+#define SUP_DIG_MPLLA_ASIC_IN_1(X) 	        			(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x15 << 2))
+#define SUP_DIG_MPLLA_ASIC_IN_2(X) 	        			(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x16 << 2))
+
+#define SUP_DIG_ASIC_IN(X)								(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x1b << 2))
+#define SUP_DIG_ASIC_IN_OFFSET							(0x1b)
+#define SUP_DIG_LVL_ASIC_IN(X)							(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x1c << 2))
+#define SUP_DIG_LVL_ASIC_IN_OFFSET						(0x1c)
+
+#define LANEN_DIG_ASIC_LANE_OVRD_IN(X,Y)				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1000 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_LANE_OVRD_IN_OFFSET(Y)			(0x1000 + (Y*0x100))
+#define LANEN_DIG_ASIC_TX_OVRD_IN_0(X,Y) 	    		(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1001 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_TX_OVRD_IN_1(X,Y) 	    		(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1002 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_TX_OVRD_IN_1_OFFSET(Y) 	    	(0x1002 + (Y*0x100))
+#define LANEN_DIG_ASIC_TX_OVRD_IN_2(X,Y) 	    		(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1003 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_TX_OVRD_IN_2_OFFSET(Y) 	    	(0x1003 + (Y*0x100))
+#define LANEN_DIG_ASIC_RX_OVRD_IN_0(X,Y) 	    		(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1005 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_OVRD_IN_1(X,Y) 	    		(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1006 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_OVRD_IN_2(X,Y) 	    		(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1007 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_OVRD_IN_3(X,Y) 	    		(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1008 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_OVRD_EQ_IN_0(X,Y) 			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1009 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_OVRD_EQ_IN_0_OFFSET(Y)		(0x1009 + (Y*0x100))
+#define LANEN_DIG_ASIC_RX_OVRD_EQ_IN_1(X,Y) 			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x100a + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_OVRD_EQ_IN_1_OFFSET(Y)		(0x100a + (Y*0x100))
+#define LANEN_DIG_ASIC_TX_ASIC_IN_0(X,Y) 				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x100d + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_TX_ASIC_IN_1(X,Y) 				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x100e + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_TX_ASIC_IN_1_OFFSET(Y)	 		(0x100e + (Y*0x100))
+#define LANEN_DIG_ASIC_TX_ASIC_IN_2(X,Y) 				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x100f + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_TX_ASIC_IN_2_OFFSET(Y)	 		(0x100f + (Y*0x100))
+#define LANEN_DIG_ASIC_RX_ASIC_IN_0(X,Y)				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1011 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_ASIC_IN_0_OFFSET(Y)			(0x1011 + (Y*0x100))
+#define LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(X,Y)				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1013 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(Y)		(0x1013 + (Y*0x100))
+#define LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(X,Y)				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1014 + (Y*0x100)) << 2))
+#define LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(Y)		(0x1014 + (Y*0x100))
+#define LANEN_DIG_ASIC_RX_ASIC_OUT_0(X,Y) 				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1017 + (Y*0x100)) << 2))
+#define LANEN_DIG_RX_DLL_FREQ(X,Y) 						(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x1059 + (Y*0x100)) << 2))
+#define LANEN_DIG_TX_LBERT_CTL(X,Y)						(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x102b + (Y*0x100)) << 2))
+#define LANEN_DIG_TX_LBERT_CTL_OFFSET(Y)				(0x102b + (Y*0x100))
+
+#define LANEN_DIG_RX_ADPTCTL_ATT_STATUS(X,Y)			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x106b + (Y*0x100)) << 2))
+#define LANEN_DIG_RX_ADPTCTL_VGA_STATUS(X,Y)			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x106c + (Y*0x100)) << 2))
+#define LANEN_DIG_RX_ADPTCTL_CTLE_STATUS(X,Y)			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x106d + (Y*0x100)) << 2))
+#define LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS(X,Y)		(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x106e + (Y*0x100)) << 2))
+#define LANEN_DIG_RX_ADPTCTL_ATT_STATUS_OFFSET(Y)		(0x106b + (Y*0x100))
+#define LANEN_DIG_RX_ADPTCTL_VGA_STATUS_OFFSET(Y)		(0x106c + (Y*0x100))
+#define LANEN_DIG_RX_ADPTCTL_CTLE_STATUS_OFFSET(Y)		(0x106d + (Y*0x100))
+#define LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS_OFFSET(Y)	(0x106e + (Y*0x100))
+
+#define RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(X,Y)			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x3008 + (Y*0x100)) << 2)) /*BIT5 ADAPT_REQ_OVRD_EN, BIT4 ADAPT_REQ */
+#define RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(Y)		(0x3008 + (Y*0x100))
+#define RAWLANEN_DIG_PCS_XF_RX_ADAPT_ACK(X,Y)			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x3010 + (Y*0x100)) << 2)) /*BIT0 RX_ADAPT_ACK */
+#define RAWLANEN_DIG_PCS_XF_RX_ADAPT_ACK_OFFSET(Y)		(0x3010 + (Y*0x100))
+#define RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN(X,Y)			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x3016 + (Y*0x100)) << 2))
+#define RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_OFFSET(Y)		(0x3016 + (Y*0x100))
+#define RAWLANEN_DIG_PCS_XF_RX_OVRD_IN_5(X,Y)			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x3019 + (Y*0x100)) << 2))
+#define RAWLANEN_DIG_PCS_XF_RX_OVRD_IN_5_OFFSET(Y)		(0x3019 + (Y*0x100))
+#define RAWLANEN_DIG_PCS_XF_RX_PCS_IN_5(X,Y)			(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x301a + (Y*0x100)) << 2))
+#define RAWLANEN_DIG_PCS_XF_RX_PCS_IN_5_OFFSET(Y)		(0x301a + (Y*0x100))
+
+#define RAWCMN_DIG_AON_SRAM_OVRD_IN(X)					(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x203c << 2))
+#define RAWCMN_DIG_AON_SRAM_IN(X)						(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x203d << 2))
+#define RAWCMN_DIG_AON_SRAM_OUT(X)						(COMBO_PHY_CR_PORT_TO_BASE(X) + (0x203e << 2))
+
+/************************************************************ */
+/* COMBO, WAN, XPCS5 Related Registers */
+/************************************************************ */
+
+#define COMBO_PHY_PORT_TO_BASE(X)	(g_combo_port_defs[(X)].port_to_addr.phy_app_base)
+#define COMBO_PHY_CR_PORT_TO_BASE(X)	(g_combo_port_defs[(X)].port_to_addr.phy_cr_base)
+
+/* COMBO/WAN/XPCS5 PDI PHY register definition */
+#define COMBO_PHY_GEN_CTRL(X)		(COMBO_PHY_PORT_TO_BASE(X) + 0x00)
+#define COMBO_PHY_MPLLA_CTRL(X)		(COMBO_PHY_PORT_TO_BASE(X) + 0x10)
+#define COMBO_PHY_MPLLB_CTRL(X)		(COMBO_PHY_PORT_TO_BASE(X) + 0x14)
+/*#define COMBO_PHY_GEN_CTRL(X)		(COMBO_PHY_CR_BASE(X) + 0x00) */
+/*#define COMBO_PHY_MPLLA_CTRL(X)		(COMBO_PHY_CR_BASE(X) + 0x10) */
+/*#define COMBO_PHY_MPLLB_CTRL(X)		(COMBO_PHY_CR_BASE(X) + 0x14) */
+
+/************************************************************ */
+/* COMBO and WAN PHY Mode */
+/************************************************************ */
+#define IFMUX_CFG_LOCAL					0xb6180120
+#define COMBOPHY_PCIE_SINGLE_LANE		0
+#define COMBOPHY_PCIE_DUAL_LANE			1
+#define COMBOPHY_DUAL_XFI_SINGLE_LANE	3
+#define WANPHY_PON_MODE					0
+#define WANPHY_ETH_MODE					1
+
+/************************************************************ */
+/* PON SHELL APP Register */
+/************************************************************ */
+
+/*PON Shell Register Defines */
+/*------------------------------------------------- */
+#define PON_SHELL_GEN_CTRL 					0x0
+#define TX_RESET_POS 						0
+#define TX_RESET_WIDTH 						1
+#define RX_RESET_POS 						1
+#define RX_RESET_WIDTH 						1
+#define CR_PARA_CLK_DIV2_EN_POS 			2
+#define CR_PARA_CLK_DIV2_EN_WIDTH 			1
+#define INTNODE_RST_N_POS 					3
+#define INTNODE_RST_N_WIDTH 				1
+#define PON_RST_N_POS 						4
+#define PON_RST_N_WIDTH 					1
+#define PHY_RST_N_POS 						5
+#define PHY_RST_N_WIDTH 					1
+#define XPCS_RST_N_POS 						6
+#define XPCS_RST_N_WIDTH 					1
+#define RX_CDR_SSC_EN_POS 					8
+#define RX_CDR_SSC_EN_WIDTH 				1
+#define RX_REQ_POS 							9
+#define RX_REQ_WIDTH 						1
+#define RX_TERM_ACDC_POS 					10
+#define RX_TERM_ACDC_WIDTH 					1
+#define AON_CLK_GATE_POS 					11
+#define AON_CLK_GATE_WIDTH 					1
+#define PON_CLK_GATE_POS 					12
+#define PON_CLK_GATE_WIDTH 					1
+#define CR_PARA_CLK_GATE_POS 				13
+#define CR_PARA_CLK_GATE_WIDTH 				1
+#define REF_CLK_EN_POS 						16
+#define REF_CLK_EN_WIDTH 					1
+#define TX_RATE_POS 						18
+#define TX_RATE_WIDTH 						3
+#define RX_RATE_POS 						21
+#define RX_RATE_WIDTH 						2
+#define PHY_RTUNE_REQ_POS 					24
+#define PHY_RTUNE_REQ_WIDTH 				1
+#define PHY_RTUNE_ACK_POS 					25
+#define PHY_RTUNE_ACK_WIDTH 				1
+#define RX_DATA_EN_POS 						26
+#define RX_DATA_EN_WIDTH 					1
+#define TX_REQ_POS 							27
+#define TX_REQ_WIDTH 						1
+#define RX_ACK_POS 							28
+#define RX_ACK_WIDTH 						1
+#define TX_ACK_POS 							29
+#define TX_ACK_WIDTH 						1
+#define REF_CLK_REQ_POS 					30
+#define REF_CLK_REQ_WIDTH 					1
+#define PON_LS_POS 							31
+#define PON_LS_WIDTH 						1
+
+/*------------------------------------------------- */
+#define PON_SHELL_LPBK_CTRL 				0x4
+#define TX2RX_LOOPBK_POS 					0
+#define TX2RX_LOOPBK_WIDTH 					1
+#define RX2TX_PAR_LB_EN_POS 				1
+#define RX2TX_PAR_LB_EN_WIDTH 				1
+
+/*------------------------------------------------- */
+#define PON_SHELL_SRAM_CSR 					0x8
+#define SRAM_BYPASS_POS						0
+#define SRAM_BYPASS_WIDTH					1
+#define SRAM_EXT_LD_DONE_POS				1
+#define SRAM_EXT_LD_DONE_WIDTH				1
+#define SRAM_INIT_DONE_POS					2
+#define SRAM_INIT_DONE_WIDTH				1
+
+/*------------------------------------------------- */
+#define PON_SHELL_MPLLA_CTRL 				0xC
+#define MPLLA_FORCE_EN_POS					0
+#define MPLLA_FORCE_EN_WIDTH				1
+#define MPLLA_SSC_EN_POS					1
+#define MPLLA_SSC_EN_WIDTH					1
+#define MPLLA_FORCE_ACK_POS					2
+#define MPLLA_FORCE_ACK_WIDTH				1
+#define MPLLA_STATE_POS 					31
+#define MPLLA_STATE_WIDTH 					1
+
+/*------------------------------------------------- */
+#define PON_SHELL_MPLLB_CTRL 				0x10
+#define MPLLB_FORCE_EN_POS					0
+#define MPLLB_FORCE_EN_WIDTH				1
+#define MPLLB_SSC_EN_POS					1
+#define MPLLB_SSC_EN_WIDTH					1
+#define MPLLB_FORCE_ACK_POS					2
+#define MPLLB_FORCE_ACK_WIDTH				1
+#define MPLLB_STATE_POS 					31
+#define MPLLB_STATE_WIDTH 					1
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_CTRL_SEL 				0x14
+#define EXT_PHY_CTRL_SEL_POS 				0
+#define EXT_PHY_CTRL_SEL_WIDTH 				1
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_BS_CTRL 				0x18
+#define EXT_BS_RX_LEVEL_POS 				0
+#define EXT_BS_RX_LEVEL_WIDTH 				5
+#define EXT_BS_RX_BIGSWING_POS 				5
+#define EXT_BS_RX_BIGSWING_WIDTH 			1
+#define EXT_BS_TX_LOWSWING_POS 				6
+#define EXT_BS_TX_LOWSWING_WIDTH 			1
+
+/*------------------------------------------------- */
+#define PON_SHELL_REF_CLK_CTRL 				0x1C
+#define REF_CLK_MPLLA_DIV2_EN_POS 			0
+#define REF_CLK_MPLLA_DIV2_EN_WIDTH 		1
+#define REF_CLK_MPLLB_DIV2_EN_POS 			1
+#define REF_CLK_MPLLB_DIV2_EN_WIDTH 		1
+#define REF_CLK_DIV2_EN_POS 				2
+#define REF_CLK_DIV2_EN_WIDTH 				1
+#define REF_RANGE_POS 						3
+#define REF_RANGE_WIDTH 					3
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MPLLA_CTRL_0 			0x20
+#define EXT_MPLLA_BANDWIDTH_POS 			0
+#define EXT_MPLLA_BANDWIDTH_WIDTH 			16
+#define EXT_MPLLA_INIT_CAL_DISABLE_POS 		16
+#define EXT_MPLLA_INIT_CAL_DISABLE_WIDTH 	1
+#define EXT_MPLLA_TX_CLK_DIV_POS 			17
+#define EXT_MPLLA_TX_CLK_DIV_WIDTH 			2
+#define EXT_MPLLA_RECAL_BANK_SEL_POS 		19
+#define EXT_MPLLA_RECAL_BANK_SEL_WIDTH 		2
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MPLLA_CTRL_1 			0x24
+#define EXT_MPLLA_DIV10_CLK_EN_POS 			8
+#define EXT_MPLLA_DIV10_CLK_EN_WIDTH 		1
+#define EXT_MPLLA_DIV16P5_CLK_EN_POS 		9
+#define EXT_MPLLA_DIV16P5_CLK_EN_WIDTH 		1
+#define EXT_MPLLA_DIV8_CLK_EN_POS 			10
+#define EXT_MPLLA_DIV8_CLK_EN_WIDTH 		1
+#define EXT_MPLLA_DIV_CLK_EN_POS 			11
+#define EXT_MPLLA_DIV_CLK_EN_WIDTH 			1
+#define EXT_MPLL_SSC_UP_SPREAD_POS 			12
+#define EXT_MPLL_SSC_UP_SPREAD_WIDTH 		1
+#define EXT_MPLLA_DIV_MULTIPLIER_POS 		16
+#define EXT_MPLLA_DIV_MULTIPLIER_WIDTH 		7
+#define EXT_MPLLA_MULTIPLIER_POS 			24
+#define EXT_MPLLA_MULTIPLIER_WIDTH 			8
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MPLLA_CTRL_2 			0x28
+#define EXT_MPLLA_FRACN_CTRL_POS			0
+#define EXT_MPLLA_FRACN_CTRL_WIDTH			11
+#define EXT_MPLLA_SSC_CLK_SEL_POS			11
+#define EXT_MPLLA_SSC_CLK_SEL_WIDTH			1
+#define EXT_MPLLA_SSC_FREQ_CNT_INIT_POS		12
+#define EXT_MPLLA_SSC_FREQ_CNT_INIT_WIDTH	12
+#define EXT_MPLLA_SSC_FRQ_CNT_PEAK_POS		24
+#define EXT_MPLLA_SSC_FRQ_CNT_PEAK_WIDTH	8
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MPLLB_CTRL_0 			0x2C
+#define EXT_MPLLB_BANDWIDTH_POS 			0
+#define EXT_MPLLB_BANDWIDTH_WIDTH 			16
+#define EXT_MPLLB_INIT_CAL_DISABLE_POS 		16
+#define EXT_MPLLB_INIT_CAL_DISABLE_WIDTH 	1
+#define EXT_MPLLB_TX_CLK_DIV_POS 			17
+#define EXT_MPLLB_TX_CLK_DIV_WIDTH 			2
+#define EXT_MPLLB_RECAL_BANK_SEL_POS 		19
+#define EXT_MPLLB_RECAL_BANK_SEL_WIDTH 		2
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MPLLB_CTRL_1 			0x30
+#define EXT_MPLLB_DIV10_CLK_EN_POS 			8
+#define EXT_MPLLB_DIV10_CLK_EN_WIDTH 		1
+#define EXT_MPLLB_DIV16P5_CLK_EN_POS 		9
+#define EXT_MPLLB_DIV16P5_CLK_EN_WIDTH 		1
+#define EXT_MPLLB_DIV8_CLK_EN_POS 			10
+#define EXT_MPLLB_DIV8_CLK_EN_WIDTH 		1
+#define EXT_MPLLB_DIV_CLK_EN_POS 			11
+#define EXT_MPLLB_DIV_CLK_EN_WIDTH 			1
+#define EXT_MPLL_SSC_UP_SPREAD_POS 			12
+#define EXT_MPLL_SSC_UP_SPREAD_WIDTH 		1
+#define EXT_MPLLB_DIV_MULTIPLIER_POS 		16
+#define EXT_MPLLB_DIV_MULTIPLIER_WIDTH 		7
+#define EXT_MPLLB_MULTIPLIER_POS 			24
+#define EXT_MPLLB_MULTIPLIER_WIDTH 			8
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MPLLB_CTRL_2			0x34
+#define EXT_MPLLB_FRACN_CTRL_POS			0
+#define EXT_MPLLB_FRACN_CTRL_WIDTH			11
+#define EXT_MPLLB_SSC_CLK_SEL_POS			11
+#define EXT_MPLLB_SSC_CLK_SEL_WIDTH			1
+#define EXT_MPLLB_SSC_FREQ_CNT_INIT_POS		12
+#define EXT_MPLLB_SSC_FREQ_CNT_INIT_WIDTH	12
+#define EXT_MPLLB_SSC_FRQ_CNT_PEAK_POS		24
+#define EXT_MPLLB_SSC_FRQ_CNT_PEAK_WIDTH	8
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_EQ_CTRL_1 			0x38
+#define EXT_RX_EQ_ATT_LVL_G1_POS			2
+#define EXT_RX_EQ_ATT_LVL_G1_WIDTH			3
+#define EXT_RX_EQ_CTLE_BOOST_G1_POS			8
+#define EXT_RX_EQ_CTLE_BOOST_G1_WIDTH		5
+#define EXT_RX_EQ_CTLE_POLE_G1_POS			13
+#define EXT_RX_EQ_CTLE_POLE_G1_WIDTH		2
+#define EXT_RX_EQ_DFE_TAP1_G1_POS			16
+#define EXT_RX_EQ_DFE_TAP1_G1_WIDTH			8
+#define EXT_RX_EQ_VGA1_GAIN_G1_POS			24
+#define EXT_RX_EQ_VGA1_GAIN_G1_WIDTH		3
+#define EXT_RX_EQ_VGA2_GAIN_G1_POS			28
+#define EXT_RX_EQ_VGA2_GAIN_G1_WIDTH		3
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_CALI_CTRL_1 			0x3C
+#define EXT_RX_VCO_LD_VAL_G1_POS			0
+#define EXT_RX_VCO_LD_VAL_G1_WIDTH			13
+#define EXT_RX_REF_LD_VAL_G1_POS			16
+#define EXT_RX_REF_LD_VAL_G1_WIDTH			7
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MISC_CTRL0 			0x40
+#define EXT_RX_LOS_LFPS_EN_POS				0
+#define EXT_RX_LOS_LFPS_EN_WIDTH			1
+#define EXT_RX_LOS_THRESHOLD_POS			1
+#define EXT_RX_LOS_THRESHOLD_WIDTH			3
+#define EXT_TX_IBOOST_LVL_POS				4
+#define EXT_TX_IBOOST_LVL_WIDTH				4
+#define EXT_RX_VREF_CTRL_POS				8
+#define EXT_RX_VREF_CTRL_WIDTH				5
+#define EXT_VPH_NOMINAL_POS					13
+#define EXT_VPH_NOMINAL_WIDTH				2
+#define EXT_TX_VBOOST_LVL_POS				16
+#define EXT_TX_VBOOST_LVL_WIDTH				3
+#define EXT_REF_REPEAT_CLK_EN_POS			19
+#define EXT_REF_REPEAT_CLK_EN_WIDTH			1
+#define EXT_SUP_MISC_POS					20
+#define EXT_SUP_MISC_WIDTH					8
+#define EXT_REF_CLKDET_EN_POS				28
+#define EXT_REF_CLKDET_EN_WIDTH				1
+#define EXT_REF_CLKDET_RESULT_POS			29
+#define EXT_REF_CLKDET_RESULT_WIDTH			1
+#define EXT_TEST_FLYOVER_EN_POS				30
+#define EXT_TEST_FLYOVER_EN_WIDTH			1
+#define EXT_TEST_STOP_CLK_EN_POS			31
+#define EXT_TEST_STOP_CLK_EN_WIDTH			1
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MISC_CTRL1 			0x44
+#define EXT_TX_LPD_POS						0
+#define EXT_TX_LPD_WIDTH					1
+#define EXT_TX_WIDTH_POS					1
+#define EXT_TX_WIDTH_WIDTH					2
+#define EXT_TX_VBOOST_EN_POS				3
+#define EXT_TX_VBOOST_EN_WIDTH				1
+#define EXT_TX_MPLL_EN_POS					4
+#define EXT_TX_MPLL_EN_WIDTH				1
+#define EXT_TX_MPLLB_SEL_POS				5
+#define EXT_TX_MPLLB_SEL_WIDTH				1
+#define EXT_TX_INVERT_POS					6
+#define EXT_TX_INVERT_WIDTH					1
+#define TX_BEACON_EN_POS					7
+#define TX_BEACON_EN_WIDTH					1
+#define TX_DISABLE_POS						8
+#define TX_DISABLE_WIDTH					1
+#define EXT_TX_CLK_RDY_POS					9
+#define EXT_TX_CLK_RDY_WIDTH				1
+#define EXT_TX_PSTATE_POS					10
+#define EXT_TX_PSTATE_WIDTH					2
+#define EXT_TX_DETRX_REQ_POS				12
+#define EXT_TX_DETRX_REQ_WIDTH				1
+#define EXT_TX_EQ_PRE_POS					13
+#define EXT_TX_EQ_PRE_WIDTH					6
+#define EXT_TX_EQ_MAIN_POS					19
+#define EXT_TX_EQ_MAIN_WIDTH				6
+#define EXT_TX_EQ_POST_POS					25
+#define EXT_TX_EQ_POST_WIDTH				6
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_MISC_CTRL2 			0x48
+#define EXT_RX_LPD_POS						0
+#define EXT_RX_LPD_WIDTH					1
+#define EXT_RX_WIDTH_POS					1
+#define EXT_RX_WIDTH_WIDTH					2
+#define EXT_RX_INVERT_POS					3
+#define EXT_RX_INVERT_WIDTH					1
+#define EXT_RX_TERM_EN_POS					4
+#define EXT_RX_TERM_EN_WIDTH				1
+#define EXT_RX_DISABLE_POS					5
+#define EXT_RX_DISABLE_WIDTH				1
+#define EXT_RX_PSTATE_POS					6
+#define EXT_RX_PSTATE_WIDTH					2
+#define EXT_RX_DIV16P5_CLK_EN_POS			8
+#define EXT_RX_DIV16P5_CLK_EN_WIDTH			1
+#define EXT_RX_ADAPT_CONT_POS				9
+#define EXT_RX_ADAPT_CONT_WIDTH				1
+#define EXT_RX_OFFCAN_COUNT_POS				10
+#define EXT_RX_OFFCAN_COUNT_WIDTH			1
+#define EXT_RX_ADAPT_REQ_POS				11
+#define EXT_RX_ADAPT_REQ_WIDTH				1
+#define EXT_ADAPT_RX_ACK_POS				12
+#define EXT_ADAPT_RX_ACK_WIDTH				1
+#define EXT_RX_MISC_POS						13
+#define EXT_RX_MISC_WIDTH					8
+#define EXT_RX_ADAPT_MODE_POS				21
+#define EXT_RX_ADAPT_MODE_WIDTH				2
+#define EXT_TX_MISC_POS						23
+#define EXT_TX_MISC_WIDTH					8
+#define EXT_RX_ADAPT_IN_PROG_POS			31
+#define EXT_RX_ADAPT_IN_PROG_WIDTH			1
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_CDR_CTRL 				0x4C
+#define EXT_RX_CDR_PPM_DRIFT_POS			0
+#define EXT_RX_CDR_PPM_DRIFT_WIDTH			6
+#define EXT_RX_CDR_PPM_DRIFT_VLD_POS		6
+#define EXT_RX_CDR_PPM_DRIFT_VLD_WIDTH		1
+#define EXT_RX_CDR_PPM_MAX_POS				7
+#define EXT_RX_CDR_PPM_MAX_WIDTH			5
+#define EXT_RX_DFE_BYPASS_POS				12
+#define EXT_RX_DFE_BYPASS_WIDTH				1
+#define EXT_RX_ADAPT_SEL_POS				13
+#define EXT_RX_ADAPT_SEL_WIDTH				1
+#define EXT_RX_CDR_VCO_FREQBAND_POS			14
+#define EXT_RX_CDR_VCO_FREQBAND_WIDTH		2
+#define EXT_RX_CDR_VCO_STEP_CTRL_POS		16
+#define EXT_RX_CDR_VCO_STEP_CTRL_WIDTH		1
+#define EXT_RX_CDR_VCO_TEMP_COMP_EN_POS		17
+#define EXT_RX_CDR_VCO_TEMP_COMP_EN_WIDTH	1
+#define EXT_RX_DELTA_IQ_POS					18
+#define EXT_RX_DELTA_IQ_WIDTH				4
+#define EXT_RX_MARGIN_IQ_POS				22
+#define EXT_RX_MARGIN_IQ_WIDTH				7
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_PG_CTRL 				0x50
+#define PON_SHELL_PG_RESET_POS				0
+#define PON_SHELL_PG_RESET_WIDTH			1
+#define PON_SHELL_PG_MODE_EN_POS			1
+#define PON_SHELL_PG_MODE_EN_WIDTH			1
+#define PON_SHELL_PMA_PWR_EN_POS			2
+#define PON_SHELL_PMA_PWR_EN_WIDTH			1
+#define PON_SHELL_PMA_PWR_STABLE_POS		3
+#define PON_SHELL_PMA_PWR_STABLE_WIDTH		1
+#define PON_SHELL_PCS_PWR_EN_POS			4
+#define PON_SHELL_PCS_PWR_EN_WIDTH			1
+#define PON_SHELL_PCS_PWR_STABLE_POS		5
+#define PON_SHELL_PCS_PWR_STABLE_WIDTH		1
+
+/*------------------------------------------------- */
+#define PON_SHELL_EXT_TERM_CTRL 				0x54
+#define PON_SHELL_EXT_TXUP_TERM_OFFSET_POS 		0
+#define PON_SHELL_EXT_TXUP_TERM_OFFSET_WIDTH	9
+#define PON_SHELL_EXT_TXDN_TERM_OFFSET_POS		9
+#define PON_SHELL_EXT_TXDN_TERM_OFFSET_WIDTH	9
+#define PON_SHELL_EXT_RX_TERM_OFFSET_POS		24
+#define PON_SHELL_EXT_RX_TERM_OFFSET_WIDTH		5
+
+/*------------------------------------------------- */
+#define PON_SHELL_MODE_SEL 					0x58
+#define PON_ETH_SEL_POS						0
+#define PON_ETH_SEL_WIDTH					1
+#define LOOP_SYNCE_SEL_POS					1
+#define LOOP_SYNCE_SEL_WIDTH				1
+#define PON_SHELL_REFCLK_EN_POS				2
+#define PON_SHELL_REFCLK_EN_WIDTH			1
+#define SEL_10GEPON_POS						3
+#define SEL_10GEPON_WIDTH					1
+
+/*------------------------------------------------- */
+#define PON_SHELL_LOOP_PLL_CFG0 			0x5C
+#define LOOP_PLL_CFG0_PLLEN_POS				0
+#define LOOP_PLL_CFG0_PLLEN_WIDTH			1
+#define LOOP_PLL_CFG0_LOCK_POS				1
+#define LOOP_PLL_CFG0_LOCK_WIDTH			1
+#define LOOP_PLL_CFG0_FRAC_POS				2
+#define LOOP_PLL_CFG0_FRAC_WIDTH			24
+#define LOOP_PLL_CFG0_DSMEN_POS				28
+#define LOOP_PLL_CFG0_DSMEN_WIDTH			1
+#define LOOP_PLL_CFG0_DACEN_POS				30
+#define LOOP_PLL_CFG0_DACEN_WIDTH			1
+
+/*------------------------------------------------- */
+#define PON_SHELL_LOOP_PLL_CFG1 			0x60
+#define LOOP_PLL_CFG1_POST_DIV0A_POS		0
+#define LOOP_PLL_CFG1_POST_DIV0A_WIDTH		3
+#define LOOP_PLL_CFG1_POST_DIV0B_POS		3
+#define LOOP_PLL_CFG1_POST_DIV0B_WIDTH		3
+#define LOOP_PLL_CFG1_POST_DIV1A_POS		6
+#define LOOP_PLL_CFG1_POST_DIV1A_WIDTH		3
+#define LOOP_PLL_CFG1_POST_DIV1B_POS		9
+#define LOOP_PLL_CFG1_POST_DIV1B_WIDTH		3
+#define LOOP_PLL_CFG1_POST_DIV2A_POS		12
+#define LOOP_PLL_CFG1_POST_DIV2A_WIDTH		3
+#define LOOP_PLL_CFG1_POST_DIV2B_POS		15
+#define LOOP_PLL_CFG1_POST_DIV2B_WIDTH		3
+#define LOOP_PLL_CFG1_FOUT0EN_POS			18
+#define LOOP_PLL_CFG1_FOUT0EN_WIDTH			1
+#define LOOP_PLL_CFG1_FOUT1EN_POS			19
+#define LOOP_PLL_CFG1_FOUT1EN_WIDTH			1
+#define LOOP_PLL_CFG1_FOUT2EN_POS			20
+#define LOOP_PLL_CFG1_FOUT2EN_WIDTH			1
+#define LOOP_PLL_CFG1_FOUT3EN_POS			21
+#define LOOP_PLL_CFG1_FOUT3EN_WIDTH			1
+#define LOOP_PLL_CFG1_POST_DIV3A_POS		22
+#define LOOP_PLL_CFG1_POST_DIV3A_WIDTH		3
+#define LOOP_PLL_CFG1_DIV3B_POS				25
+#define LOOP_PLL_CFG1_DIV3B_WIDTH			3
+#define LOOP_PLL_CFG1_POST_DIV0PRE_POS		28
+#define LOOP_PLL_CFG1_POST_DIV0PRE_WIDTH	1
+
+/*------------------------------------------------- */
+#define PON_SHELL_LOOP_PLL_CFG2 			0x64
+#define LOOP_PLL_CFG2_FBDIV_POS				0
+#define LOOP_PLL_CFG2_FBDIV_WIDTH			12
+#define LOOP_PLL_CFG2_REFDIV_POS			18
+#define LOOP_PLL_CFG2_REFDIV_WIDTH			6
+#define LOOP_PLL_CFG2_BYPASS0_POS			24
+#define LOOP_PLL_CFG2_BYPASS0_WIDTH			1
+#define LOOP_PLL_CFG2_BYPASS1_POS			25
+#define LOOP_PLL_CFG2_BYPASS1_WIDTH			1
+#define LOOP_PLL_CFG2_BYPASS2_POS			26
+#define LOOP_PLL_CFG2_BYPASS2_WIDTH			1
+#define LOOP_PLL_CFG2_BYPASS3_POS			27
+#define LOOP_PLL_CFG2_BYPASS3_WIDTH			1
+#define LOOP_PLL_CFG2_FREFCMLEN_POS			28
+#define LOOP_PLL_CFG2_FREFCMLEN_WIDTH		1
+
+/*------------------------------------------------- */
+#define PON_SHELL_LOOP_PLL_CFG3 			0x68
+#define LOOP_PLL_CFG3_DSKCAIN_POS			0
+#define LOOP_PLL_CFG3_DSKCAIN_WIDTH			12
+#define LOOP_PLL_CFG3_DSKCALOUT_POS			12
+#define LOOP_PLL_CFG3_DSKCALOUT_WIDTH		12
+#define LOOP_PLL_CFG3_DSKEWEN_POS			24
+#define LOOP_PLL_CFG3_DSKEWEN_WIDTH			1
+#define LOOP_PLL_CFG3_DSKEWCALBP_POS		25
+#define LOOP_PLL_CFG3_DSKEWCALBP_WIDTH		1
+#define LOOP_PLL_CFG3_FASTDSKEWCALEN_POS	26
+#define LOOP_PLL_CFG3_FASTDSKEWCALEN_WIDTH	1
+#define LOOP_PLL_CFG3_DSKEWCALCNT_POS		27
+#define LOOP_PLL_CFG3_DSKEWCALCNT_WIDTH		3
+
+#define VR_XS_PMA_GEN5_12G_TX_STS_TX_ACK_0			BIT(0)
+#define VR_XS_PMA_GEN5_12G_TX_STS_DETRX_RSLT_0		BIT(4)
+#define SR_PMA_STATUS1_RLU							BIT(2)
+#define SR_PMA_STATUS2_RF							BIT(10)
+
+#define SR_PMA_KR_PMD_STS_RCV_STS		BIT(0)
+#define SR_PMA_KR_PMD_STS_FRM_LCK		BIT(1)
+#define SR_PMA_KR_PMD_STS_SU_PR_DTD		BIT(2)
+#define SR_PMA_KR_PMD_STS_TR_FAIL		BIT(3)
+
+#define SR_PMA_KR_LP_CEU_LP_INIT		BIT(12)
+#define SR_PMA_KR_LP_CEU_LP_PRST		BIT(13)
+#define SR_PMA_KR_LP_CESTS_LP_RR		BIT(15)
+
+#define SR_PMA_KR_LD_CEU_LD_INIT		BIT(12)
+#define SR_PMA_KR_LD_CEU_LD_PRST		BIT(13)
+
+#define SR_PMA_KR_LD_CESTS_LD_RR		BIT(15)
+
+#define SR_AN_STS_LP_AN_ABL			BIT(0)
+#define SR_AN_STS_LP_AN_LS			BIT(2)
+#define SR_AN_STS_LD_AN_ABL			BIT(3)
+#define SR_AN_STS_LD_AN_RF			BIT(4)
+#define SR_AN_STS_LD_ANC			BIT(5)
+#define SR_AN_STS_LD_PR				BIT(6)
+#define SR_AN_STS_LD_EXT_NP_STS		BIT(7)
+#define SR_AN_STS_LD_PDF			BIT(9)
+
+#define SR_XS_PCS_STS1_RLU			BIT(2)
+#define SR_XS_PCS_STS2_RF			BIT(10)
+#define SR_XS_PCS_STS2_TF			BIT(11)
+#define SR_XS_PCS_KR_STS1_RLU		BIT(12)
+
+#define SR_MII_STS_LINK_STS					BIT(2)
+#define VR_MII_AN_CTRL_STS					BIT(4)
+#define VR_MII_1_AN_CTRL_SGMII_LINK_STS		BIT(4)
+#define VR_MII_2_AN_CTRL_SGMII_LINK_STS		BIT(4)
+
+/*************** Function Prototype Declaration ******************/
+extern struct combo_port g_combo_port_defs[COMBO_PORT_MAX];
+void combo_global_init(int port);
+u32 serdes_cr_write(int port, u32 addr, u32 data);
+u32 serdes_cr_read(int port, u32 addr);
+void serdes_cal_ovrd(int port);
+void rx_cdr_lock_check(int port, int lane);
+
+void read_mpll_state(int port);
+void tx_bert_enable(int port, int lane, int bert_mode);
+void tx_bert_disable(int port, int lane);
+void phy_rxeq_autoadapt(int port, int lane);
+
+void ljpll3_cfg_frac_eth(void);
+void ljpll3_cfg_integ_eth(void);
+void ljpll3_cfg_integ(void);
+void loop_pll_cfg_frac_pon(void);
+void loop_pll_cfg_integ_pon(int spd);
+void loop_pll_cfg_frac_eth(void);
+void loop_pll_cfg_integ_eth(void);
+
+void hsiolr_init(int p0_id, int p0_spd, int p1_id, int p1_spd);
+int wan_init(int spd);
+void xpcs5_init(int spd);
+int combophy_mode(int port, int mode);
+void hsiotop_clk_gate_cfg(int port, int dis);
+void init_combo_base(struct combo_port *combo_port, int port);
+void eth_xpcs_loopback_init(int port);
+void eth_pma_loopback_init(int port);
+void pma_pcs_link_status(int port);
+void tx_eq_status(int port, int lane, char port_str[20]);
+void tx_eq_override(int port, int lane, char port_str[20], struct tx_eq *txeq_ovrd);
+void rx_eq_status(int port, int lane, char port_str[20]);
+
+int pon_shell_rst_assert(void);
+int pon_shell_rst_deassert(void);
+int pon_shell_rst_stat(void);
+int combophy_rst_assert(int port);
+int combophy_rst_deassert(int port);
+int combophy_rst_stat(int port);
+int eth_phy_rst_deassert(int port);
+int eth_phy_rst_assert(int port);
+int eth_phy_rst_stat(int port);
+void combophy_paraclk_div2_cfg(struct combo_port *paddr, int port, int en);
+void combophy_sram_bypass_cfg(struct combo_port *paddr, int port, int en);
+
+void clear_reset(u32 regoff, u32 bitn);
+void set_reset(u32 regoff, u32 bitn);
+u32 get_reset_bit_status(u32 regoff, u32 bitn);
+void dummy(int port);
+void pon_shell_wan_init(int epon_en);
+#ifdef CONFIG_LGMC_SGMII
+int lgmc_sgmii_init(LGMC_SGMII_CONNECTION_SEL_t SGMII_CONNECTION, LGMC_SGMII_SPEED_SEL_t SGMII_SPEED);
+#endif
+
+#endif /* COMBOPHY_H */
diff --git a/drivers/net/lightning_mountain_sw.c b/drivers/net/lightning_mountain_sw.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/lightning_mountain_sw.c
@@ -0,0 +1,5143 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright © 2022 MaxLinear, Inc.
+ *
+ * Lightning Mountain Slim Ethernet Driver
+ *
+ */
+#include <common.h>
+#include <config.h>
+#include <dm.h>
+#include <fdt_support.h>
+#include <lgm_gpio.h>
+#include <malloc.h>
+#include <net.h>
+#include <miiphy.h>
+#include <image.h>
+#include <time.h>
+#include <asm/io.h>
+#include <asm/arch/project.h>
+#include <asm/lib_dma.h>
+#include <asm/cache.h>
+#include <asm/gpio.h>
+#include <linux/delay.h>
+
+#include "lightning_mountain_sw.h"
+#include "lightning_mountain_sw_ucode.h"
+
+#if defined(CONFIG_LTQ_BOOT_FROM_SPI) \
+	|| defined(CONFIG_LTQ_BOOT_FROM_QSPI)
+#include <spi.h>
+#include <spi_flash.h>
+#endif
+
+#ifdef CONFIG_LGM_P34X_SUPPORT
+#include <lzma/LzmaTypes.h>
+#include <lzma/LzmaDec.h>
+#include <lzma/LzmaTools.h>
+
+#define CONFIG_LGM_GPHY_FW_ADDR (CONFIG_SYS_TEXT_BASE + CONFIG_LGM_U_BOOT_SIZE)
+#define CONFIG_LGM_UNCOMPRESSED_GPHY_FW_SIZE	(0x20000)
+
+#define P34X_MAX_PORT	4
+#define MAC_START	3
+#define MAC_LAST	7
+#define P34_VER_SHIFT	12
+u32 mxl86249_fw = 0;
+extern struct usxspd g_usxspeed_defs[1];
+#else
+#define MAC_START	0
+#define MAC_LAST	9
+#endif /* CONFIG_LGM_P34X_SUPPORT */
+
+#if defined(CONFIG_LGM_P34X_SUPPORT) || defined(CONFIG_XPCS5_USXGMII_RTL8261)
+#define MDC_CLK_DIV_LSB		GENMASK(21, 19)
+#define MDC_CLK_DIV_MSB		BIT(31)
+#define MDC_CLK_DIV_MSK		(MDC_CLK_DIV_MSB | MDC_CLK_DIV_LSB)
+#endif /* CONFIG_LGM_P34X_SUPPORT || CONFIG_XPCS5_USXGMII_RTL8261 */
+
+/* Switch Offset */
+#define TX_PORT		0
+#define RX_PORT		0
+#define TX_CHAN		0
+#define RX_CHAN		0
+
+#if !defined(CONFIG_LIGHTNING_A0)
+#define NUM_RX_DESC 4
+#else
+#define NUM_RX_DESC 1
+#endif /* !CONFIG_LIGHTNING_A0 */
+#define NUM_TX_DESC 1
+#define MAX_PACKET_SIZE     1536
+#define TOUT_LOOP   100
+
+#define MDIO_WRITE_CMD	((0 << 11) | (1 << 10))
+#define MDIO_READ_CMD  ((1 << 11) | (0 << 10))
+
+#define PCE_TABLE_SIZE		256
+#define PCE_PARS_INDEX		0
+#define PCE_OP_MODE_ADWR	1
+#define INSTR				0
+#define IPV6				1
+#define LENACCU				2
+
+#if defined(CONFIG_LAN_HSIO_L) || defined(CONFIG_LAN_HSIO_R)
+u32 gpy215_sgmii_1g = 1;
+#endif
+
+#ifdef CONFIG_LGMC_SGMII
+extern int combophy_hsio_c10phy_init(LGMC_SGMII_CONNECTION_SEL_t SGMII_CONNECTION);
+#endif
+
+extern int combophy_hsio_init(int phy);
+extern int combophy_hsio_init_xpcs5_rtl8261(int phy);
+extern int wan_init(int spd);
+extern int gswip_xpcs5_init(int spd);
+extern int gswip_xpcs5_init_rtl8261(int spd);
+extern int set_adp_dvfs_level(int level);
+
+#if defined(CONFIG_LGMC_SGMII) || defined(CONFIG_XPCS5_USXGMII_RTL8261)
+void sso_init(int sso_no);
+int sso_output(int gpio, u32 value, u8 duty_cycle);
+#endif
+
+#ifdef CONFIG_LGMC_SGMII
+int lgmc_sgmii_init(LGMC_SGMII_CONNECTION_SEL_t SGMII_CONNECTION, LGMC_SGMII_SPEED_SEL_t SGMII_SPEED);
+#endif
+
+u32 kick_start;
+
+/* xgmac_priv data default values for xgmac module 2*/
+struct mac_prv_data xgmac_prv_data[10] = {
+	{
+		.mac_idx          = 0,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(0),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(0),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(0),
+		.tx_q_count         = 1,
+		.rx_q_count         = 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x01},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip          = 0,
+		.crc_strip_type     = 0,
+		.padcrc_strip       = 0,
+		.rmon_reset         = 1,
+		.fup                = 1,
+		.fef                = 1,
+		.mac_en             = 1,
+		.ipg                = 0,
+		.enable_mac_int     = MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int     = MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend 		= 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec                = 0,
+		.nsec               = 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy  = 0,
+	},
+	/* xgmac_priv data default values xgmac module 3*/
+	{
+		.mac_idx			= 1,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(1),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(1),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(1),
+		.tx_q_count 		= 1,
+		.rx_q_count 		= 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x02},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip			= 0,
+		.crc_strip_type 	= 0,
+		.padcrc_strip		= 0,
+		.rmon_reset 		= 1,
+		.fup				= 1,
+		.fef				= 1,
+		.mac_en 			= 1,
+		.ipg				= 0,
+		.enable_mac_int 	= MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int 	= MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend		    = 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec				= 0,
+		.nsec				= 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy	= 0,
+
+	},
+	/* xgmac_priv data default values xgmac module 4*/
+	{
+		.mac_idx			= 2,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(2),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(2),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(2),
+		.tx_q_count 		= 1,
+		.rx_q_count 		= 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x03},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip			= 0,
+		.crc_strip_type 	= 0,
+		.padcrc_strip		= 0,
+		.rmon_reset 		= 1,
+		.fup				= 1,
+		.fef				= 1,
+		.mac_en 			= 1,
+		.ipg                = 0,
+		.enable_mac_int     = MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int     = MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend 		= 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec				= 0,
+		.nsec				= 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy  = 0,
+	},
+	/* xgmac_priv data default values xgmac module 5*/
+	{
+		.mac_idx			= 3,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(3),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(3),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(3),
+		.tx_q_count 		= 1,
+		.rx_q_count 		= 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x04},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip			= 0,
+		.crc_strip_type 	= 0,
+		.padcrc_strip		= 0,
+		.rmon_reset 		= 1,
+		.fup				= 1,
+		.fef				= 1,
+		.mac_en 			= 1,
+		.ipg                = 0,
+		.enable_mac_int     = MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int     = MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend 		= 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec				= 0,
+		.nsec				= 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy  = 0,
+	},
+	/* xgmac_priv data default values xgmac module 6*/
+	{
+		.mac_idx			= 4,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(4),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(4),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(4),
+		.tx_q_count 		= 1,
+		.rx_q_count 		= 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x06},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip			= 0,
+		.crc_strip_type 	= 0,
+		.padcrc_strip		= 0,
+		.rmon_reset 		= 1,
+		.fup				= 1,
+		.fef				= 1,
+		.mac_en 			= 1,
+		.ipg                = 0,
+		.enable_mac_int     = MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int     = MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend 		= 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec				= 0,
+		.nsec				= 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy  = 0,
+	},
+	/* xgmac_priv data default values xgmac module 7*/
+	{
+		.mac_idx			= 5,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(5),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(5),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(5),
+		.tx_q_count 		= 1,
+		.rx_q_count 		= 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x07},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip			= 0,
+		.crc_strip_type 	= 0,
+		.padcrc_strip		= 0,
+		.rmon_reset 		= 1,
+		.fup				= 1,
+		.fef				= 1,
+		.mac_en 			= 1,
+		.ipg                = 0,
+		.enable_mac_int     = MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int     = MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend 		= 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec				= 0,
+		.nsec				= 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy  = 0,
+	},
+	/* xgmac_priv data default values xgmac module 8*/
+	{
+		.mac_idx			= 6,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(6),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(6),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(6),
+		.tx_q_count 		= 1,
+		.rx_q_count 		= 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x08},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip			= 0,
+		.crc_strip_type 	= 0,
+		.padcrc_strip		= 0,
+		.rmon_reset 		= 1,
+		.fup				= 1,
+		.fef				= 1,
+		.mac_en 			= 1,
+		.ipg                = 0,
+		.enable_mac_int     = MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int     = MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend 		= 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec				= 0,
+		.nsec				= 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy  = 0,
+	},
+	/* xgmac_priv data default values xgmac module 9*/
+	{
+		.mac_idx			= 7,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(7),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(7),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(7),
+		.tx_q_count 		= 1,
+		.rx_q_count 		= 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x09},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip			= 0,
+		.crc_strip_type 	= 0,
+		.padcrc_strip		= 0,
+		.rmon_reset 		= 1,
+		.fup				= 1,
+		.fef				= 1,
+		.mac_en 			= 1,
+		.ipg                = 0,
+		.enable_mac_int     = MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int     = MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend 		= 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec				= 0,
+		.nsec				= 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy  = 0,
+	},
+	{
+		.mac_idx			= 8,
+		.xgmac_ctrl_reg 	= XGMAC_CTRL_REG(8),
+		.xgmac_data0_reg 	= XGMAC_DATA0_REG(8),
+		.xgmac_data1_reg 	= XGMAC_DATA1_REG(8),
+		.tx_q_count 		= 1,
+		.rx_q_count 		= 1,
+		.tx_sf_mode 		= 0,
+		.tx_threshold 		= MTL_TX_THRESHOLD_64,
+		.rx_sf_mode 		= 0,
+		.rx_threshold	    = MTL_RX_THRESHOLD_64,
+		.mac_addr			= {0x00, 0x00, 0x94, 0x00, 0x00, 0x09},
+		.tstamp_addend      = 0,
+		.tx_tstamp			= 0,
+		/* .phy_speed			= SPEED_MAC_AUTO, PRE-SILICON FORCE */
+		.phy_speed		= SPEED_XGMAC_10G,
+		.promisc_mode		= 1,
+		.all_mcast_mode		= 1,
+		.rfa 				= 2,
+		.rfd 				= 4,
+		.tx_mtl_alg 		= MTL_ETSALG_WRR,
+		.rx_mtl_alg 		= MTL_RAA_SP,
+		.mtu 				= LGM_MAX_MTU,
+		.pause_time 		= 0xFFFF,
+		.rx_checksum_offload = 1,
+		.pause_frm_enable	= 1,
+		.rmon_reset			= 1,
+		.loopback           = 0,
+		.eee_enable         = 1,
+		.lst                = 1000,
+		.twt                = 0,
+		.lpitxa             = 0,
+		.crc_strip			= 0,
+		.crc_strip_type 	= 0,
+		.padcrc_strip		= 0,
+		.rmon_reset 		= 1,
+		.fup				= 1,
+		.fef				= 1,
+		.mac_en 			= 1,
+		.ipg                = 0,
+		.enable_mac_int     = MASK(MAC_IER, TSIE) | MASK(MAC_IER, TXESIE) | MASK(MAC_IER, RXESIE) | MASK(MAC_IER, LPIIE) | MASK(MAC_IER, PMTIE),
+		.enable_mtl_int     = MASK(MTL_Q_IER, TXUIE) | MASK(MTL_Q_IER, ABPSIE) | MASK(MTL_Q_IER, RXOIE),
+		.def_addend 		= 0x19999999, /* Calc as (2^32 * 50Mhz)/ 500Mhz */
+		.sec				= 0,
+		.nsec				= 0,
+		.ptp_clk            = PTP_CLK,
+		.one_nsec_accuracy  = 0,
+	}
+};
+
+struct lightning_mountain_eth_priv {
+	u32 gswip_l_base;
+	u32 gswip_o_base;
+	u32 gswip_oss_base;
+	u32 dma_tx_base;
+	u32 dma_rx_base;
+
+	int pmac_id;
+	int tx_num;
+	int rx_num;
+	int phy_addr;
+	int p34x_tune_val;
+
+	_dma_rx_descriptor_t *rx_des_ring;
+	_dma_tx_descriptor_t *tx_des_ring;
+}__attribute__ ((aligned(32)));
+
+typedef struct {
+	u16 key[21];
+	u16 mask[4];
+	u16 val[25];
+	u16 table;
+	u16 table_index;
+	u16 op_mode:2;
+	u16 extop:1;
+	u16 key_format:1;
+	u16 type:1;
+	u16 valid:1;
+	u16 group:4;
+} pctbl_prog_t;
+
+static const gsw_pce_tbl_info_t gsw_pce_tbl_info_31[] = {
+	{0, 0, 4}, {0, 0, 0}, {1, 0, 1}, {1, 0, 0}, {1, 1, 0}, {1, 1, 0},
+	{4, 4, 0}, {4, 4, 0}, {1, 1, 0}, {0, 0, 1}, {0, 0, 1}, {4, 0, 10},
+	{0, 0, 2}, {19, 0, 10}, {2, 0, 5}, {22, 0, 18}, {0, 0, 0}, {0, 0, 1},
+	{0, 0, 9}, {0, 0, 7}, {0, 0, 18}, {0, 0, 14}, {3, 1, 0}, {3, 1, 0},
+	{1, 1, 0}, {0, 0, 10}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {1, 1, 0},
+	{4, 0, 6}, {0, 0, 1}
+};
+
+static const u32 gsw_pce_tbl_reg_key[] = {
+	PCE_TBL_KEY_0_KEY0_OFFSET, PCE_TBL_KEY_1_KEY1_OFFSET,
+	PCE_TBL_KEY_2_KEY2_OFFSET, PCE_TBL_KEY_3_KEY3_OFFSET,
+	PCE_TBL_KEY_4_KEY4_OFFSET, PCE_TBL_KEY_5_KEY5_OFFSET,
+	PCE_TBL_KEY_6_KEY6_OFFSET, PCE_TBL_KEY_7_KEY7_OFFSET,
+	PCE_TBL_KEY_8_KEY8_OFFSET, PCE_TBL_KEY_9_KEY9_OFFSET,
+	PCE_TBL_KEY_10_KEY10_OFFSET, PCE_TBL_KEY_11_KEY11_OFFSET,
+	PCE_TBL_KEY_12_KEY12_OFFSET, PCE_TBL_KEY_13_KEY13_OFFSET,
+	PCE_TBL_KEY_14_KEY14_OFFSET, PCE_TBL_KEY_15_KEY15_OFFSET,
+	PCE_TBL_KEY_16_KEY16_OFFSET, PCE_TBL_KEY_17_KEY17_OFFSET,
+	PCE_TBL_KEY_18_KEY18_OFFSET, PCE_TBL_KEY_19_KEY19_OFFSET,
+	PCE_TBL_KEY_20_KEY20_OFFSET, PCE_TBL_KEY_21_KEY21_OFFSET
+};
+
+static const u32 gsw_pce_tbl_reg_mask[] = {
+	PCE_TBL_MASK_0_MASK0_OFFSET, PCE_TBL_MASK_1_MASK1_OFFSET,
+	PCE_TBL_MASK_2_MASK2_OFFSET, PCE_TBL_MASK_3_MASK3_OFFSET
+};
+
+static const u32 gsw_pce_tbl_reg_value[] = {
+	PCE_TBL_VAL_0_VAL0_OFFSET, PCE_TBL_VAL_1_VAL1_OFFSET,
+	PCE_TBL_VAL_2_VAL2_OFFSET, PCE_TBL_VAL_3_VAL3_OFFSET,
+	PCE_TBL_VAL_4_VAL4_OFFSET, PCE_TBL_VAL_5_VAL5_OFFSET,
+	PCE_TBL_VAL_6_VAL6_OFFSET, PCE_TBL_VAL_7_VAL7_OFFSET,
+	PCE_TBL_VAL_8_VAL8_OFFSET, PCE_TBL_VAL_9_VAL9_OFFSET,
+	PCE_TBL_VAL_10_VAL10_OFFSET, PCE_TBL_VAL_11_VAL11_OFFSET,
+	PCE_TBL_VAL_12_VAL12_OFFSET, PCE_TBL_VAL_13_VAL13_OFFSET,
+	PCE_TBL_VAL_14_VAL14_OFFSET, PCE_TBL_VAL_15_VAL15_OFFSET,
+	PCE_TBL_VAL_16_VAL16_OFFSET, PCE_TBL_VAL_17_VAL17_OFFSET,
+	PCE_TBL_VAL_18_VAL18_OFFSET, PCE_TBL_VAL_19_VAL19_OFFSET,
+	PCE_TBL_VAL_20_VAL20_OFFSET, PCE_TBL_VAL_21_VAL21_OFFSET,
+	PCE_TBL_VAL_22_VAL22_OFFSET, PCE_TBL_VAL_23_VAL23_OFFSET,
+	PCE_TBL_VAL_24_VAL24_OFFSET, PCE_TBL_VAL_25_VAL25_OFFSET
+};
+
+#ifdef CONFIG_DEBUG
+static void hexdump(unsigned char *buf, unsigned int len)
+{
+	while (len--) {
+		if (len && !(len % 16))
+			printf("\n");
+		printf("%02x", *buf++);
+	}
+	printf("\n");
+}
+#endif
+
+static inline u32 gsw_field_r32(u32 rval, short shift, short size)
+{
+	return (rval >> shift) & ((1 << size) - 1);
+}
+
+static inline u32 gsw_field_w32(u32 rval, short shift, short size, u32 val)
+{
+	u32 mask;
+
+	mask = ((1 << size) - 1) << shift;
+	val = (val << shift) & mask;
+	return (rval & ~mask) | val;
+}
+
+static inline void gsw_r32_raw(u32 base_addr, short offset, u32 *value)
+{
+	*value = readl(base_addr + (offset * 4));
+}
+
+static inline void gsw_w32_raw(u32 base_addr, short offset, u32 value)
+{
+	writel(value, base_addr + (offset * 4));
+}
+
+int gsw_pce_table_write(struct udevice *dev, pctbl_prog_t *ptdata)
+{
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	int i, j;
+	unsigned int num_key, num_mask, num_val;
+	u32 ctrlval;
+	u32 base_addr;
+
+	if (!priv)
+		return -EINVAL;
+
+	base_addr = (u32)(priv->gswip_o_base);
+
+	do {
+		gsw_r32_raw(base_addr, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+				PCE_TBL_CTRL_BAS_SIZE));
+
+	gsw_w32_raw(base_addr, PCE_TBL_ADDR_ADDR_OFFSET, ptdata->table_index);
+
+	num_key = gsw_pce_tbl_info_31[ptdata->table].num_key;
+	num_mask = gsw_pce_tbl_info_31[ptdata->table].num_mask;
+	num_val = gsw_pce_tbl_info_31[ptdata->table].num_val;
+
+	/*TABLE ADDRESS*/
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_ADDR_SHIFT,
+				PCE_TBL_CTRL_ADDR_SIZE, ptdata->table);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_OPMOD_SHIFT,
+				PCE_TBL_CTRL_OPMOD_SIZE, PCE_OP_MODE_ADWR);
+
+	/*KEY REG*/
+	j = num_key;
+	if (ptdata->key_format)
+		j *= 4;
+
+	for (i = 0; i < j; i++)
+		gsw_w32_raw(base_addr,
+				gsw_pce_tbl_reg_key[i], ptdata->key[i]);
+
+	/*MASK REG*/
+	j = num_mask;
+	for (i = 0; i < j; i++)
+		gsw_w32_raw(base_addr,
+				gsw_pce_tbl_reg_mask[i], ptdata->mask[i]);
+
+	/*VAL REG*/
+	j = num_val;
+	for (i = 0; i < j; i++)
+		gsw_w32_raw(base_addr,
+				gsw_pce_tbl_reg_value[i], ptdata->val[i]);
+
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_KEYFORM_SHIFT,
+				PCE_TBL_CTRL_KEYFORM_SIZE,
+				ptdata->key_format);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_TYPE_SHIFT,
+				PCE_TBL_CTRL_TYPE_SIZE, ptdata->type);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_VLD_SHIFT,
+				PCE_TBL_CTRL_VLD_SIZE, ptdata->valid);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_GMAP_SHIFT,
+				PCE_TBL_CTRL_GMAP_SIZE, ptdata->group);
+	ctrlval = gsw_field_w32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+				PCE_TBL_CTRL_BAS_SIZE, 1);
+	gsw_w32_raw(base_addr, PCE_TBL_CTRL_BAS_OFFSET, ctrlval);
+
+	do {
+		gsw_r32_raw(base_addr, PCE_TBL_CTRL_BAS_OFFSET, &ctrlval);
+	} while (gsw_field_r32(ctrlval, PCE_TBL_CTRL_BAS_SHIFT,
+				PCE_TBL_CTRL_BAS_SIZE));
+
+	gsw_w32_raw(base_addr, PCE_TBL_CTRL_ADDR_OFFSET, 0);
+
+	return 0;
+}
+
+#ifdef CONFIG_DEBUG
+int GSW_PMAC_CountGet_v32(struct udevice *dev, u32 txChanId, u32 pmacId)
+{
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	int err;
+        u8 i = 0;
+        u32 data, base_addr;
+        bmtbl_prog_t bmtable = {0};
+
+	if (!priv)
+		return -EINVAL;
+
+	base_addr = (u32)(priv->gswip_o_base);
+
+	/* For Ingress it is 0 - 16, for Egress 0 - 15. */
+                if ((txChanId >= 17))
+					return -1;
+
+	for (i = 0; i <= 15; i++) {
+		if ((i == 12) || (i == 13))
+			continue;
+
+		bmtable.adr.pmacRmon.channel_or_port = txChanId;
+
+		if (i < 8)
+			bmtable.adr.pmacRmon.count = i;
+		else {
+			bmtable.adr.pmacRmon.count = (i & 0x7);
+			bmtable.adr.bits.b12 = ((i & 0x8) >> 3);
+		}
+
+		bmtable.adr.pmacRmon.pmacNo = pmacId;
+		bmtable.b64bitMode = 0;
+		bmtable.tableID = PMAC_RMON_COUNTER;
+		bmtable.numValues = 2;
+		err = gsw_bm_table_read(base_addr, &bmtable);
+
+		if (err < 0)
+			return -1;
+
+		data = (bmtable.value[1] << 16) | (bmtable.value[0] & 0xFFFF);
+
+		switch (i) {
+		case 0:
+			printf("nDiscPktsCount = 0x%08x\n", data);
+			break;
+		case 1:
+			printf("nDiscBytesCount = 0x%08x\n",  data);
+			break;
+		case 2:
+			printf("nChkSumErrPktsCount = 0x%08x\n",  data);
+			break;
+		case 3:
+			printf("ChkSumErrBytesCount = 0x%08x\n",  data);
+			break;
+		case 4:
+			printf("nIngressPktsCount = 0x%08x\n", data);
+			break;
+		case 5:
+			printf("nIngressBytesCount = 0x%08x\n", data);
+			break;
+		case 6:
+			printf("nEgressPktsCount = 0x%08x\n", data);
+			break;
+		case 7:
+			printf("nEgressBytesCount = 0x%08x\n", data);
+			break;
+		case 8:
+			printf("nIngressHdrPktsCount = 0x%08x\n", data);
+			break;
+		case 9:
+			printf("nIngressHdrBytesCount = 0x%08x\n", data);
+			break;
+		case 10:
+			printf("nEgressHdrPktsCount = 0x%08x\n", data);
+			break;
+		case 11:
+			printf("nEgressHdrBytesCount = 0x%08x\n", data);
+			break;
+		case 14:
+			printf("nEgressHdrDiscPktsCount = 0x%08x\n", data);
+			break;
+		case 15:
+			printf("nEgressHdrDiscBytesCount = 0x%08x\n", data);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+int gsw_bm_table_read(u32 base_addr, bmtbl_prog_t *ptdata)
+{
+	int i, noOfValues, err = 0;
+	u32 value, retry = 0xFFFF;
+
+	if (ptdata->b64bitMode)
+		ptdata->tableID |= 0x40;
+
+	noOfValues = ptdata->numValues;
+	gsw_w32_raw(base_addr, BM_RAM_ADDR_REG_OFFSET, (u32) ptdata->adr.raw);
+	gsw_w32_raw(base_addr, BM_RAM_CTRL_REG_OFFSET, ((u32)ptdata->tableID) | 0x8000);
+
+	while(1) {
+		gsw_r32(base_addr, BM_RAM_CTRL_BAS_OFFSET,
+				BM_RAM_CTRL_BAS_SHIFT, BM_RAM_CTRL_BAS_SIZE, &value);
+		retry --;
+		if (value == 0)
+			break;
+		if (retry == 0) {
+			printf("Timeout waiting for BM\n");
+			return -1;
+		}
+	}
+
+	for (i = 0; (i < noOfValues); i++)
+		gsw_r32_raw(base_addr, BM_RAM_VAL_0_VAL0_OFFSET - i, &(ptdata->value[i]));
+
+	return err;
+}
+#endif
+
+static int gsw_bm_table_write(u32 base_addr, bmtbl_prog_t *ptdata)
+{
+	int i, noOfValues;
+	int retry = 1000;
+	u32 value;
+
+	if (ptdata->b64bitMode)
+		ptdata->tableID |= 0x40;
+
+	noOfValues = ptdata->numValues;
+	gsw_w32_raw(base_addr,
+		BM_RAM_ADDR_REG_OFFSET,
+		(u32) ptdata->adr.raw);
+	gsw_w32_raw(base_addr,
+		BM_RAM_CTRL_REG_OFFSET,
+		((u32)ptdata->tableID) | 0x0020);
+
+	for (i = 0; (i < noOfValues) /*&& (GSW_statusOk == err)*/; i++)
+		gsw_w32_raw(base_addr,
+		BM_RAM_VAL_0_VAL0_OFFSET - i, ptdata->value[i]);
+
+	gsw_w32_raw(base_addr, BM_RAM_CTRL_REG_OFFSET,
+		((u32)ptdata->tableID) | 0x8020);
+
+	while (1) {
+		gsw_r32(base_addr, BM_RAM_CTRL_BAS_OFFSET,
+			BM_RAM_CTRL_BAS_SHIFT, BM_RAM_CTRL_BAS_SIZE, &value);
+		retry --;
+		if (value == 0)
+			break;
+		if (retry == 0) {
+			printf("Timeout waiting for BM\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static void gswip_qos_wred_config(struct udevice *dev)
+{
+	int portId, queueId;
+	u8 crcode;
+	u32 base_addr, addr;
+	u32 red_min = 0, red_max = 0;
+	u32 yellow_min = 0, yellow_max = 0;
+	u32 green_min = 200, green_max = 200;
+	bmtbl_prog_t bmtable = {0};
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return;
+
+	base_addr = (u32)(priv->gswip_o_base);
+
+	for (portId = 0; portId < 16; portId++) {
+		gsw_w32(base_addr, (BM_PWRED_RTH_0_MINTH_OFFSET
+					   + (portId * 0x6)),
+				BM_PWRED_RTH_0_MINTH_SHIFT,
+				BM_PWRED_RTH_0_MINTH_SIZE, red_min);
+		/** WRED Red Threshold Max [number of segments]. */
+		gsw_w32(base_addr, (BM_PWRED_RTH_1_MAXTH_OFFSET
+					   + (portId * 0x6)),
+				BM_PWRED_RTH_1_MAXTH_SHIFT,
+				BM_PWRED_RTH_1_MAXTH_SIZE, red_max);
+		/* WRED Yellow Threshold - Minimum */
+		gsw_w32(base_addr, (BM_PWRED_YTH_0_MINTH_OFFSET
+					   + (portId * 0x6)),
+				BM_PWRED_YTH_0_MINTH_SHIFT,
+				BM_PWRED_YTH_0_MINTH_SIZE, yellow_min);
+		/* WRED Yellow Threshold - Maximum */
+		gsw_w32(base_addr, (BM_PWRED_YTH_1_MAXTH_OFFSET
+					   + (portId * 0x6)),
+				BM_PWRED_YTH_1_MAXTH_SHIFT,
+				BM_PWRED_YTH_1_MAXTH_SIZE, yellow_max);
+		/* WRED Green Threshold - Minimum */
+		gsw_w32(base_addr, (BM_PWRED_GTH_0_MINTH_OFFSET
+					   + (portId * 0x6)),
+				BM_PWRED_GTH_0_MINTH_SHIFT,
+				BM_PWRED_GTH_0_MINTH_SIZE, green_min);
+		/* WRED Green Threshold - Maximum */
+		gsw_w32(base_addr, (BM_PWRED_GTH_1_MAXTH_OFFSET
+					   + (portId * 0x6)),
+				BM_PWRED_GTH_1_MAXTH_SHIFT,
+                        BM_PWRED_GTH_1_MAXTH_SIZE, green_max);
+	}
+
+	for (queueId = 0; queueId < 32; queueId++) {
+		for (crcode = 1; crcode < 4; crcode++) {
+			addr = (((queueId << 3) & 0xF8) | crcode);
+			bmtable.adr.raw = (u16)addr;
+
+			switch (crcode) {
+			case 3:
+				bmtable.value[1] = red_max;
+				bmtable.value[0] = red_min;
+				break;
+
+			case 2:
+				bmtable.value[1] = yellow_max;
+				bmtable.value[0] = yellow_min;
+				break;
+
+			case 1:
+				bmtable.value[1] = green_max;
+				bmtable.value[0] = green_min;
+				break;
+			}
+
+			bmtable.tableID = PQM_THRESHOLD;
+			bmtable.numValues = 2;
+			gsw_bm_table_write(base_addr, &bmtable);
+		}
+	}
+}
+
+static int lightning_mountain_switch_enable(struct udevice *dev,
+				unsigned int total_ports)
+{
+	int i;
+	u32 reg;
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+	for (i = 0; i < total_ports; i++) {
+		reg = readl(priv->gswip_o_base + FDMA_PCTRL + (i * 0x18));
+		reg &= ~(FDMA_PCTRL_EN_MASK);
+		reg |= 1;
+		writel(reg, priv->gswip_o_base + FDMA_PCTRL + (i * 0x18));
+
+		reg = readl(priv->gswip_o_base + SDMA_PCTRL + (i * 0x18));
+		reg &= ~(SDMA_PCTRL_PEN_POS);
+		reg |= 1;
+		writel(reg, priv->gswip_o_base + SDMA_PCTRL + (i * 0x18));
+
+		writel(0x00000001, priv->gswip_o_base + BM_PCFG + (i * 0x8));
+	}
+
+	reg = readl(priv->gswip_oss_base + GSWIP_CFG);
+	reg |= (1 << GSWIP_CFG_CORE_SE_POS);
+	writel(reg, priv->gswip_oss_base + GSWIP_CFG);
+	return 0;
+}
+
+int lightning_mountain_load_microcode(struct udevice *dev,
+				unsigned int num_ports)
+{
+	int i, j;
+	pctbl_prog_t tbl_entry;
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	u32 base_addr;
+
+	if (!priv)
+		return -EINVAL;
+
+	base_addr = (u32)(priv->gswip_o_base);
+
+	/* Disable all physical port  */
+	for (j = 0; j < num_ports; j++) {
+		gsw_w32(base_addr, (FDMA_PCTRL_EN_OFFSET + (j * 0x6)),
+			FDMA_PCTRL_EN_SHIFT, FDMA_PCTRL_EN_SIZE, 0);
+		gsw_w32(base_addr, (SDMA_PCTRL_PEN_OFFSET + (j * 0x6)),
+			SDMA_PCTRL_PEN_SHIFT, SDMA_PCTRL_PEN_SIZE, 0);
+	}
+
+	gsw_w32(base_addr, PCE_GCTRL_0_MC_VALID_OFFSET,
+		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x0);
+
+	for (i = 0; i < PCE_TABLE_SIZE; i++) {
+		memset(&tbl_entry, 0, sizeof(pctbl_prog_t));
+		tbl_entry.val[3] = pce_mc_max_ifx_tag_m_30[i].val_3;
+		tbl_entry.val[2] = pce_mc_max_ifx_tag_m_30[i].val_2;
+		tbl_entry.val[1] = pce_mc_max_ifx_tag_m_30[i].val_1;
+		tbl_entry.val[0] = pce_mc_max_ifx_tag_m_30[i].val_0;
+		tbl_entry.table_index = i;
+		tbl_entry.table = PCE_PARS_INDEX;
+		gsw_pce_table_write(dev, &tbl_entry);
+	}
+
+	gsw_w32(base_addr, PCE_GCTRL_0_MC_VALID_OFFSET,
+		PCE_GCTRL_0_MC_VALID_SHIFT, PCE_GCTRL_0_MC_VALID_SIZE, 0x1);
+
+	/* Enable RMON Counter for all ports */
+	for (j = 0; j < num_ports; j++) {
+		gsw_w32(base_addr, (BM_PCFG_CNTEN_OFFSET + (j * 0x2)),
+			BM_PCFG_CNTEN_SHIFT, BM_PCFG_CNTEN_SIZE, 1);
+	}
+
+	gsw_w32(base_addr, BM_QUEUE_GCTRL_GL_MOD_OFFSET,
+		BM_QUEUE_GCTRL_GL_MOD_SHIFT, 2, 0);
+
+	return 0;
+}
+
+static inline u32 LMAC_RGRD(u32 reg)
+{
+	u32 reg_val;
+
+	reg_val = readl(LEGACY_MAC_BASE + reg);
+	return reg_val;
+}
+
+static inline void LMAC_RGWR(u32 reg, u32 val)
+{
+	writel(val, LEGACY_MAC_BASE + reg);
+}
+
+static inline u32 GSWSS_RGRD(u32 reg)
+{
+	u32 reg_val;
+
+	reg_val = readl(GSWIP_SS + reg);
+	return reg_val;
+}
+
+static inline void GSWSS_RGWR(u32 reg, u32 val)
+{
+	writel(val, GSWIP_SS + reg);
+}
+
+static inline u32 XGMAC_RGRD(struct mac_prv_data *pdata, u16 reg)
+{
+	u32 reg_val;
+
+	writel((0x8000 | reg), (u32 *)pdata->xgmac_ctrl_reg)
+		;
+	while (1) {
+		if ((readl((u32 *)pdata->xgmac_ctrl_reg) & 0x8000) == 0)
+			break;
+	}
+
+	reg_val = ((readl((u32 *)pdata->xgmac_data1_reg) << 16) |
+				(readl((u32 *) pdata->xgmac_data0_reg)));
+
+	return reg_val;
+}
+
+static inline void XGMAC_RGWR(struct mac_prv_data *pdata, u16 reg, u32 val)
+{
+	writel(((val & 0xFFFF0000) >> 16), (u32 *)pdata->xgmac_data1_reg);
+	writel((val & 0x0000FFFF), (u32 *)pdata->xgmac_data0_reg);
+	writel((0xC000 | reg), (u32 *)pdata->xgmac_ctrl_reg);
+
+	while (1) {
+		if ((readl((u32 *)pdata->xgmac_ctrl_reg) & 0x8000) == 0)
+			break;
+	}
+}
+
+void mdio_set_clause(struct mac_prv_data *pdata,
+				u32 clause, u32 phy_id)
+{
+	u32 mdio_c22p = 0;
+
+	mdio_c22p = XGMAC_RGRD(pdata, MDIO_C22P);
+	SET_BITS_VAL(mdio_c22p, phy_id, MDIO_CL22P_PORT0_WIDTH, clause);
+	/* Select port 0, 1, 2 and 3 as Clause 22/45 ports */
+	XGMAC_RGWR(pdata, MDIO_C22P, mdio_c22p);
+}
+
+int mdio_get_clause(struct mac_prv_data *pdata,  u32 phy_id)
+{
+	u32 mdio_c22p = 0;
+	int clause;
+
+	mdio_c22p = XGMAC_RGRD(pdata, MDIO_C22P);
+
+	clause = GET_BITS(mdio_c22p, phy_id, MDIO_CL22P_PORT0_WIDTH);
+
+	return clause;
+}
+
+int mdio_read(struct mac_prv_data *pdata,
+			 u32 dev_adr,
+			 u32 phy_id,
+			 u32 phy_reg,
+			 u32 *phy_reg_data)
+{
+	u32 mdio_sccdr = 0;
+	u32 mdio_scar = 0;
+
+#ifdef LGM_NET_VERBOSE
+	u32 clause;
+
+	clause = mdio_get_clause(pdata, 0x1);
+
+	debug("Reading from dev=%08x, clause=%d, id=0x%08x, register=0x%08x\n",
+		dev_adr, clause ? 22 : 45, phy_id, phy_reg);
+#endif /* LGM_NET_VERBOSE */
+
+	/* wait for any previous MDIO read/write operation to complete */
+	/*Poll*/
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MDIO_SCCDR, BUSY) == 0)
+			break;
+	}
+
+	/* initiate the MDIO read operation by updating desired bits */
+	/* PA - phy address/id (0 - 31) */
+	/* RA - phy register offset */
+
+	mdio_scar = XGMAC_RGRD(pdata, MDIO_SCAR);
+
+	XGMAC_SET_BITS(mdio_scar, MDIO_SCAR, DA, dev_adr);
+	XGMAC_SET_BITS(mdio_scar, MDIO_SCAR, PA, phy_id);
+	XGMAC_SET_BITS(mdio_scar, MDIO_SCAR, RA, phy_reg);
+
+	XGMAC_RGWR(pdata, MDIO_SCAR, mdio_scar);
+
+	mdio_sccdr = XGMAC_RGRD(pdata, MDIO_SCCDR);
+
+	XGMAC_SET_BITS(mdio_sccdr, MDIO_SCCDR, BUSY, 1);
+	XGMAC_SET_BITS(mdio_sccdr, MDIO_SCCDR, SADDR, 0);
+	XGMAC_SET_BITS(mdio_sccdr, MDIO_SCCDR, CMD, 3);
+	XGMAC_SET_BITS(mdio_sccdr, MDIO_SCCDR, SDATA, 0);
+
+	XGMAC_RGWR(pdata, MDIO_SCCDR, mdio_sccdr);
+
+	/* wait for MDIO read operation to complete */
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MDIO_SCCDR, BUSY) == 0)
+			break;
+	}
+
+	/* read the data */
+	mdio_sccdr = XGMAC_RGRD(pdata, MDIO_SCCDR);
+	*phy_reg_data = XGMAC_GET_BITS(mdio_sccdr, MDIO_SCCDR, SDATA);
+
+	return 0;
+}
+
+/*!
+* \brief This sequence is used to write into phy registers
+*/
+int mdio_write(struct mac_prv_data *pdata,
+			 u32 dev_adr,
+			 u32 phy_id,
+			 u32 phy_reg,
+			 u32 phy_reg_data)
+{
+
+	u32 mdio_sccdr = 0;
+	u32 mdio_scar = 0;
+
+	/* wait for any previous MDIO read/write operation to complete */
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MDIO_SCCDR, BUSY) == 0)
+			break;
+	}
+
+	mdio_scar = XGMAC_RGRD(pdata, MDIO_SCAR);
+
+	XGMAC_SET_BITS(mdio_scar, MDIO_SCAR, DA, dev_adr);
+	XGMAC_SET_BITS(mdio_scar, MDIO_SCAR, PA, phy_id);
+	XGMAC_SET_BITS(mdio_scar, MDIO_SCAR, RA, phy_reg);
+
+	XGMAC_RGWR(pdata, MDIO_SCAR, mdio_scar);
+
+	mdio_sccdr = XGMAC_RGRD(pdata, MDIO_SCCDR);
+
+	XGMAC_SET_BITS(mdio_sccdr, MDIO_SCCDR, SDATA, phy_reg_data);
+	XGMAC_SET_BITS(mdio_sccdr, MDIO_SCCDR, BUSY, 1);
+	XGMAC_SET_BITS(mdio_sccdr, MDIO_SCCDR, SADDR, 0);
+	XGMAC_SET_BITS(mdio_sccdr, MDIO_SCCDR, CMD, 1);
+
+	XGMAC_RGWR(pdata, MDIO_SCCDR, mdio_sccdr);
+
+	/* wait for MDIO read operation to complete */
+	while (1) {
+		if (XGMAC_RGRD_BITS(pdata, MDIO_SCCDR, BUSY) == 0)
+			break;
+	}
+
+	return 0;
+}
+
+int xway_mii_read(const char *devname, unsigned char addr,
+		unsigned char reg, unsigned short *value)
+{
+	u32 rd_reg;
+	struct mac_prv_data *pdata = &xgmac_prv_data[1];
+
+	mdio_read(pdata, addr, 0x1f, reg, &rd_reg);
+	*value = rd_reg & 0xffff;
+	return 0;
+}
+
+int xway_mii_write(const char *devname, unsigned char addr,
+		unsigned char reg, unsigned short value)
+{
+	struct mac_prv_data *pdata = &xgmac_prv_data[1];
+
+	LGM_NET_DBG("Writing to addr=0x%02x, reg=0x%02x, value: 0x%02x\n",
+		addr, reg, value);
+	mdio_write(pdata, addr, 0x1f, reg, value);
+	return 0;
+}
+
+static void smdio_write(struct mac_prv_data *pdata, u32 dev_addr,
+				u32 phy_id, u32 phy_pdi, u32 phy_data)
+{
+	mdio_write(pdata,
+		 dev_addr,
+		 phy_id,
+		 SMDIO_BADR,
+		 phy_pdi);
+
+	mdio_write(pdata,
+		 dev_addr,
+		 phy_id,
+		 SMDIO_TOFF,
+		 phy_data);
+}
+
+static u32 smdio_read(struct mac_prv_data *pdata, u32 dev_addr,
+				u32 phy_id, u32 phy_pdi, u32 *phy_data)
+{
+	mdio_write(pdata,
+		 dev_addr,
+		 phy_id,
+		 SMDIO_BADR,
+		 phy_pdi);
+
+	mdio_read(pdata,
+		 dev_addr,
+		 phy_id,
+		 SMDIO_TOFF,
+		 phy_data);
+
+#ifdef CONFIG_DEBUG
+	clause = mdio_get_clause(pdata, 0x1f);
+
+	LGM_NET_DBG("\nOP    \tCL    \tDEVADR\tPHYID \tPHYPDI\tDATA\n");
+	LGM_NET_DBG("============================================\n");
+
+	LGM_NET_DBG("%s\t", "RD");
+	LGM_NET_DBG("%4s\t", clause ? "CL22" : "CL45");
+	LGM_NET_DBG("%6X\t", dev_addr);
+	LGM_NET_DBG("%5X\t", phy_id);
+	LGM_NET_DBG("%6X\t", phy_pdi);
+	LGM_NET_DBG("%4X\t", *phy_data);
+	LGM_NET_DBG("\n");
+#endif
+
+	return *phy_data;
+}
+
+u32 xgmac_mb16_read(struct mac_prv_data *pdata,
+			 u32 dev_adr,
+			 u32 phy_id,
+			 u32 phy_reg,
+			 u32 *phy_data)
+{
+	u32 _mbox_cmd = 0;
+	u32 regaddr = phy_reg;
+
+	u16 addr_high = regaddr >> 16;
+	u16 addr_low = regaddr & 0xFFFF;
+
+	mdio_write(pdata,
+		 MDIO_MMD_VEND1,
+		 phy_id,
+		(VSPEC1_MBOX_ADDRLO/2),
+		 addr_low);
+
+	FIELD_REPLACE(_mbox_cmd, addr_high, VSPEC1_MBOX_CMD_ADDRHI);
+	FIELD_REPLACE(_mbox_cmd, CONST_VSPEC1_MBOX_CMD_CMD_READ, VSPEC1_MBOX_CMD_CMD);
+
+	mdio_write(pdata,
+		 MDIO_MMD_VEND1,
+		phy_id,
+		VSPEC1_MBOX_CMD/2,
+		 _mbox_cmd);
+
+	udelay(100);
+
+	mdio_read(pdata,
+		 MDIO_MMD_VEND1,
+		 phy_id,
+		 VSPEC1_MBOX_DATA/2,
+		 phy_data);
+
+#ifdef LGM_NET_VERBOSE
+	int clause;
+
+	clause = mdio_get_clause(pdata, 0x1f);
+
+	LGM_NET_DBG("\nOP    \tCL    \tDEVADR\tPHYID \tPHYREG\tDATA\n");
+	LGM_NET_DBG("============================================\n");
+
+	LGM_NET_DBG("%s\t", "RD");
+	LGM_NET_DBG("%4s\t", clause ? "CL22" : "CL45");
+	LGM_NET_DBG("%6X\t", dev_adr);
+	LGM_NET_DBG("%5X\t", phy_id);
+	LGM_NET_DBG("%6X\t", regaddr);
+	LGM_NET_DBG("%4X\t", *phy_data);
+	LGM_NET_DBG("\n");
+#endif /* LGM_NET_VERBOSE */
+
+	return *phy_data;
+}
+
+void print_smdio_data(struct mac_prv_data *pdata, u32 devaddr, u32 phy_id,
+			u32 phy_pdi, u32 phy_data)
+{
+#ifdef LGM_NET_VERBOSE
+	u32 clause;
+
+	clause = mdio_get_clause(pdata, 0x1f);
+
+	LGM_NET_DBG("\nOP    \tCL    \tDEVADR\tPHYID \tPHYPDI\tDATA\n");
+        LGM_NET_DBG("============================================\n");
+
+        LGM_NET_DBG("%s\t", "RD");
+        LGM_NET_DBG("%4s\t", clause ? "CL22" : "CL45");
+        LGM_NET_DBG("%6X\t", devaddr);
+        LGM_NET_DBG("%5X\t", phy_id);
+        LGM_NET_DBG("%6X\t", phy_pdi);
+        LGM_NET_DBG("%4X\t", phy_data);
+        LGM_NET_DBG("\n");
+#endif /* LGM_NET_VERBOSE */
+}
+
+static void xgmac_config_std_pkt(struct mac_prv_data *pdata)
+{
+	u32 mac_rcr;
+
+	mac_rcr = XGMAC_RGRD(pdata, MAC_RCR);
+
+	XGMAC_SET_BITS(mac_rcr, MAC_RCR, JE, 0);
+	XGMAC_SET_BITS(mac_rcr, MAC_RCR, WD, 0);
+	XGMAC_SET_BITS(mac_rcr, MAC_RCR, GPSLCE, 0);
+	XGMAC_RGWR_BITS(pdata, MAC_TCR, JD, 0);
+
+	XGMAC_RGWR(pdata, MAC_RCR, mac_rcr);
+}
+
+static int xgmac_set_mac_int(struct mac_prv_data *pdata, u32 val)
+{
+	u32 mac_ier = 0;
+
+	/* Enable Timestamp interrupt */
+	if (val & MASK(MAC_IER, TSIE))
+		XGMAC_SET_BITS(mac_ier, MAC_IER, TSIE, val);
+
+	/* Enable LPI interrupt (EEE) */
+	if (val & MASK(MAC_IER, LPIIE))
+		XGMAC_SET_BITS(mac_ier, MAC_IER, LPIIE, val);
+
+	/* Enable transmit error status interrupt */
+	if (val & MASK(MAC_IER, TXESIE))
+		XGMAC_SET_BITS(mac_ier, MAC_IER, TXESIE, val);
+
+	/* Enable recieve error status interrupt */
+	if (val & MASK(MAC_IER, RXESIE))
+		XGMAC_SET_BITS(mac_ier, MAC_IER, RXESIE, val);
+
+	/* Enable power management interrupt */
+	if (val & MASK(MAC_IER, PMTIE))
+		XGMAC_SET_BITS(mac_ier, MAC_IER, PMTIE, val);
+
+	XGMAC_RGWR(pdata, MAC_IER, mac_ier);
+
+	if (val) {
+		/* Enable all counter interrupts */
+		XGMAC_RGWR_BITS(pdata, MMC_RIER, ALL_INTERRUPTS, 0xffffffff);
+		XGMAC_RGWR_BITS(pdata, MMC_TIER, ALL_INTERRUPTS, 0xffffffff);
+	} else {
+		/* Disable all counter interrupts */
+		XGMAC_RGWR_BITS(pdata, MMC_RIER, ALL_INTERRUPTS, 0);
+		XGMAC_RGWR_BITS(pdata, MMC_TIER, ALL_INTERRUPTS, 0);
+	}
+
+	return 0;
+}
+
+static int xgmac_set_extcfg(struct mac_prv_data *pdata, u32 val)
+{
+	u32 mac_extcfg;
+
+	mac_extcfg = XGMAC_RGRD(pdata, MAC_EXTCFG);
+
+	if (MAC_GET_VAL(mac_extcfg, MAC_EXTCFG, SBDIOEN) != val) {
+		debug("XGMAC %d: MAC Extended CFG SBDIOEN: %s\n",
+				pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+
+		MAC_SET_VAL(mac_extcfg, MAC_EXTCFG, SBDIOEN, val);
+
+		XGMAC_RGWR(pdata, MAC_EXTCFG, mac_extcfg);
+	}
+
+	return 0;
+}
+
+static int xgmac_disable_rx_vlan_filtering(struct mac_prv_data *pdata)
+{
+	if (XGMAC_RGRD_BITS(pdata, MAC_PFR, VTFE) != 0) {
+		debug("XGMAC %d: Disabling VLAN filtering\n", pdata->mac_idx);
+		/* Disable VLAN filtering */
+		XGMAC_RGWR_BITS(pdata, MAC_PFR, VTFE, 0);
+	}
+
+	return 0;
+}
+
+/*	MAC_PFR:
+ *	The MAC Packet Filter register contains the filter controls for
+ *	receiving packets. Some of the controls from
+ *	this register go to the address check block of the MAC which
+ *	performs the first level of address filtering. The
+ *	second level of filtering is performed on the incoming packet
+ *	based on other controls such as Pass Bad
+ *	Packets and Pass Control Packets.
+ *
+ *	PR:
+ *	Promiscuous Mode
+ *	When this bit is set, the Address Filtering module
+ *	passes all incoming packets irrespective of the
+ *	destination or source address. The SA or DA Filter Fails status
+ *	bits of the Rx Status Word are always cleared when PR is set.
+ */
+static int xgmac_set_promiscuous_mode(struct mac_prv_data *pdata, u32 val)
+{
+	if (XGMAC_RGRD_BITS(pdata, MAC_PFR, PR) != val) {
+		debug("XGMAC %d: %s promiscuous mode\n",
+			pdata->mac_idx,  val ? "Entering" : "Leaving");
+		XGMAC_RGWR_BITS(pdata, MAC_PFR, PR, val);
+	}
+
+	/* Hardware will still perform VLAN filtering in promiscuous mode */
+	xgmac_disable_rx_vlan_filtering(pdata);
+
+	return 0;
+}
+
+/*	PM:
+ *	Pass All Multicast
+ *	When this bit is set, it indicates that all received
+ *	packets with a multicast destination address
+ *	(first bit in the destination address field is '1') are passed.
+ *	When this bit is reset, filtering of multicast packet
+ *	depends on HMC bit.
+ */
+static int xgmac_set_all_multicast_mode(struct mac_prv_data *pdata, u32 val)
+{
+	if (XGMAC_RGRD_BITS(pdata, MAC_PFR, PM) != val) {
+		debug("XGMAC %d: %s allmulti mode\n",
+				pdata->mac_idx,
+				val ? "Entering" : "Leaving");
+		XGMAC_RGWR_BITS(pdata, MAC_PFR, PM, val);
+	}
+
+	return 0;
+}
+
+static int gswss_set_speed(u32 mac_idx, u8 speed)
+{
+	u16 phy_mode = 0;
+	u8 speed_msb = 0, speed_lsb = 0;
+
+	phy_mode = GSWSS_RGRD(PHY_MODE(mac_idx));
+
+	speed_msb = GET_BITS(speed, 2, 1);
+	speed_lsb = GET_BITS(speed, 0, 2);
+
+	if (speed == SPEED_10M)
+		debug("\tGSWSS: SPEED\t10 Mbps\n");
+	else if (speed == SPEED_100M)
+		debug("\tGSWSS: SPEED\t100 Mbps\n");
+	else if (speed == SPEED_1G)
+		debug("\tGSWSS: SPEED\t1 Gbps\n");
+	else if (speed == SPEED_10G)
+		debug("\tGSWSS: SPEED\t10 Gbps\n");
+	else if (speed == SPEED_2G5)
+		debug("\tGSWSS: SPEED\t2.5 Gbps\n");
+	else if (speed == SPEED_5G)
+		debug("\tGSWSS: SPEED\t5 Gbps\n");
+	else if (speed == SPEED_FLEX)
+		debug("\tGSWSS: SPEED\tRESERVED\n");
+	else if (speed == SPEED_AUTO)
+		debug("\tGSWSS: SPEED\tautomatic mode detection by GPHY/XPCS link information outputs\n");
+
+	GSWSS_SET_BITS(phy_mode, PHY_MODE, SPEEDMSB, speed_msb);
+	GSWSS_SET_BITS(phy_mode, PHY_MODE, SPEEDLSB, speed_lsb);
+
+	GSWSS_RGWR(PHY_MODE(mac_idx), phy_mode);
+
+	return 0;
+}
+
+static int xgmac_set_xgmii_speed(struct mac_prv_data *pdata)
+{
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TCR);
+
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, USS) != 0)
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, USS, 0);
+
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, SS) != 0) {
+		debug("XGMAC %d: Setting SPEED to XGMII 10G\n",
+			pdata->mac_idx);
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, SS, 0);
+	}
+
+	XGMAC_RGWR(pdata, MAC_TCR, mac_tcr);
+	return 0;
+}
+
+static int gswss_set_2G5_intf(u32 mac_idx, u32 macif)
+{
+	u32 mac_if_cfg;
+	int ret = 0;
+
+	mac_if_cfg = GSWSS_RGRD(MAC_IF_CFG(mac_idx));
+
+	if (macif == XGMAC_GMII) {
+		debug("GSWSS: MACIF Configured to 2.5G with XGMAC_GMII\n");
+		GSWSS_SET_BITS(mac_if_cfg, MAC_IF_CFG, CFG2G5, 0);
+	} else if (macif == XGMAC_XGMII) {
+		debug("GSWSS: MACIF Configured to 2.5G with XGMAC_XGMII\n");
+		udelay(10);
+		GSWSS_SET_BITS(mac_if_cfg, MAC_IF_CFG, CFG2G5, 1);
+	} else {
+		debug("GSWSS: MACIF Configured to 2.5G Wrong Value\n");
+	}
+
+	GSWSS_RGWR(MAC_IF_CFG(mac_idx), mac_if_cfg);
+
+	return ret;
+}
+
+static int xgmac_set_gmii_2500_speed(struct mac_prv_data *pdata)
+{
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TCR);
+
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, USS) != 0)
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, USS, 0);
+
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, SS) != 0x2) {
+		debug("XGMAC %d: Setting SPEED to GMII 2.5G\n",
+			pdata->mac_idx);
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, SS, 0x2);
+	}
+
+	XGMAC_RGWR(pdata, MAC_TCR, mac_tcr);
+	return 0;
+}
+
+static int xgmac_set_xgmii_2500_speed(struct mac_prv_data *pdata)
+{
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TCR);
+
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, USS) != 1)
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, USS, 1);
+
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, SS) != 0x2) {
+		debug("XGMAC %d: Setting SPEED to XGMII 2.5G\n",
+			pdata->mac_idx);
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, SS, 0x2);
+	}
+
+	XGMAC_RGWR(pdata, MAC_TCR, mac_tcr);
+	return 0;
+}
+
+static int gswss_set_1g_intf(u32 mac_idx, u32 macif)
+{
+	u32 mac_if_cfg;
+	int ret = 0;
+
+	mac_if_cfg = GSWSS_RGRD(MAC_IF_CFG(mac_idx));
+
+	if (macif == LMAC_GMII) {
+		debug("GSWSS: MACIF Configured to CFG1G with LMAC_GMII\n");
+		GSWSS_SET_BITS(mac_if_cfg, MAC_IF_CFG, CFG1G, 0);
+	} else if (macif == XGMAC_GMII) {
+		debug("GSWSS: MACIF Configured to CFG1G with XGMAC_GMII\n");
+		GSWSS_SET_BITS(mac_if_cfg, MAC_IF_CFG, CFG1G, 1);
+	} else {
+		debug("GSWSS: MACIF Configured to 1G Wrong Value\n");
+	}
+
+	GSWSS_RGWR(MAC_IF_CFG(mac_idx), mac_if_cfg);
+
+	return ret;
+}
+
+static int xgmac_set_gmii_speed(struct mac_prv_data *pdata)
+{
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TCR);
+
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, USS) != 0)
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, USS, 0);
+
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, SS) != 0x3) {
+		debug("XGMAC %d: Setting SPEED to GMII 1G\n", pdata->mac_idx);
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, SS, 0x3);
+	}
+
+	XGMAC_RGWR(pdata, MAC_TCR, mac_tcr);
+
+	return 0;
+}
+
+static int gswss_set_fe_intf(u32 mac_idx, u32 macif)
+{
+	u32 mac_if_cfg;
+	int ret = 0;
+
+	mac_if_cfg = GSWSS_RGRD(MAC_IF_CFG(mac_idx));
+
+	if (macif == LMAC_MII) {
+		debug("GSWSS: MACIF Configured to CFGFE with LMAC_MII\n");
+		GSWSS_SET_BITS(mac_if_cfg, MAC_IF_CFG, CFGFE, 0);
+	} else if (macif == XGMAC_GMII) {
+		debug("GSWSS: MACIF Configured to CFGFE with XGMAC_GMII\n");
+		GSWSS_SET_BITS(mac_if_cfg, MAC_IF_CFG, CFGFE, 1);
+	} else {
+		debug("GSWSS: MACIF Configured to CFGFE Wrong Value\n");
+	}
+
+	GSWSS_RGWR(MAC_IF_CFG(mac_idx), mac_if_cfg);
+
+	return ret;
+}
+
+static int lmac_set_intf_mode(struct mac_prv_data *pdata, u32 val)
+{
+	u32 mac_ctrl0 = LMAC_RGRD(MAC_CTRL0(pdata->mac_idx));
+
+	if (LMAC_GET_BITS(mac_ctrl0, MAC_CTRL0, GMII) != val) {
+		if (val == 0)
+			debug("LMAC %d: Intf mode set to : AUTO\n",
+				pdata->mac_idx);
+		else if (val == 1)
+			debug("LMAC %d: Intf mode set to : MII"
+				"(10/100/200 Mbps)\n", pdata->mac_idx);
+		else if (val == 2)
+			debug("LMAC %d: Intf mode set to : GMII"
+				"(1000 Mbps)\n", pdata->mac_idx);
+		else if (val == 3)
+			debug("LMAC %d: Intf mode set to : GMII_2G"
+				"(2000 Mbps)\n", pdata->mac_idx);
+
+		LMAC_SET_BITS(mac_ctrl0, MAC_CTRL0, GMII, val);
+
+		LMAC_RGWR(MAC_CTRL0(pdata->mac_idx), mac_ctrl0);
+	}
+
+	return 0;
+}
+
+static int mac_set_mii_if(struct mac_prv_data *pdata, u32 mii_mode)
+{
+	/* Default values for 2.5G is XGMAC_GMII, 1G is LMAC_GMII, */
+	/* FE is LMAC_MII */
+	if (mii_mode == GSW_PORT_HW_XGMII) {
+		gswss_set_1g_intf(pdata->mac_idx, XGMAC_GMII);
+		//gswss_set_fe_intf(pdata->mac_idx, XGMAC_GMII);
+		gswss_set_2G5_intf(pdata->mac_idx, XGMAC_XGMII);
+	} else if (mii_mode == GSW_PORT_HW_MII) {
+		gswss_set_fe_intf(pdata->mac_idx, LMAC_MII);
+	} else if (mii_mode == GSW_PORT_HW_GMII) {
+		gswss_set_1g_intf(pdata->mac_idx, XGMAC_GMII);
+		gswss_set_fe_intf(pdata->mac_idx, XGMAC_GMII);
+		gswss_set_2G5_intf(pdata->mac_idx, XGMAC_GMII);
+	} else if (mii_mode == 5) { /* For Testing LMAC 1G only */
+		gswss_set_1g_intf(pdata->mac_idx, LMAC_GMII);
+	} else {
+		debug("Wrong MII Interface\n");
+	}
+
+	return 0;
+}
+
+static int mac_set_physpeed(struct mac_prv_data *pdata, u32 phy_speed)
+{
+	xgmac_set_extcfg(pdata, 1);
+
+	switch (phy_speed) {
+	case SPEED_MAC_AUTO:
+		gswss_set_speed(pdata->mac_idx, SPEED_AUTO);
+		break;
+
+	case SPEED_XGMAC_10G:
+		gswss_set_speed(pdata->mac_idx, SPEED_10G);
+		xgmac_set_xgmii_speed(pdata);
+		break;
+
+	case SPEED_GMII_25G:
+		gswss_set_speed(pdata->mac_idx, SPEED_2G5);
+		gswss_set_2G5_intf(pdata->mac_idx, XGMAC_GMII);
+		xgmac_set_gmii_2500_speed(pdata);
+		break;
+
+	case SPEED_XGMII_25G:
+		gswss_set_speed(pdata->mac_idx, SPEED_2G5);
+		gswss_set_2G5_intf(pdata->mac_idx, XGMAC_XGMII);
+		xgmac_set_xgmii_2500_speed(pdata);
+		break;
+
+	case SPEED_XGMAC_1G:
+		gswss_set_speed(pdata->mac_idx, SPEED_1G);
+		gswss_set_1g_intf(pdata->mac_idx, XGMAC_GMII);
+		xgmac_set_gmii_speed(pdata);
+		xgmac_set_extcfg(pdata, 1);
+		break;
+
+	case SPEED_XGMAC_10M:
+		gswss_set_speed(pdata->mac_idx, SPEED_10M);
+
+	case SPEED_XGMAC_100M:
+		if (phy_speed != SPEED_XGMAC_10M)
+			gswss_set_speed(pdata->mac_idx, SPEED_100M);
+
+		gswss_set_fe_intf(pdata->mac_idx, XGMAC_GMII);
+		gswss_set_1g_intf(pdata->mac_idx, XGMAC_GMII);
+		xgmac_set_gmii_speed(pdata);
+		break;
+
+	case SPEED_LMAC_10M:
+		gswss_set_speed(pdata->mac_idx, SPEED_10M);
+
+	case SPEED_LMAC_100M:
+		if (phy_speed != SPEED_LMAC_10M)
+			gswss_set_speed(pdata->mac_idx, SPEED_100M);
+
+		gswss_set_fe_intf(pdata->mac_idx, LMAC_MII);
+		lmac_set_intf_mode(pdata, 1);
+		break;
+
+	case SPEED_LMAC_1G:
+		gswss_set_speed(pdata->mac_idx, SPEED_1G);
+		gswss_set_1g_intf(pdata->mac_idx, LMAC_GMII);
+		lmac_set_intf_mode(pdata, 2);
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int gswss_set_linkstatus(u32 mac_idx, u8 linkst)
+{
+	u16 phy_mode = 0;
+
+	phy_mode = GSWSS_RGRD(PHY_MODE(mac_idx));
+
+	if (GSWSS_GET_BITS(phy_mode, PHY_MODE, LINKST) != linkst) {
+		if (linkst == 0)
+			debug("\tGSWSS: LINK STS: Automatic mode detection"
+				" by GPHY/XPCS link information outputs\n");
+		else if (linkst == 1)
+			debug("\tGSWSS: LINK STS: the link"
+				" status is forced UP\n");
+		else if (linkst == 2)
+			debug("\tGSWSS: LINK STS: the link"
+				" status is forced DOWN\n");
+		else if (linkst == 3)
+			debug("\tGSWSS: LINK STS: Reserved\n");
+
+		GSWSS_SET_BITS(phy_mode, PHY_MODE, LINKST, linkst);
+		GSWSS_RGWR(PHY_MODE(mac_idx), phy_mode);
+	}
+
+	return 0;
+}
+
+static int mac_set_linksts(struct mac_prv_data *pdata, u8 linksts)
+{
+	if (linksts == GSW_PORT_LINK_UP)
+		gswss_set_linkstatus(pdata->mac_idx, 1);
+	else if (linksts == GSW_PORT_LINK_DOWN)
+		gswss_set_linkstatus(pdata->mac_idx, 2);
+	else
+		gswss_set_linkstatus(pdata->mac_idx, 0); // Auto
+
+	return 0;
+}
+
+static int gswss_set_duplex_mode(u32 mac_idx, u32 val)
+{
+	u16 phy_mode = 0;
+
+	phy_mode = GSWSS_RGRD(PHY_MODE(mac_idx));
+
+	if (GSWSS_GET_BITS(phy_mode, PHY_MODE, FDUP) != val) {
+
+		if (val == MAC_AUTO_DPLX)
+			debug("\tGSWSS: Duplex mode set: Automatic"
+				" mode detection by GPHY/XPCS link"
+				" information outputs\n");
+		else if (val == MAC_FULL_DPLX)
+			debug("\tGSWSS: Duplex mode set: Full Duplex\n");
+		else if (val == MAC_RES_DPLX)
+			debug("\tGSWSS: Duplex mode set: Reserved\n");
+		else if (val == MAC_HALF_DPLX)
+			debug("\tGSWSS: Duplex mode set: Half Duplex\n");
+
+		GSWSS_SET_BITS(phy_mode, PHY_MODE, FDUP, val);
+		GSWSS_RGWR(PHY_MODE(mac_idx), phy_mode);
+	}
+
+	return 0;
+}
+
+static int lmac_set_duplex_mode(struct mac_prv_data *pdata, u32 val)
+{
+	u32 mac_ctrl0 = LMAC_RGRD(MAC_CTRL0(pdata->mac_idx));
+
+	if (LMAC_GET_BITS(mac_ctrl0, MAC_CTRL0, FDUP) != val) {
+		if (val == 0)
+			debug("LMAC %d: FDUP mode set to : AUTO\n",
+				pdata->mac_idx);
+		else if (val == 1)
+			debug("LMAC %d: FDUP mode set to : Full Duplex Mode\n",
+				pdata->mac_idx);
+		else if (val == 2)
+			debug("LMAC %d: FDUP mode set to : Reserved\n",
+				pdata->mac_idx);
+		else if (val == 3)
+			debug("LMAC %d: FDUP mode set to : Half Duplex Mode\n",
+				pdata->mac_idx);
+
+		LMAC_SET_BITS(mac_ctrl0, MAC_CTRL0, FDUP, val);
+		LMAC_RGWR(MAC_CTRL0(pdata->mac_idx), mac_ctrl0);
+	}
+
+	return 0;
+}
+
+static int mac_set_duplex(struct mac_prv_data *pdata, u32 val)
+{
+	if (val == GSW_DUPLEX_FULL)
+		val = MAC_FULL_DPLX;
+	else if (val == GSW_DUPLEX_HALF)
+		val = MAC_HALF_DPLX;
+	else
+		val = MAC_AUTO_DPLX;
+
+	gswss_set_duplex_mode(pdata->mac_idx, val);
+	lmac_set_duplex_mode(pdata, val);
+
+	return 0;
+}
+
+/*	LPIATE: LPI Auto Timer Enable
+ *	This bit controls the automatic entry of the
+ *	MAC Transmitter into and exit out
+ *	of the LPI state. When LPIATE, LPITXA and
+ *	LPITXEN bits are set, the MAC
+ *	Transmitter will enter LPI state only when the complete MAC
+ *	TX data path is IDLE for a period indicated by
+ *	the MAC_LPI_Auto_Entry_Timer register.
+ *	After entering LPI state, if the data path becomes
+ *	non-IDLE (due to a new packet being accepted
+ *	for transmission), the Transmitter will exit LPI state
+ *	but will not clear LPITXEN bit. This enables the re-entry
+ *	into LPI state when it is IDLE again.
+ *	When LPIATE is 0, the LPI Auto timer is disabled and MAC
+ *	Transmitter will enter LPI state based on the settings
+ *	of LPITXA and LPITXEN bit descriptions.
+ *
+ *	LPITXA: LPI Tx Automate
+ *	This bit controls the behavior of the MAC when it is
+ *	entering or coming out of the LPI mode on the Transmit side.
+ *	This bit is not functional in the XGMAC-CORE configurations in which
+ *	the Tx clock gating is done during the LPI mode.
+ *	If the LPITXA and LPITXEN bits are set to 1, the
+ *	MAC enters the LPI mode only after all outstanding
+ *	packets (in the core) and pending packets (in the
+ *	application interface) have been transmitted.
+ *	The MAC comes out of the LPI mode when the application
+ *	presents any packet for transmission or the application issues
+ *	a Tx FIFO Flush command. In addition, the MAC
+ *	automatically clears the LPITXEN bit when it exits
+ *	the LPI state. If Tx FIFO Flush is set in the
+ *	FTQ bit of MTL_TxQ0_Operation_Mode register, when
+ *	the MAC is in the LPI mode, it exits the LPI mode.
+ *	When this bit is 0, the LPITXEN bit directly controls
+ *	behavior of the MAC when it is entering or coming out of the LPI mode.
+*/
+static int xgmac_set_mac_lpitx(struct mac_prv_data *pdata, u32 val)
+{
+	u32 lpiate;
+
+	lpiate = XGMAC_RGRD(pdata, MAC_LPICSR);
+
+	if (XGMAC_GET_BITS(lpiate, MAC_LPICSR, LPIATE) != val) {
+		debug("XGMAC %d: LPIATE: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		XGMAC_SET_BITS(lpiate, MAC_LPICSR, LPIATE, val);
+	}
+
+	if (XGMAC_GET_BITS(lpiate, MAC_LPICSR, LPITXA) != val) {
+		debug("XGMAC %d: LPITXA: %s\n",
+			pdata->mac_idx, val ? "ENABLED" : "DISABLED");
+		XGMAC_SET_BITS(lpiate, MAC_LPICSR, LPITXA, val);
+	}
+
+	XGMAC_RGWR(pdata, MAC_LPICSR, lpiate);
+
+	return 0;
+}
+
+static int xgmac_powerup(struct mac_prv_data *pdata)
+{
+	u32 mac_tcr = XGMAC_RGRD(pdata, MAC_TCR);
+	u32 mac_rcr = XGMAC_RGRD(pdata, MAC_RCR);
+	u32 mac_pfr = XGMAC_RGRD(pdata, MAC_PFR);
+
+	/* Enable MAC Tx */
+	if (XGMAC_GET_BITS(mac_tcr, MAC_TCR, TE) != 1) {
+		debug("XGMAC %d: MAC TX: ENABLED\n", pdata->mac_idx);
+		XGMAC_SET_BITS(mac_tcr, MAC_TCR, TE, 1);
+		XGMAC_RGWR(pdata, MAC_TCR, mac_tcr);
+	}
+
+	/* Enable MAC Rx */
+	if (XGMAC_GET_BITS(mac_rcr, MAC_RCR, RE) != 1) {
+		debug("XGMAC %d: MAC RX: ENABLED\n", pdata->mac_idx);
+		XGMAC_SET_BITS(mac_rcr, MAC_RCR, RE, 1);
+		XGMAC_RGWR(pdata, MAC_RCR, mac_rcr);
+	}
+
+	/* Enable MAC Filter Rx All */
+	if (XGMAC_GET_BITS(mac_pfr, MAC_PFR, RA) != 1) {
+		debug("XGMAC %d: MAC Filter Recieve All: ENABLED\n",
+			pdata->mac_idx);
+		XGMAC_SET_BITS(mac_pfr, MAC_PFR, RA, 1);
+		XGMAC_RGWR(pdata, MAC_PFR, mac_pfr);
+	}
+
+	return 0;
+}
+
+int gswss_xgmac_reset(struct mac_prv_data *pdata, u32 reset)
+{
+	u32 mac_if_cfg;
+
+	mac_if_cfg = GSWSS_RGRD(MAC_IF_CFG(pdata->mac_idx));
+
+	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, XGMAC_RES, reset);
+
+	debug("GSWSS: Resetting XGMAC %d Module\n", pdata->mac_idx);
+
+	GSWSS_RGWR(MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return 0;
+}
+
+int gswss_lmac_reset(struct mac_prv_data *pdata, u32 reset)
+{
+	u32 mac_if_cfg;
+
+	mac_if_cfg = GSWSS_RGRD(MAC_IF_CFG(pdata->mac_idx));
+
+	MAC_SET_VAL(mac_if_cfg, MAC_IF_CFG, LMAC_RES, reset);
+
+	debug("GSWSS: Resetting LMAC %d Module\n", pdata->mac_idx);
+
+	GSWSS_RGWR(MAC_IF_CFG(pdata->mac_idx), mac_if_cfg);
+
+	return 0;
+}
+
+static int lightning_mountain_mac_init(struct udevice *dev,
+				struct mac_prv_data *pdata)
+{
+	u32 reg;
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+	/* set mtu */
+	reg = readl(priv->gswip_oss_base + MAC2_MTU_CFG + (pdata->mac_idx * 0x100));
+	if (reg != pdata->mtu)
+		writel(pdata->mtu,
+			priv->gswip_oss_base + MAC2_MTU_CFG + (pdata->mac_idx * 0x100));
+
+	xgmac_config_std_pkt(pdata);
+
+	/* Enable MAC interrupts */
+	xgmac_set_mac_int(pdata, pdata->enable_mac_int);
+
+	/* Configure RWK filter frames */
+	/* populate_filter_frames(pdata); */
+
+	xgmac_set_extcfg(pdata, 1);
+
+	/* Program Promisc mode and All multicast mode */
+	xgmac_set_promiscuous_mode(pdata, pdata->promisc_mode);
+
+	/* Program All multicast mode */
+	xgmac_set_all_multicast_mode(pdata, pdata->all_mcast_mode);
+
+	/* Configure MAC Speed to 10/2.5/1 G */
+	//mac_set_physpeed(pdata, pdata->phy_speed);
+	/* Configure MII to XGMAC by default */
+	mac_set_mii_if(pdata, GSW_PORT_HW_XGMII); /* xgmii */
+
+	/* Set the link status as UP */
+#if 0	/* TODO: HAPS SPEED */
+	/* if (pdata->phy_speed == SPEED_MAC_AUTO) */
+	if (pdata->phy_speed == SPEED_MAC_AUTO)
+		mac_set_linksts(pdata, GSW_PORT_LINK_AUTO); /* auto */
+	else
+#else
+	mac_set_linksts(pdata, GSW_PORT_LINK_UP); /* link-up*/
+#endif
+
+	/* Set the Duplex as Full Duplex */
+#if 0   /* HAPS SPEED */
+	if (pdata->phy_speed == SPEED_MAC_AUTO)
+		mac_set_duplex(pdata, GSW_DUPLEX_AUTO); /* auto */
+	else
+#else
+
+#if defined(CONFIG_LAN_HSIO_R_SGMII_2500BASEX) || defined(CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET)
+	mac_set_duplex(pdata, GSW_DUPLEX_FULL);
+#else
+	mac_set_duplex(pdata, GSW_DUPLEX_AUTO); /* auto */
+#endif
+#endif
+
+	/* Set LPI TX Automate and LPI Auto Timer Enable
+	 * to overcome packet-drop issue
+	 */
+	xgmac_set_mac_lpitx(pdata, 1);
+
+	/* Configure MAC Speed to 10/2.5/1 G */
+	/* mac_set_physpeed(pdata, pdata->phy_speed); */
+#if defined(CONFIG_LAN_HSIO_R_SGMII_2500BASEX) || defined(CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET)
+	mac_set_physpeed(pdata, SPEED_GMII_25G);
+#else
+	mac_set_physpeed(pdata, SPEED_MAC_AUTO); /* auto */
+#endif
+	/* don't enable this first for P34X ports */
+	if (!(pdata->mac_idx >= 3 && pdata->mac_idx <= 6))
+		/* POWER ON MAC Tx/Rx */
+		xgmac_powerup(pdata);
+
+#if defined(CONFIG_WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G) || defined(CONFIG_XPCS5_USXGMII_RTL8261)
+	if (pdata->mac_idx == 2) {
+    		GSWSS_RGWR(ANEG_EEE_2, 0x3);
+	}
+#endif
+
+	return 0;
+}
+
+static int lightning_mountain_mac_config(struct udevice *dev)
+{
+	int i, ret;
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+
+	for (i = MAC_START; i < MAC_LAST; i++) {
+		ret = lightning_mountain_mac_init(dev, &pdata[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int lightning_mountain_switch_init(struct udevice *dev)
+{
+	int i;
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+	priv->tx_num = 0;
+	priv->rx_num = 0;
+
+	/* configure rx */
+	mxl_dma_w32_mask(0, (1 << DMA_V31_CTRL_RST_POS),
+			(priv->dma_rx_base) + DMA_V31_CTRL);
+	writel(RX_PORT, priv->dma_rx_base + DMA_V31_PS);
+	writel(0x1017, priv->dma_rx_base + DMA_V31_PCTRL);
+	writel(RX_CHAN, priv->dma_rx_base + DMA_V31_CS);
+	writel(0x2, priv->dma_rx_base + DMA_V31_CCTRL);
+
+	while (readl(priv->dma_rx_base + DMA_V31_CCTRL) & 0x2)
+		;
+
+	writel(0x80000020, priv->dma_rx_base + DMA_V31_CPOLL);
+	writel((u32)priv->rx_des_ring, priv->dma_rx_base + DMA_V31_CDBA);
+	writel(NUM_RX_DESC, priv->dma_rx_base + DMA_V31_CDLEN);
+	writel(0, priv->dma_rx_base + DMA_V31_CIE);
+	writel(0x10000, priv->dma_rx_base + DMA_V31_CCTRL);
+
+	mxl_dma_w32_mask((1 << (RX_CHAN & 0x1f)), 0,
+			(priv->dma_rx_base) + DMA_V31_IRNEN);
+
+	/* configure tx */
+	mxl_dma_w32_mask(0, (1 << DMA_V31_CTRL_RST_POS),
+			(priv->dma_tx_base) + DMA_V31_CTRL);
+	writel(TX_PORT, priv->dma_tx_base + DMA_V31_PS);
+	writel(0x1017, priv->dma_tx_base + DMA_V31_PCTRL);
+	writel(TX_CHAN, priv->dma_tx_base + DMA_V31_CS);
+	writel(0x2, priv->dma_tx_base + DMA_V31_CCTRL);
+
+	while (readl(priv->dma_tx_base + DMA_V31_CCTRL) & 0x2)
+		;
+
+	writel(0x80000020, priv->dma_tx_base + DMA_V31_CPOLL);
+	writel((u32)priv->tx_des_ring, priv->dma_tx_base + DMA_V31_CDBA);
+	writel(NUM_TX_DESC, priv->dma_tx_base + DMA_V31_CDLEN);
+	writel(0, priv->dma_tx_base + DMA_V31_CIE);
+	writel(0x10100, priv->dma_tx_base + DMA_V31_CCTRL);
+	writel(0x80040200, priv->dma_tx_base + DMA_V31_CTRL);
+
+	for (i = 0; i < NUM_TX_DESC; i++) {
+		_dma_tx_descriptor_t *tx_desc =
+			(_dma_tx_descriptor_t *)(&priv->tx_des_ring[i]);
+		memset(tx_desc, 0, sizeof(priv->tx_des_ring[0]));
+		dma_sync_cache_range((void *)tx_desc,
+				sizeof(_dma_tx_descriptor_t));
+	}
+
+	for (i = 0; i < NUM_RX_DESC; i++) {
+		_dma_rx_descriptor_t *rx_desc =
+			(_dma_rx_descriptor_t *)(&priv->rx_des_ring[i]);
+		rx_desc->proto = 0;
+		rx_desc->DW1.all = 0;
+		rx_desc->DW3.field.c = 0;
+		rx_desc->DW3.field.sp = 0;
+		rx_desc->DW3.field.haddr = 0;
+		/* PMAC 1 */
+		rx_desc->DW1.field.port = priv->pmac_id;
+		rx_desc->DW3.field.own = 0;
+		rx_desc->DW3.field.datalen = (u16)PKTSIZE_ALIGN;
+		rx_desc->laddr = (u32)net_rx_packets[i];
+		dma_sync_cache_range((void *)(&priv->rx_des_ring[i]),
+				sizeof(_dma_rx_descriptor_t));
+	}
+	kick_start = 1;
+
+	/* give a little delay for cache flush to complete */
+	udelay(200);
+
+	/* switch on rx chan */
+	mxl_dma_w32(RX_CHAN, (priv->dma_rx_base) + DMA_V31_CS);
+	mxl_dma_w32_mask(0, (1 << DMA_V31_CCTRL_ON_OFF_POS),
+			(priv->dma_rx_base) + DMA_V31_CCTRL);
+
+	return 0;
+}
+
+static void lightning_mountain_switch_halt(struct udevice *dev)
+{
+	int i = 0;
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return;
+
+	debug("halting switch .... \n");
+	mxl_dma_w32(RX_CHAN, (priv->dma_rx_base) + DMA_V31_CS);
+	mxl_dma_w32_mask((1 << DMA_V31_CCTRL_ON_OFF_POS), 0,
+			(priv->dma_rx_base) + DMA_V31_CCTRL);
+
+	while ((readl(priv->dma_rx_base + DMA_V31_CCTRL) & 0x1)) {
+		i++;
+		if (i > 10000) {
+			debug("failed resetting rx chan\n");
+			break;
+		}
+	}
+
+	i = 0;
+
+	/* turn off both tx/rx chan */
+	mxl_dma_w32(TX_CHAN, (priv->dma_tx_base) + DMA_V31_CS);
+	mxl_dma_w32_mask((1 << DMA_V31_CCTRL_ON_OFF_POS), 0,
+			(priv->dma_tx_base) +  DMA_V31_CCTRL);
+
+	while ((readl(priv->dma_tx_base + DMA_V31_CCTRL) & 0x1)) {
+		i++;
+		if (i > 10000) {
+			printf("failed resetting tx chan\n");
+			break;
+		}
+	}
+}
+
+static int lightning_mountain_switch_send(struct udevice *dev,
+			void *packet, int length)
+{
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	int i, res = -1;
+	_dma_tx_descriptor_t *tx_desc;
+
+	if (!priv)
+		return -EINVAL;
+
+	tx_desc = (_dma_tx_descriptor_t *)(&priv->tx_des_ring[priv->tx_num]);
+
+	dma_sync_cache_range((void *)tx_desc, sizeof(_dma_tx_descriptor_t));
+
+	if (length <= 0) {
+		printf("%s: bad packet size: %d\n", dev->name, length);
+		goto Done;
+	}
+
+	for (i = 0; tx_desc->DW3.field.own == 1; i++) {
+		if (i >= TOUT_LOOP) {
+			printf("NO Tx Descriptor...");
+			goto Done;
+		}
+		dma_sync_cache_range((void *)tx_desc,
+			sizeof(_dma_tx_descriptor_t));
+	}
+
+	/* serial_putc('s'); */
+	tx_desc->proto = 0;
+	tx_desc->DW1.all = 0;
+	/* PMAC 1 port */
+	tx_desc->DW1.field.port = priv->pmac_id;
+	tx_desc->DW3.all = 0;
+	tx_desc->DW3.field.sop = 1;
+	tx_desc->DW3.field.eop = 1;
+	tx_desc->DW3.field.c = 0;
+	if (length < 60)
+		tx_desc->DW3.field.datalen = 60;
+	else
+		tx_desc->DW3.field.datalen = (u16) length;
+
+	tx_desc->laddr = (u32) packet;
+	tx_desc->DW3.field.own = 1;
+	wmb();
+
+	res = length;
+	priv->tx_num++;
+	if (priv->tx_num == NUM_TX_DESC)
+		priv->tx_num = 0;
+
+	dma_sync_cache_range((void *)packet, length);
+	dma_sync_cache_range((void *)tx_desc, sizeof(_dma_tx_descriptor_t));
+
+	/* switch on tx chan */
+	mxl_dma_w32(TX_CHAN, (priv->dma_tx_base) + DMA_V31_CS);
+	mxl_dma_w32_mask(0, (1 << DMA_V31_CCTRL_ON_OFF_POS),
+			(priv->dma_tx_base) +  DMA_V31_CCTRL);
+
+Done:
+	return res;
+}
+
+static int lightning_mountain_switch_recv(struct udevice *dev,
+					int flags, uchar **packetp)
+{
+
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	int length = 0;
+	u32 timeout = 500000;
+	_dma_rx_descriptor_t *rx_desc, *rx_desc_rest;
+	u32 i, round_seq;
+
+	if (!priv)
+		return -EINVAL;
+
+	rx_desc = (_dma_rx_descriptor_t *)(&priv->rx_des_ring[priv->rx_num]);
+	dma_sync_cache_range((void *)rx_desc, sizeof(_dma_rx_descriptor_t));
+
+	if (kick_start == 1) {
+		/*set buf0 own = 1 to kick start buf0 dma transfer.*/
+		rx_desc->DW3.field.own = 1;
+
+		for (i = 1; i < NUM_RX_DESC; i++) {
+			rx_desc_rest = (_dma_rx_descriptor_t *)(&priv->rx_des_ring[priv->rx_num + i]);
+			dma_sync_cache_range((void *)rx_desc_rest, sizeof(_dma_rx_descriptor_t));
+			/*set buf1,2,3 own = 1 to kick start buf1,2,3 dma transfer.*/
+			rx_desc_rest->DW3.field.own = 1;
+		}
+	}
+	wmb();
+
+	while (rx_desc->DW3.field.c == 0 ||
+		rx_desc->DW3.field.own == 1) {
+		if (timeout <= 0)
+			break;
+		timeout--;
+	}
+
+	if (timeout <= 0) {
+		return -EAGAIN;
+	}
+
+	length = rx_desc->DW3.field.datalen;
+	if (length) {
+		dma_sync_cache_range((void *)net_rx_packets[priv->rx_num], length);
+		*packetp = (uchar *)net_rx_packets[priv->rx_num];
+	} else {
+		printf("Zero length rcv!\n");
+	}
+
+	if (kick_start == 1) {
+		/*set kick_start = 0 to prevent kick start operations been executed again.*/
+		kick_start = 0;
+	} else {
+		/*reset previous descriptor parameters and set its own = 1 */
+		round_seq = (priv->rx_num + NUM_RX_DESC - 1) % NUM_RX_DESC;
+		rx_desc_rest = (_dma_rx_descriptor_t *)(&priv->rx_des_ring[round_seq]);
+		dma_sync_cache_range((void *)rx_desc_rest, sizeof(_dma_rx_descriptor_t));
+
+		rx_desc_rest->DW3.all = 0;
+		rx_desc_rest->DW3.field.sop = 0;
+		rx_desc_rest->DW3.field.eop = 0;
+		rx_desc_rest->DW3.field.c = 0;
+		rx_desc_rest->DW3.field.datalen = PKTSIZE_ALIGN;
+		rx_desc_rest->DW3.field.own = 1;
+		/* PMAC 1 */
+		rx_desc_rest->DW1.field.port = priv->pmac_id;
+	}
+	wmb();
+
+	priv->rx_num++;
+
+	if (priv->rx_num == NUM_RX_DESC)
+		priv->rx_num = 0;
+
+
+	return length;
+}
+
+static int lightning_mountain_dma_init(struct udevice *dev)
+{
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+	/* must provide aligned address */
+	priv->rx_des_ring = memalign(64,
+			sizeof(_dma_rx_descriptor_t) * NUM_RX_DESC);
+	priv->tx_des_ring = memalign(64,
+			sizeof(_dma_tx_descriptor_t) * NUM_TX_DESC);
+
+	/* configure rx */
+	mxl_dma_w32_mask(0, (1 << DMA_V31_CTRL_RST_POS),
+			(priv->dma_rx_base) + DMA_V31_CTRL);
+
+	writel(RX_PORT, priv->dma_rx_base + DMA_V31_PS);
+	/* Burst 16, ENDIAN = 0 */
+	writel(0x1017, priv->dma_rx_base + DMA_V31_PCTRL);
+	writel(RX_CHAN, priv->dma_rx_base + DMA_V31_CS);
+	writel(0x80000180, priv->dma_rx_base + DMA_V31_CDBA);
+	writel(NUM_RX_DESC, priv->dma_rx_base + DMA_V31_CDLEN);
+	writel(0, priv->dma_rx_base + DMA_V31_CIE);
+	writel(0x10000, priv->dma_rx_base + DMA_V31_CCTRL);
+
+	mxl_dma_w32_mask((1 << (RX_CHAN & 0x1f)), 0,
+			(priv->dma_rx_base) + DMA_V31_IRNEN);
+	mxl_dma_w32_mask(0, (1 << (RX_CHAN & 0x1f)),
+			(priv->dma_rx_base) + DMA_V31_IRNCR);
+
+	/* configure tx */
+	mxl_dma_w32_mask(0, (1 << DMA_V31_CTRL_RST_POS),
+			(priv->dma_tx_base) + DMA_V31_CTRL);
+
+	writel(TX_PORT, priv->dma_tx_base + DMA_V31_PS);
+	/* Burst 16, ENDIAN = 0 */
+	writel(0x1017, priv->dma_tx_base + DMA_V31_PCTRL);
+	writel(TX_CHAN, priv->dma_tx_base + DMA_V31_CS);
+	writel(0x80000180, priv->dma_tx_base + DMA_V31_CPOLL);
+	writel((u32)priv->tx_des_ring, priv->dma_tx_base + DMA_V31_CDBA);
+	writel(NUM_TX_DESC, priv->dma_tx_base + DMA_V31_CDLEN);
+	writel(0, priv->dma_tx_base + DMA_V31_CIE);
+	writel(0x10100, priv->dma_tx_base + DMA_V31_CCTRL);
+
+	mxl_dma_w32_mask((1 << (TX_CHAN & 0x1f)), 0,
+			(priv->dma_tx_base) + DMA_V31_IRNEN);
+	mxl_dma_w32_mask(0, (1 << (TX_CHAN & 0x1f)),
+			(priv->dma_tx_base) + DMA_V31_IRNCR);
+	return 0;
+}
+
+void __usxgmii_usra_reset(struct mac_prv_data *pdata)
+{
+	u32 addr = 0x0;
+	u32 read_val = 0x0;
+
+	LGM_NET_DBG("### USRA RESET PORT 0 ###\n");
+	addr = 0x38000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_DIG_CTRL1 before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 10);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	LGM_NET_DBG("CSR_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+
+	LGM_NET_DBG("### USRA RESET PORT 1 ###\n");
+	addr = 0x1a8000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_1_DIG_CTRL1 before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 5);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_1_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	LGM_NET_DBG("CSR_MII_1_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8010));
+
+	LGM_NET_DBG("### USRA RESET PORT 2 ###\n");
+	addr = 0x1b8000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_DIG_CTRL1 before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 5);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_2_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	LGM_NET_DBG("CSR_MII_2_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8010));
+
+	LGM_NET_DBG("### USRA RESET PORT 3 ###\n");
+	addr = 0x1c8000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_DIG_CTRL1 before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 5);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_3_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	LGM_NET_DBG("CSR_MII_3_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8010));
+}
+
+void __usxgmii_vr_reset(struct mac_prv_data *pdata)
+{
+	u32 addr = 0x0;
+	u32 read_val = 0x0;
+	int i = 0;
+
+	LGM_NET_DBG("### VR_SOFT_RESET ###\n");
+	addr = 0x38000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_DIG_CTRL1 before: 0x%x\n",read_val);
+	read_val = read_val & 0xFFFF;
+	read_val = read_val | (0x1<<15);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_DIG_CTRL1 after: 0x%x\n", __usxgmii_fabric_rd(pdata, addr));
+
+	for (i = 0; i < 1000; i++){
+		if (__usxgmii_fabric_rd(pdata, 0x1809b)&BIT(0))  //check INIT_DN
+				break;
+		udelay(10);
+	}
+
+	for (i = 0; i < 5000; i++) {
+		if (!(__usxgmii_fabric_rd(pdata, addr) & BIT(15))) {
+				break;
+		}
+		udelay(10);
+	}
+
+	if (i >= 5000)
+		LGM_NET_DBG("XPCS VR RESET fail\n");
+	else
+		LGM_NET_DBG("XPCS VR RESET success\n");
+
+	for (i = 0; i < 1000; i++){
+		read_val = __usxgmii_fabric_rd(pdata, 0x38010);
+		read_val = read_val >> 2;
+		read_val &= 0x7;
+		if (read_val == 0x4) {
+			LGM_NET_DBG("wait_for_powerup_xpcs5...success\n");
+			break;
+		}
+		udelay(10);
+	}
+}
+
+void __gpy2xx_fabric_rdadr(struct mac_prv_data *pdata, u32 regaddr)
+{
+	u16 base_low, base_hi;
+	u32 phy_pdi, phy_data;
+
+	base_hi = (regaddr >> 16) & 0xFFFF;
+	base_low = (regaddr & 0xFFFF);
+
+	/* Fabric indirect access address High register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB48); //FABRIC_PDI_ADDRH
+	phy_data = base_hi;
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+
+	/* Fabric indirect access address Low register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB44); //FABRIC_PDI_ADDRL
+	phy_data = base_low;
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+
+	/* Fabric indirect access Access Control register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB40); //FABRIC_PDI_CTRL
+	phy_data = 0x1;
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+}
+
+void __gpy2xx_fabric_wradr(struct mac_prv_data *pdata, u32 regaddr)
+{
+	u16 base_low, base_hi;
+	u32 phy_pdi, phy_data;
+
+	base_hi = (regaddr >> 16) & 0xFFFF;
+	base_low = (regaddr & 0xFFFF);
+
+	/* Fabric indirect access Access Control register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB40); //FABRIC_PDI_CTRL
+	phy_data = 0x2;
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+
+	/* Fabric indirect access address High register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB48); //FABRIC_PDI_ADDRH
+	phy_data = base_hi;
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+
+	/* Fabric indirect access address Low register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB44); //FABRIC_PDI_ADDRL
+	phy_data = base_low;
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+}
+
+int __usxgmii_fabric_rd(struct mac_prv_data *pdata, u32 regaddr)
+{
+	u32 address_base, address_offset;
+	u32 data_high, data_low;
+	u32 usxgmii_addr;
+	u32 phy_pdi, phy_data;
+
+	address_base = regaddr >> 8;
+	address_offset = regaddr & 0xFF;
+
+	/* Set the USXGMII base address to read */
+	__gpy2xx_fabric_wradr(pdata, 0x00D3DFFC); //USXGMII_PDI_BASEADRR
+
+	/* boot time optimization */
+	/* mdelay(10); */
+
+	/* Set the address_base */
+	/* Fabric indirect access address High register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB50); //FABRIC_PDI_DATAH
+	phy_data = (address_base >> 16);
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+
+	/* Fabric indirect access address Low register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB4C); //FABRIC_PDI_DATAL
+	phy_data = (address_base & 0xFFFF);
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+
+	/* Set the USXGMII PDI indirect address */
+	usxgmii_addr = (0xd3dc00 + (4 * address_offset));
+	__gpy2xx_fabric_rdadr(pdata, usxgmii_addr); //USXGMII_PDI_INDIRECT
+	/* boot time optimization */
+	/* mdelay(10); */
+
+	/* Fabric indirect access address High register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB50); //FABRIC_PDI_DATAH
+	smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data);
+	data_high = phy_data;
+
+	/* Fabric indirect access address Low register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB4C); //FABRIC_PDI_DATAL
+	smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data);
+	data_low = phy_data;
+
+	return ((data_high << 16) | data_low);
+}
+
+int __usxgmii_phy_rd(struct mac_prv_data *pdata, u32 phy_address)
+{
+	u32 addr = 0x0;
+	u32 read_val = 0x1;
+
+	addr = 0x180a0; //VR_XS_PMA_SNPS_CR_CTRL
+	while (read_val != 0){
+		//printf("Check if bit 0 VR_XS_PMA_SNPS_CR_CTRL is 0\n");
+		read_val = __usxgmii_fabric_rd(pdata, addr);
+		read_val = read_val & 0x1;
+	}
+	//printf("write Phy address to VR_XS_PMA_SNPS_CR_ADDR\n");
+	addr = 0x180a1; //VR_XS_PMA_SNPS_CR_ADDR
+	__usxgmii_fabric_wr(pdata, addr, phy_address);
+
+	//printf("write 0 to bit 1 of VR_XS_PMA_SNPS_CR_CTRL\n");
+	addr = 0x180a0; //VR_XS_PMA_SNPS_CR_CTRL
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	read_val = read_val & 0xFFFFFFFD;
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+
+	//printf("write 1 to bit 0 of VR_XS_PMA_SNPS_CR_CTRL\n");
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	read_val = read_val | 0x1;
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+
+	read_val = 0x1;
+	while (read_val != 0){
+		//printf("Check if bit 0 VR_XS_PMA_SNPS_CR_CTRL is 0\n");
+		read_val = __usxgmii_fabric_rd(pdata, addr);
+		read_val = read_val & 0x1;
+	}
+
+	addr = 0x180a2; //VR_XS_PMA_SNPS_CR_DATA
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+
+	return read_val;
+}
+
+void __usxgmii_fabric_wr(struct mac_prv_data *pdata, u32 regaddr, u32 data)
+{
+	u32 address_base, address_offset;
+	u32 usxgmii_addr;
+	u32 phy_pdi, phy_data;
+
+	address_base = regaddr >> 8;
+	address_offset = regaddr & 0xFF;
+
+	/* Set the USXGMII base address to write */
+	__gpy2xx_fabric_wradr(pdata, 0x00D3DFFC); //USXGMII_PDI_BASEADRR
+
+	/* boot time optimization */
+	/*mdelay(100); */
+
+	/* Set the address_base */
+	/* Fabric indirect access address High register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB50); //FABRIC_PDI_DATAH
+	phy_data = (address_base >> 16);
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+
+	/* Fabric indirect access address Low register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB4C); //FABRIC_PDI_DATAL
+	phy_data = (address_base & 0xFFFF);
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+
+	/* Set the USXGMII PDI indirect address */
+	usxgmii_addr = (0xd3dc00 + (4 * address_offset));
+	__gpy2xx_fabric_wradr(pdata, usxgmii_addr); //USXGMII_PDI_INDIRECT
+	/* boot time optimization */
+	/* mdelay(100); */
+
+	/* Set the data */
+	/* Fabric indirect access address High register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB50); //FABRIC_PDI_DATAH
+	phy_data = (data >> 16);
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+
+	/* Fabric indirect access address Low register */
+	phy_pdi = AHB_TO_PDI(0x00D3DB4C); //FABRIC_PDI_DATAL
+	phy_data = (data & 0xFFFF);
+	smdio_write(pdata, 0x0, 0x1f, phy_pdi, phy_data);
+
+}
+
+void __usxgmii_phy_wr(struct mac_prv_data *pdata,
+			u32 phy_address, u32 phy_data)
+{
+	u32 addr = 0x0;
+	u32 read_val = 0x1;
+
+	addr = 0x180a0; //VR_XS_PMA_SNPS_CR_CTRL
+	while (read_val != 0){
+		LGM_NET_DBG("Check if bit 0 VR_XS_PMA_SNPS_CR_CTRL is 0\n");
+		read_val = __usxgmii_fabric_rd(pdata, addr);
+		read_val = read_val & 0x1;
+	}
+	LGM_NET_DBG("write Phy address to VR_XS_PMA_SNPS_CR_ADDR\n");
+	addr = 0x180a1; //VR_XS_PMA_SNPS_CR_ADDR
+	__usxgmii_fabric_wr(pdata, addr, phy_address);
+
+	LGM_NET_DBG("write to VR_XS_PMA_SNPS_CR_DATA\n");
+	addr = 0x180a2; //VR_XS_PMA_SNPS_CR_DATA
+	__usxgmii_fabric_wr(pdata, addr, phy_data);
+
+	LGM_NET_DBG("write 1 to bit 1 of VR_XS_PMA_SNPS_CR_CTRL\n");
+	addr = 0x180a0; //VR_XS_PMA_SNPS_CR_CTRL
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	read_val = read_val | (0x1 << 1);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+
+	LGM_NET_DBG("write 1 to bit 0 of VR_XS_PMA_SNPS_CR_CTRL\n");
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	read_val = read_val | 0x1;
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+
+	read_val = 0x1;
+	while (read_val != 0) {
+		LGM_NET_DBG("Check if bit 0 VR_XS_PMA_SNPS_CR_CTRL is 0\n");
+		read_val = __usxgmii_fabric_rd(pdata, addr);
+		read_val = read_val & 0x1;
+	}
+}
+
+void usxgmii_speed_config(struct mac_prv_data *pdata)
+{
+	u32 phy_pdi, phy_data;
+
+	/* 2.5G=f9 */
+	phy_pdi = 0xa202; //TOP_PDI_REGISTERS.TOP_SLICE_IF
+	phy_data = 0x0;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	phy_pdi = 0x33d7; //SLICE_CTRL_PDI_REGISTERS.SLICE_CTRL_PDI_USXGMII
+	phy_data = 0x99; //originally it was 0xf9, clock stop not capable, EEE not able
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("2.5G=f9...: 0x%x\n",smdio_read(pdata, 0x0, 0x1f, phy_pdi, &phy_data));
+
+	/* 1G=f5 */
+	phy_pdi = 0xa202;
+	phy_data = 0x1;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	phy_pdi = 0x33d7;
+	phy_data = 0x99; //originally it was 0xf9
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("1G=f5...: 0x%x\n",smdio_read(pdata, 0x0, 0x1f, phy_pdi, &phy_data));
+
+	/* 100M=f3*/
+	phy_pdi = 0xa202;
+	phy_data = 0x2;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	phy_pdi = 0x33d7;
+	phy_data = 0x99; //originally it was 0xf9
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("100M=f3...: 0x%x\n",smdio_read(pdata, 0x0, 0x1f, phy_pdi, &phy_data));
+
+	/* 10M=f1 */
+	phy_pdi = 0xa202;
+	phy_data = 0x3;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	phy_pdi = 0x33d7;
+	phy_data = 0x99; //originally it was 0xf9
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("10M=f1...: 0x%x\n",smdio_read(pdata, 0x0, 0x1f, phy_pdi, &phy_data));
+
+	phy_pdi = 0xa202;
+	phy_data = 0x0;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+}
+
+void gphy_usxgmii_en(struct mac_prv_data *pdata)
+{
+	u32 addr = 0x0;
+	u32 read_val = 0x0, read_data = 0x0;
+	int i = 0;
+	int usxgmii_linktimer = 0x100;
+	u32 usxgmii_alignmenttimer = 0x4010;
+	int usxgmii_rxeq = 0x1;
+	u32 phy_pdi, phy_data;
+
+	usxgmii_speed_config(pdata);	//set all slice speed 2.5G
+	LGM_NET_DBG("USXGMII Configuration started\n");
+	phy_pdi = 0xa403;	//bit 0 of 0xa403 = CGU_PDI.LJPLL_CFG0L.PLLEN
+	phy_data = 0x1;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	//print("%08X"%p34x.mr(0xa403))
+
+	for (i = 0; i < 1000; i++){
+		smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data);
+		if (phy_data & BIT(1))
+			break;
+		udelay(10);
+	}
+	LGM_NET_DBG("CGU_PDI.LJPLL_CFG0L.PLLEN: 0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	phy_pdi = 0xa40e;	//bit 0 of 0xa40e = CGU_PDI.CGU_PDI_CLK_EN.USXGMII_CLK_EN
+	phy_data = 0x1;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	//print("%08X"%p34x.mr(0xa40e))
+	LGM_NET_DBG("CGU_PDI.CGU_PDI_CLK_EN.SEL(USXGMII_CLK_EN): 0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	/* Release the all usxgmii iddq,phy,xpcs bit 8,9,10 */
+	phy_pdi = AHB_TO_PDI(0x00D29404);
+	//phy_data = 0x1000;
+	phy_data = 0x1378;	//RCU_PDI_REGISTERS_RCU_PDI_REGISTERS_RST_REQ
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+
+	phy_pdi = AHB_TO_PDI(0x00D29404);	//todo change to after pll lock
+	phy_data = 0x1078;	//to include the LJPLL bit 12?
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG(">>>USXGMII released... value:0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	phy_pdi = AHB_TO_PDI(0x00A49408);	//SLICE_RCU_PDI_REGISTERS.SLICE_RCU_PDI_REGISTERS_STORAGE_0.SLICE_PERSISTENT
+	LGM_NET_DBG("SLICE_RCU_PDI_REGISTER.SLICE_PERSISTENT before:0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+	phy_data = 0x4;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("SLICE_RCU_PDI_REGISTER.SLICE_PERSISTENT after:0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	for (i = 0; i < 1000; i++){
+		if (__usxgmii_fabric_rd(pdata, 0x1809b)&BIT(0))	//check INIT_DN
+			break;
+		udelay(10);
+	}
+
+	read_val = __usxgmii_fabric_rd(pdata, 0x1809b);
+	read_val = read_val | 0x2;	//write EXT_LD_DN
+	__usxgmii_fabric_wr(pdata, 0x1809b, read_val);	//VR_XS_PMA_Gen5_12G_16G_SRAM
+
+	LGM_NET_DBG("READ CSR_RAM: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1809b));
+
+	phy_pdi = AHB_TO_PDI(0x00A49408);	//SLICE_RCU_PDI_REGISTERS.SLICE_RCU_PDI_REGISTERS_STORAGE_0.SLICE_PERSISTENT
+	LGM_NET_DBG("SLICE_RCU_PDI_REGISTER.SLICE_PERSISTENT before:0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+	phy_data = 0x5;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("SLICE_RCU_PDI_REGISTER.SLICE_PERSISTENT after:0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	//wait_for_powerup_xpcs5();
+	for (i = 0; i < 1000; i++){
+		read_val = __usxgmii_fabric_rd(pdata, 0x38010);	//CSR_DIG_STS	//VR_XS_PCS_DIG_STS[4:2]
+		read_val = read_val >> 2;	// bit[4:2] (PSEQ_STATE)
+		read_val &= 0x7;
+		if (read_val == 0x4) {//3b100 Tx/Rx Stable (Power_Good state)
+			LGM_NET_DBG("wait_for_powerup_xpcs5...success\n");
+			break;
+		}
+		udelay(10);
+	}
+
+	LGM_NET_DBG("READ VR_PMA_CTRL: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18000));
+	LGM_NET_DBG("READ CSR_DIG_STS: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+
+	//p34x.usxgmii.disable_an()
+	LGM_NET_DBG("### DISABLE AN 73 ###\n");
+	addr = 0x70000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("READ CSR_AN_CTRL before: 0x%x\n",read_val);
+	read_val = read_val & ~(0x1<<12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("READ CSR_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	//p34x.usxgmii.enable_kr()
+	LGM_NET_DBG("### ENABLE KR - Step 1 ###\n");
+	addr = 0x30007;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("SR_XS_PCS_CTRL2 before: 0x%x\n",read_val);
+	read_val = read_val & 0xFFFF;
+	read_val = read_val & ~(0xF);
+	//read_val = read_val | 0x1;	//Enable KX
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("SR_XS_PCS_CTRL2(Enable KR)(0x30007): 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### CONFIGURE_USXGMII - Step 2 ###\n");
+	addr = 0x38000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_DIG_CTRL1 before: 0x%x\n",read_val);
+	read_val = read_val & 0xFFFF;
+	read_val = read_val | (0x1<<9);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1(0x38000): 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### CONFIGURE_USXGMII - Step 3 ###\n");
+	addr = 0x38007;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PCS_KR_CTRL before: 0x%x\n",read_val);
+	read_val = read_val & 0xFFFF;
+	read_val = read_val & ~(0x7<<10);
+	read_val = read_val | (0x5 << 10); //phy mode = 10G-QXGMII
+	//read_val = read_val | (0x2 << 10);	//change to 2.5G-SXGMII
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_XS_PCS_KR_CTRL(0x38007): 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	//p34x.usxgmii.configure_usxgmii("10GQ",is_emu=is_emulation)
+	//usxgmii_phy_config()
+	LGM_NET_DBG("### USXGMII PHY CONFIG - Step 4 ###\n>\n");
+
+	addr = 0x18091;	//CSR_E12_PMA_REF_CLK_CTRL
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data |= 0x00000040;	//bit[6]
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x18071; //CSR_E12_PMA_MPLLA_CTRL0
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= 0xFFFFFF00;
+	read_data |= 0x00000021; //bit[7:0] 8'd33;
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x18077; //CSR_E12_PMA_MPLLA_CTRL3
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= 0xFFFF0000;
+	read_data |= 0x0000A016; //bit[15:0] 16'd40982;
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x18076; //CSR_E12_PMA_MPLLA_CTRL2
+	//addr = 0x18073; //CSR_E12_PMA_MPLLA_CTRL2
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data |= (1 << 10); //bit[10] mplla_div16p5_clk_en = 1
+	read_data |= (1 << 8); //bit[8] mplla_div8_clk_en = 1
+	read_data &= ~(1 << 9); //bit[9] mplla_div10_clk_en = 0
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_MPLLB_CTRL2(0x18076): 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18076));
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_MPLLA_CTRL2(0x18073): 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18073));
+
+	#if 1
+	addr = 0x18031; //CSR_E12_PMA_TXGENERAL_CTRL1
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_GENCTRL1(TX_CLK_RDY_0) before: 0x%x\n",read_data);
+	read_data &= 0xFFFFF8FF;
+	read_data |= 0x00000500; //wr_data[10:8] = 3'h5; // VBOOST_LVL // [NEW] Based on 1.03b_cust2 E16 X2 spec
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	#endif
+
+	addr = 0x18092; //CSR_E12_PMA_VCO_LD_CTRL0
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= 0xFFFFE000;
+	read_data |= 0x00000549; //wr_data[12:0] = 13'd1353;
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x18096; //CSR_E12_PMA_VCO_REF_CTRL0
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= 0xFFFFFF80;
+	read_data |= 0x00000029; //wr_data[6:0] = 7'd41;
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x1805D; //CSR_E12_PMA_AFE_DFE_EN
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data |= (1 << 4); //bit[4] dfe_en = 1
+	read_data |= (1 << 0); //bit[0] afe_en = 1
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x1805C; //CSR_E12_PMA_RX_EQ_CTRL4
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data |= (1 << 0); //bit[0] adapt_cont = 1
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x18034; //VR_XS_PMA_Gen5_12G_16G_TX_RATE_CTRL
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= ~(7 << 0); //wr_data[2:0] = 3'b000; // 10G
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x18054; //VR_XS_PMA_Gen5_12G_16G_RX_RATE_CTRL
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_RX_RATE_CTRL before: 0x%x\n",read_data);
+	read_data &= ~(3 << 0); //wr_data[1:0] = 2'b00; // 10G
+	//if (usxgmii_rxeq == 5) {read_data |= (3 << 0);} //wr_data[1:0] = 2'b03; // #dkteh-RX_ADS
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_RX_RATE_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x18032; //CSR_E12_PMA_TXGENERAL_CTRL
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= 0xFFFFFCFF;
+	read_data |= 0x00000200; //wr_data[9:8] = 2'b10; // 16-bit interface
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x18052; //CSR_E12_PMA_RX_GENERAL_CTRL2
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= 0xFFFFFCFF;
+	read_data |= 0x00000200; //wr_data[9:8] = 2'b10; // 16-bit interface
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	addr = 0x18053; //CSR_E12_PMA_RX_GENERAL_CTRL3
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= 0xFFFFFFF8;
+	read_data |= 0x00000007; //wr_data[2:0] = 3'd7; // LOS_TRSHLD_0
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+
+	#if 1
+	addr = 0x18031; //CSR_E12_PMA_TXGENERAL_CTRL1
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data |= (1 << 4); //wr_data[4] = 1'b1; // VBOOST_EN_0
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	#endif
+
+	addr = 0x18057; //VR_XS_PMA_Gen5_12G_16G_RX_ATTN_CTRL
+	u32 rx_att_lvl = 0;
+	if (usxgmii_rxeq == 1)	//RX_10G_SHORT
+		rx_att_lvl = 0x7;
+	else if (usxgmii_rxeq == 2)	//RX_10G
+		rx_att_lvl = 0x0;
+	else if (usxgmii_rxeq == 3)	//RX_ADAPT value
+		rx_att_lvl = 0x7;
+	else if (usxgmii_rxeq == 5)	//RX_ADS value
+		rx_att_lvl = 0x7;
+	else;
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_RX_ATTN_CTRL before: 0x%x\n",read_data);
+	read_data &= 0xFFFFFFF8;
+	read_data |= rx_att_lvl << 0; //BIT2:0 RX0_EQ_ATT_LVL
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_RX_ATTN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x18058; //CSR_E12_PMA_RX_EQ_CTRL0 //todo also 0x18057 VR_XS_PMA_Gen5_12G_16G_RX_ATTN_CTRL
+	u32 rx_ctle_boost = 0x0, rx_ctle_pole = 0x0, rx_vga2_gain = 0x0, rx_vga1_gain = 0x0;
+	if (usxgmii_rxeq == 1)
+		{rx_ctle_boost = 0x0, rx_ctle_pole = 0x0, rx_vga2_gain = 0x0, rx_vga1_gain = 0x0;}	//RX_10G_SHORT
+	else if (usxgmii_rxeq == 2)
+		{rx_ctle_boost = 0x10, rx_ctle_pole = 0x2, rx_vga2_gain = 0x5, rx_vga1_gain = 0x5;}	//RX_10G
+	else if (usxgmii_rxeq == 3)
+		{rx_ctle_boost = 0x0, rx_ctle_pole = 0x2, rx_vga2_gain = 0x0, rx_vga1_gain = 0x0;} //RX_ADAPT value
+	else if (usxgmii_rxeq == 5)
+		{rx_ctle_boost = 0x0, rx_ctle_pole = 0x6, rx_vga2_gain = 0x5, rx_vga1_gain = 0x5;} //RX_ADS value
+	else;
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_RX_EQ_CTRL0 before: 0x%x\n",read_data);
+	read_data &= 0xFFFF0000;
+	//read_data |= 0x00005510; //wr_data[4:0] = 5'd16; // CTLE_BOOST  wr_data[10:8] = 3'd5; // VGA2_GAIN0 wr_data[14:12] = 3'd5; // VGA1_GAIN0 //1.03b_cust2 E16 X2 spec
+	read_data |= rx_ctle_boost << 0; //BIT4:0 CTLE_BOOST_0		= 16
+	read_data |= rx_ctle_pole  << 5; //BIT7:5 CTLE_POLE_0 		= 2
+	read_data |= rx_vga2_gain  << 8; //BIT11:8 VGA2_GAIN_0		= 5
+	read_data |= rx_vga1_gain  << 12; //BIT15:12 VGA1_GAIN_0		= 5
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_RX_EQ_CTRL0 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	//postdebug
+	addr = 0x1805d; //VR_XS_PMA_Gen5_12G_AFE_DFE_EN_CTRL
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_AFE_DFE_EN_CTRL before: 0x%x\n",read_data);
+	if (usxgmii_rxeq == 1)		//RX_10G_SHORT
+		read_data &= 0xFFFFFF00; //Clear BIT AFE_EN & DFE_EN
+	else if (usxgmii_rxeq == 2)	//RX_10G
+	{
+		read_data &= 0xFFFFFF00;
+		read_data |= 0xFF;
+	}
+	else if (usxgmii_rxeq == 3)	//RX_ADAPT value
+	{
+		read_data &= 0xFFFFFF00;
+		read_data |= 0xFF;
+	}
+	else if (usxgmii_rxeq == 5)		//RX_ADS
+		read_data &= 0xFFFFFF00; //Clear BIT AFE_EN & DFE_EN
+	else;
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_AFE_DFE_EN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x18031; //VR_XS_PMA_Gen5_12G_16G_TX_GENCTRL1
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data &= ~(0x1 << 12); //Clear BIT[12] TX_CLK_RDY_0
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_GENCTRL1(TX_CLK_RDY_0) before: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### VR Reset - Step 5/6/7 ###\n");
+	__usxgmii_vr_reset(pdata);
+
+	addr = 0x18031; //VR_XS_PMA_Gen5_12G_16G_TX_GENCTRL1
+	read_data = __usxgmii_fabric_rd(pdata, addr);
+	read_data |= (1 << 12); //wr_data[12] = 1'b1; // TX_CLK_RDY_0
+	__usxgmii_fabric_wr(pdata, addr, read_data);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_GENCTRL1(TX_CLK_RDY_0) after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	if (usxgmii_rxeq == 5){
+		LGM_NET_DBG("LANEN_DIG_ASIC_RX_OVRD_ASIC_IN_0 before\t: 0x%x\n", __usxgmii_phy_rd(pdata, 0x1005));
+		__usxgmii_phy_wr(pdata, 0x1005, 0x4D84);
+		LGM_NET_DBG("LANEN_DIG_ASIC_RX_OVRD_ASIC_IN_0 after\t: 0x%x\n", __usxgmii_phy_rd(pdata, 0x1005));
+	}
+
+	addr = 0x18036;
+	//u32 tx_pre_cursor = 0x0, tx_main_cursor = 0x14, tx_post_cursor = 0x0, tx_iboost_lvl = 0x5;	//[10G Short] De-emphasis = 0dB; Pre-shoot = 0dB; Boost = 0dB; TxMargin = 3, TX max swing 0.5V
+	//u32 tx_pre_cursor = 0x8, tx_main_cursor = 0x10, tx_post_cursor = 0x4, tx_iboost_lvl = 0xf;	//[TxEQ Override] De-emphasis = 0dB; Pre-shoot = 0dB; Boost = 0dB; TxMargin = 3, TX max swing 0.5V
+	u32 tx_pre_cursor = 0x0, tx_main_cursor = 0x28, tx_post_cursor = 0x0, tx_iboost_lvl = 0xf;	// [TX Presets 4] De-emphasis = 0.00dB; Pre-shoot = 0.00dB; Boost = 0.00dB
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_EQ_CTRL0 before: 0x%x\n",read_val);
+	read_val &= ~(0x3F << 0); //Clear BIT5:0 EQ_PRE
+	read_val &= ~(0x3F << 8); //Clear BIT13:8 EQ_MAIN
+	read_val |= (tx_pre_cursor) << 0; //Set BIT5:0 EQ_PRE
+	read_val |= (tx_main_cursor) << 8; //SetBIT13:8 EQ_MAIN
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_EQ_CTRL0 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x18037;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_EQ_CTRL1 before: 0x%x\n",read_val);
+	read_val &= ~(0x3F << 0); //Clear BIT5:0 EQ_PRE
+	read_val &= ~(0x1 << 6); //Clear BIT6 EQ_MAIN
+	read_val |= (tx_post_cursor) << 0; //Set BIT5:0 TX_EQ_POST
+	read_val |= (0x1) << 6; //Set BIT6 TX_EQ_OVR_RIDE
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_EQ_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x18033;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_BOOST_CTRL before: 0x%x\n",read_val);
+	read_data &= ~(0xF << 0); //Clear BIT3:0 TX0_IBOOST
+	read_data |= (tx_iboost_lvl) << 0; //Set BIT3:0 TX0_IBOOST
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_XS_PMA_Gen5_12G_16G_TX_BOOST_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### DISABLE AN 73 - Step 8 ###\n");
+	addr = 0x70000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("READ CSR_AN_CTRL before: 0x%x\n",read_val);
+	read_val = read_val & ~(0x1<<12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("SR_AN_CTRL(0x70000): 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### DISABLE CL37_AN BIT ###\n");
+	addr = 0x1f0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_CTRL before: 0x%x\n",read_val);
+	read_val = read_val & ~(0x1<<12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("SR_MII_CTRL(bit 12)(0x1f0000): 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f0000));
+
+	addr = 0x1a0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_1_CTRL before: 0x%x\n",read_val);
+	read_val = read_val & ~(0x1<<12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("SR_MII_1_CTRL(0x1a0000): 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a0000));
+
+	addr = 0x1b0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_2_CTRL before: 0x%x\n",read_val);
+	read_val = read_val & ~(0x1<<12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("SR_MII_2_CTRL(0x1b0000): 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b0000));
+
+	addr = 0x1c0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_3_CTRL before: 0x%x\n",read_val);
+	read_val = read_val & ~(0x1<<12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("SR_MII_3_CTRL(0x1c0000): 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c0000));
+
+	LGM_NET_DBG("### VR_DATAPATH_INIT ###\n");
+	addr = 0x38000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_DIG_CTRL1 before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 8);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	LGM_NET_DBG("CSR_DIG_STS read to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+
+	//p34x.usxgmii.configure_usxgmii_an_ctrl()
+	LGM_NET_DBG("### CONFIGURE USXGMII AN_CTRL PORT 0 - Step 9 ###\n");
+	addr = 0x1f8001;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_AN_CTRL before: 0x%x\n",read_val);
+	read_val = read_val | 0x1;	//MII_AN_INTR_EN
+	read_val = read_val & ~(0x1 << 8);	//MII_CTRL (4 bit MII)
+	//read_val = read_val | (0x1 << 8);	//MII_CTRL (8 bit MII)
+	read_val = read_val | (0x1 << 3);	//TX_CONFIG
+	read_val = read_val | (0x1 << 4);	//SGMII_LINK_STS
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_MII_AN_CTRL(bit 8 0:4bit MII)(0x1f8001): 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### CONFIGURE USXGMII AN_CTRL PORT 1 ###\n");
+	addr = 0x1a8001;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_AN_CTRL before: 0x%x\n",read_val);
+	read_val = read_val | 0x1;
+	read_val = read_val & ~(0x1 << 8);
+	read_val = read_val | (0x1 << 3);
+	read_val = read_val | (0x1 << 4);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_MII_1_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### CONFIGURE USXGMII AN_CTRL PORT 2 ###\n");
+	addr = 0x1b8001;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_AN_CTRL before: 0x%x\n",read_val);
+	read_val = read_val | 0x1;
+	read_val = read_val & ~(0x1 << 8);
+	read_val = read_val | (0x1 << 3);
+	read_val = read_val | (0x1 << 4);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_MII_2_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### CONFIGURE USXGMII AN_CTRL PORT 3 ###\n");
+	addr = 0x1c8001;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_AN_CTRL before: 0x%x\n",read_val);
+	read_val = read_val | 0x1;
+	read_val = read_val & ~(0x1 << 8);
+	read_val = read_val | (0x1 << 3);
+	read_val = read_val | (0x1 << 4);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("VR_MII_3_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### SEE IF RX LINK UP ###\n");
+	read_val = __usxgmii_fabric_rd(pdata, 0x30001);
+	LGM_NET_DBG("0x%x\n",read_val);
+	LGM_NET_DBG("### cl37 AN Enable ###\n");
+	addr = 0x1f800a;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+
+	LGM_NET_DBG("### SET LINK TIMER - Step 10 ###\n");
+	LGM_NET_DBG("CSR_MII_LINK_TIMER before: 0x%x\n",read_val);
+
+	//usxgmii_linktimer == 0 (default) is 0x3d1, or 0x0 = 1.6ms
+	if (usxgmii_linktimer == 1)
+		__usxgmii_fabric_wr(pdata, addr, 0x100);	//Set to 0.42ms
+	else if (usxgmii_linktimer == 2)
+		__usxgmii_fabric_wr(pdata, addr, 0x7a1);	//Set for SGMII 2.5G mode, 3.2ms
+	else if (usxgmii_linktimer == 3)
+		__usxgmii_fabric_wr(pdata, addr, 0x1000); //Set to 6.71ms
+	else if (usxgmii_linktimer == 4)
+		__usxgmii_fabric_wr(pdata, addr, 0x263); //Set to 1ms
+	else if (usxgmii_linktimer == 5)
+		__usxgmii_fabric_wr(pdata, addr, 0x3d1); //Set to 1.6ms
+	else;
+	LGM_NET_DBG("CSR_MII_LINK_TIMER after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	LGM_NET_DBG("CSR_MII_1_LINK_TIMER after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a800a));
+	LGM_NET_DBG("CSR_MII_2_LINK_TIMER after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b800a));
+	LGM_NET_DBG("CSR_MII_3_LINK_TIMER after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c800a));
+
+	if (usxgmii_linktimer >= 1){
+		addr = 0x1f8000;
+		read_val = __usxgmii_fabric_rd(pdata, addr);
+		LGM_NET_DBG("### SET OVERRIDE BIT in ALL PORTS ###\n");
+		LGM_NET_DBG("CSR_MII_DIG_CTRL1 before: 0x%x\n",read_val);
+		read_val = read_val | (0x1 << 3);
+		read_val = read_val | 0x1;
+		__usxgmii_fabric_wr(pdata, addr, read_val);
+		LGM_NET_DBG("CSR_MII_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+		addr = 0x1a8000;
+		read_val = __usxgmii_fabric_rd(pdata, addr);
+		LGM_NET_DBG("CSR_MII_1_DIG_CTRL1 before: 0x%x\n",read_val);
+		read_val = read_val | (0x1 << 3);
+		read_val = read_val | 0x1;
+		__usxgmii_fabric_wr(pdata, addr, read_val);
+		LGM_NET_DBG("CSR_MII_1_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+		addr = 0x1b8000;
+		read_val = __usxgmii_fabric_rd(pdata, addr);
+		LGM_NET_DBG("CSR_MII_2_DIG_CTRL1 before: 0x%x\n",read_val);
+		read_val = read_val | (0x1 << 3);
+		read_val = read_val | 0x1;
+		__usxgmii_fabric_wr(pdata, addr, read_val);
+		LGM_NET_DBG("CSR_MII_2_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+		addr = 0x1c8000;
+		read_val = __usxgmii_fabric_rd(pdata, addr);
+		LGM_NET_DBG("CSR_MII_3_DIG_CTRL1 before: 0x%x\n",read_val);
+		read_val = read_val | (0x1 << 3);
+		read_val = read_val | 0x1;
+		__usxgmii_fabric_wr(pdata, addr, read_val);
+		LGM_NET_DBG("CSR_MII_3_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	}
+
+	//2.5G
+	//todo add the speed config here
+	LGM_NET_DBG("\n### Redo SPEED CONFIG for all ports - Step 11 ###\n");
+	addr = 0x1f0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_CTRL before: 0x%x\n",read_val);
+	read_val |=  (0x1 << 5);	//SS5	= 1
+	read_val &= ~(0x1 << 6);	//SS6	= 0
+	read_val &= ~(0x1 << 13);	//SS13	= 0
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x1a0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_1_CTRL before: 0x%x\n",read_val);
+	read_val |=  (0x1 << 5);	//SS5	= 1
+	read_val &= ~(0x1 << 6);	//SS6	= 0
+	read_val &= ~(0x1 << 13);	//SS13	= 0
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_1_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x1b0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_2_CTRL before: 0x%x\n",read_val);
+	read_val |=  (0x1 << 5);	//SS5	= 1
+	read_val &= ~(0x1 << 6);	//SS6	= 0
+	read_val &= ~(0x1 << 13);	//SS13	= 0
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_2_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x1c0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_3_CTRL before: 0x%x\n",read_val);
+	read_val |=  (0x1 << 5);	//SS5	= 1
+	read_val &= ~(0x1 << 6);	//SS6	= 0
+	read_val &= ~(0x1 << 13);	//SS13	= 0
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_3_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### ENABLE CL37_AN BIT - Step 12 ###\n");
+	addr = 0x38000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_DIG_CTRL1 before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	LGM_NET_DBG("### ENABLE AN BIT for all ports ###\n");
+	addr = 0x1f0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_CTRL before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x1a0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_1_CTRL before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_1_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x1b0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_2_CTRL before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_2_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	addr = 0x1c0000;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("CSR_MII_3_CTRL before: 0x%x\n",read_val);
+	read_val = read_val | (0x1 << 12);
+	__usxgmii_fabric_wr(pdata, addr, read_val);
+	LGM_NET_DBG("CSR_MII_3_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+
+	#if 1
+	//ALIGNMENT TIMER CONFIG
+	addr = 0x3800a;
+	LGM_NET_DBG("CSR_VR_PCS_AM_CTRL before: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	if (usxgmii_alignmenttimer != 0x4010) __usxgmii_fabric_wr(pdata, addr, usxgmii_alignmenttimer);
+	else LGM_NET_DBG("Skipping programming...\n");
+	LGM_NET_DBG("CSR_VR_PCS_AM_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, addr));
+	#endif
+
+	LGM_NET_DBG("VR_XS_PCS_DIG_STS: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+	LGM_NET_DBG("SR_XS_PCS_STS1: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x30001));
+
+	LGM_NET_DBG("VR_PMA_CTRL now: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18000));
+
+	LGM_NET_DBG("### Read auto-negotiation INTR - Step 14 ###\n");
+	read_val = __usxgmii_fabric_rd(pdata, 0x1f8002); //VR_MII_AN_INTR_STS
+	LGM_NET_DBG("ANEG Complete for Port 0: 0x%x\n",(read_val & 0x1));
+	read_val = __usxgmii_fabric_rd(pdata, 0x1a8002); //VR_MII_1_AN_INTR_STS
+	LGM_NET_DBG("ANEG Complete for Port 1: 0x%x\n",(read_val & 0x1));
+	read_val = __usxgmii_fabric_rd(pdata, 0x1b8002); //VR_MII_2_AN_INTR_STS
+	LGM_NET_DBG("ANEG Complete for Port 2: 0x%x\n",(read_val & 0x1));
+	read_val = __usxgmii_fabric_rd(pdata, 0x1c8002); //VR_MII_3_AN_INTR_STS
+	LGM_NET_DBG("ANEG Complete for Port 3: 0x%x\n",(read_val & 0x1));
+
+	LGM_NET_DBG("### USRA Reset (To reach desired USXGMII speed) - Step 18 ###\n");
+	__usxgmii_usra_reset(pdata);
+
+	LGM_NET_DBG("=========================================================================\n");
+	LGM_NET_DBG("New Register\n");
+	LGM_NET_DBG("READ CSR_RAM: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1809b));
+	LGM_NET_DBG("READ VR_PMA_CTRL: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18000));
+	LGM_NET_DBG("READ CSR_DIG_STS: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+	LGM_NET_DBG("READ CSR_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x70000));
+	LGM_NET_DBG("CSR_PCS_CTRL2 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x30007));
+
+	LGM_NET_DBG("### READ CONFIGURATION_USXGMII\n ####");
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 before: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38000));
+	LGM_NET_DBG("CSR_VR_RPCS_TPC after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38007));
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38000));
+	LGM_NET_DBG("CSR_VR_PCS_AM_CTRL: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x3800a));
+	LGM_NET_DBG("CSR_DEBUG_CTL before: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x380005));
+	LGM_NET_DBG("CSR_DEBUG_CTL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x380005));
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 after: 0x%x\n", __usxgmii_fabric_rd(pdata, 0x38000));
+	LGM_NET_DBG("CSR_DIG_STS read to flush 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+	LGM_NET_DBG("CSR_MII_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f8001));
+	LGM_NET_DBG("CSR_MII_1_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8001));
+	LGM_NET_DBG("CSR_MII_2_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8001));
+	LGM_NET_DBG("CSR_MII_3_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8001));
+
+	LGM_NET_DBG("RX LINK UP:0x%x\n",__usxgmii_fabric_rd(pdata, 0x30001));
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38000));
+	LGM_NET_DBG("CSR_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+	LGM_NET_DBG("CSR_MII_1_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8000));
+	LGM_NET_DBG("CSR_MII_1_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8010));
+	LGM_NET_DBG("CSR_MII_2_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8000));
+	LGM_NET_DBG("CSR_MII_2_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8010));
+	LGM_NET_DBG("CSR_MII_3_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8000));
+	LGM_NET_DBG("CSR_MII_3_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8010));
+
+	LGM_NET_DBG("RX LINK UP:0x%x\n",__usxgmii_fabric_rd(pdata, 0x30001));
+	LGM_NET_DBG("CSR_MII_LINK_TIMER after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f800a));
+	LGM_NET_DBG("VR_MII_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f8000));
+	LGM_NET_DBG("CSR_MII_1_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8000));
+	LGM_NET_DBG("CSR_MII_2_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8000));
+	LGM_NET_DBG("CSR_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8000));
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38000));
+	LGM_NET_DBG("CSR_MII_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f0000));
+	LGM_NET_DBG("CSR_MII_1_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a0000));
+	LGM_NET_DBG("CSR_MII_2_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b0000));
+	LGM_NET_DBG("CSR_MII_3_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c0000));
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38000));
+	LGM_NET_DBG("CSR_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+	LGM_NET_DBG("CSR_MII_1_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8000));
+	LGM_NET_DBG("CSR_MII_1_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8010));
+	LGM_NET_DBG("CSR_MII_2_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8000));
+	LGM_NET_DBG("CSR_MII_2_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8010));
+	LGM_NET_DBG("CSR_MII_3_DIG_CTRL1 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8000));
+	LGM_NET_DBG("CSR_MII_3_DIG_STS to flush: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8010));
+	LGM_NET_DBG("SR_XS_PCS_STS1 now: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x30001));
+	LGM_NET_DBG("VR_PMA_CTRL now: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18000));
+	LGM_NET_DBG("VR_XS_PCS_DEBUG_CTRL now: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38005));
+
+	LGM_NET_DBG("VR_XS_PCS_DEBUG_CTRL: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38005));
+	LGM_NET_DBG("VR_XS_PCS_DIG_STS: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+	LGM_NET_DBG("VR_XS_PCS_DEBUG_CTRL: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38005));
+	LGM_NET_DBG("VR_XS_PCS_DIG_STS: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+
+	LGM_NET_DBG("6.250 VR_XS_PMA_Gen5_10G_MISC_CTR: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f809f));
+	//p34x.usxgmii.fabric_write(0x1f809f, 0x0001)
+	LGM_NET_DBG("6.250 VR_XS_PMA_Gen5_10G_MISC_CTR: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f809f));
+
+	//p34x.usxgmii.fabric_write(0x1f809f, 0x0001)
+	LGM_NET_DBG("6.250 VR_XS_PMA_Gen5_10G_MISC_CTR: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18090));
+	//p34x.usxgmii.fabric_write(0x18090, 0x5101)
+	LGM_NET_DBG("6.250 VR_XS_PMA_Gen5_10G_MISC_CTR: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18090));
+	LGM_NET_DBG("6.251 VR_XS_PMA_SNPS_CR_CTRL 0x%x\n",__usxgmii_fabric_rd(pdata, 0x0180a0));
+
+	if (usxgmii_rxeq == 4){
+		LGM_NET_DBG("### Configuring PHY Registers ###\n");
+		__usxgmii_phy_wr(pdata, 0x1002, 0xA000);	//Tx EQ Main cursor = 0x10, iBoost/vBoost = 0x0
+		__usxgmii_phy_wr(pdata, 0x1003, 0x2248);	//Tx EQ Post = 0x4, pre cursor = 0x8
+		__usxgmii_phy_wr(pdata, 0x3008, 0x1800);	//Rx EQ Adapt ADAPT_REQ, REQ_OVRD_EN = 0x1
+
+		LGM_NET_DBG("RX_ADAPT_DONE\t: 0x%x\n", __usxgmii_phy_rd(pdata, 0x305e));
+		__usxgmii_phy_wr(pdata, 0x3008, 0x0);
+	}
+
+	LGM_NET_DBG("\n###>>>USXGMII CONFIG DONE :))))))))###\n");
+
+	addr = 0x38006;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PCS_EEE_MCTRL0 before: 0x%x\n",read_val);
+	addr = 0x3800b;
+	read_val = __usxgmii_fabric_rd(pdata, addr);
+	LGM_NET_DBG("VR_XS_PCS_EEE_MCTRL1 before: 0x%x\n",read_val);
+	LGM_NET_DBG("READ 6.1_SR_PMA_CTRL: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x10000));
+
+	LGM_NET_DBG("### SR_MII_CTRL BIT13/6/5 ###\n");
+	LGM_NET_DBG("\nSlice0         \tSlice1         \tSlice2         \tSlice3\n");
+	LGM_NET_DBG("================================================================\n");
+	LGM_NET_DBG("%6X\t", __usxgmii_fabric_rd(pdata, 0x1f0000));
+	LGM_NET_DBG("%5X\t", __usxgmii_fabric_rd(pdata, 0x1a0000));
+	LGM_NET_DBG("%6X\t", __usxgmii_fabric_rd(pdata, 0x1b0000));
+	LGM_NET_DBG("%4X\t", __usxgmii_fabric_rd(pdata, 0x1c0000));
+	LGM_NET_DBG("\n");
+
+	#if 1
+	LGM_NET_DBG(">>>Read USXGMII sideband speed config\n");
+
+	phy_pdi = 0xa202;	//TOP_PDI_REGISTERS.TOP_SLICE_IF
+	phy_data = 0x0;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	phy_pdi = 0x33d7;	//SLICE_CTRL_PDI_REGISTERS.SLICE_CTRL_PDI_USXGMII
+	//phy_data = 0x95;	//originally it was 0xf9, clock stop not capable, EEE not able
+	//smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("2.5G=f9...: 0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	phy_pdi = 0xa202;
+	phy_data = 0x1;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	phy_pdi = 0x33d7;
+	//phy_data = 0x95; //originally it was 0xf9
+	//smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("1G=f5...: 0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	phy_pdi = 0xa202;
+	phy_data = 0x2;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	phy_pdi = 0x33d7;
+	//phy_data = 0x95; //originally it was 0xf9
+	//smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("100M=f3...: 0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	phy_pdi = 0xa202;
+	phy_data = 0x3;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	phy_pdi = 0x33d7;
+	//phy_data = 0x95; //originally it was 0xf9
+	//smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("10M=f1...: 0x%x\n",smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data));
+
+	phy_pdi = 0xa202;
+	phy_data = 0x0;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	#endif
+
+	LGM_NET_DBG(">>>CSR_VR_PCS_AM_CTRL(AM_COUNT): 0x%x\n",__usxgmii_fabric_rd(pdata, 0x3800a));
+
+	read_val = __usxgmii_fabric_rd(pdata, 0x1f8002);	//VR_MII_AN_INTR_STS
+	LGM_NET_DBG("ANEG(VR_MII_AN_INTR_STS) reg value Port 0: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f8002));
+	LGM_NET_DBG("ANEG Complete for Port 0: 0x%x\n",(read_val & 0x1));
+
+	read_val = __usxgmii_fabric_rd(pdata, 0x1a8002);	//VR_MII_1_AN_INTR_STS
+	LGM_NET_DBG("ANEG(VR_MII_1_AN_INTR_STS) reg value Port 1: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8002));
+	LGM_NET_DBG("ANEG Complete for Port 1: 0x%x\n",(read_val & 0x1));
+
+	read_val = __usxgmii_fabric_rd(pdata, 0x1b8002);	//VR_MII_2_AN_INTR_STS
+	LGM_NET_DBG("ANEG(VR_MII_2_AN_INTR_STS) reg value Port 2: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8002));
+	LGM_NET_DBG("ANEG Complete for Port 2: 0x%x\n",(read_val & 0x1));
+
+	read_val = __usxgmii_fabric_rd(pdata, 0x1c8002);	//VR_MII_3_AN_INTR_STS
+	LGM_NET_DBG("ANEG(VR_MII_3_AN_INTR_STS) reg value Port 3: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8002));
+	LGM_NET_DBG("ANEG Complete for Port 3: 0x%x\n",(read_val & 0x1));
+
+	LGM_NET_DBG("New Register\n");
+	LGM_NET_DBG("READ CSR_RAM: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1809b));
+	LGM_NET_DBG("READ VR_PMA_CTRL: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x18000));
+	LGM_NET_DBG("READ CSR_DIG_STS: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x38010));
+	LGM_NET_DBG("READ CSR_AN_CTRL after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x70000));
+	LGM_NET_DBG("CSR_PCS_CTRL2 after: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x30007));
+	LGM_NET_DBG("\n>>>All P34x in reset... \n");
+}
+
+#if defined(CONFIG_LGM_P34X_SUPPORT)
+static void p34x_serdes_tune(struct mac_prv_data *pdata, u32 reg,
+			u32 phy_id, int length)
+{
+	u32 read_val;
+	u32 len_setting=1;
+
+	if(length != 1)
+		len_setting=3;/*urx851,custom*/
+	else
+		len_setting=1;/*urx641,non FF, medium*/
+
+	mdio_read(pdata, 0x1e, phy_id, reg, &read_val);
+	read_val &= ~(0x98);
+	read_val |= (len_setting << 3);
+	mdio_write(pdata, 0x1e, phy_id, reg, read_val);
+	debug("new sedes tuned val: 0x%x\n", read_val);
+}
+
+/* raw gphy firmware is re-packaged inside u-boot and should be read using this function */
+int get_gphy_firmware(struct mac_prv_data *pdata, u32 dst, u32 src,
+			u32 *actual_fw_addr, u32 *actual_fw_size)
+{
+	int result = 1;
+	int fw_type = 0;
+	int update_img = 0;
+	u32 soc_version = get_soc_version();
+	u8 *load = (unsigned char *) dst;
+	u8 *image_start = NULL;
+	u32 boot_mode;
+	ulong unc_len = CONFIG_LGM_UNCOMPRESSED_GPHY_FW_SIZE * 2;
+	ulong image_len = 0;
+	image_header_t *pimg_header = NULL;
+
+	/* For recovery image, force use the firmware in the BIN image. */
+	/* TODO: Handle this in the Makefile? */
+	boot_mode = readl(BOOT_IMG_INFO);
+	boot_mode = (boot_mode >> 8) & 0xF;
+	if (boot_mode == 0x1 || boot_mode == 0x4
+		|| boot_mode == 0x2)
+		soc_version = 0;
+
+	pimg_header = (image_header_t *) src;
+	while (1) {
+		if (ntohl(pimg_header->ih_magic) != IH_MAGIC) {
+			LGM_NET_DBG("bad image magic number\n");
+			result = 1;
+			break;
+		}
+
+		switch (pimg_header->ih_type) {
+		case IH_TYPE_MULTI:
+			LGM_NET_DBG("multi type\n");
+			image_start = (u8 *)pimg_header
+					+ sizeof(image_header_t) + 8;
+			image_len = ntohl(pimg_header->ih_size);
+
+			if (lzmaBuffToBuffDecompress(load, (SizeT *)&unc_len,
+					(unsigned char *)image_start,
+					image_len)) {
+				result = 1;
+				goto exit;
+			}
+			pimg_header = (image_header_t *)load;
+			break;
+
+		case IH_TYPE_FIRMWARE:
+			LGM_NET_DBG("firmware type\n");
+			/* determine from mkimage hdr if the fw is unsigned or signed */
+
+			if (strncmp((const char *)pimg_header->ih_name,
+					"LGM GPHY Firmware unsigned",
+					sizeof(pimg_header->ih_name)) == 0)
+				fw_type = 1;
+			else if (strncmp((const char *)pimg_header->ih_name,
+					"LGM GPHY Firmware signed",
+					sizeof(pimg_header->ih_name)) == 0)
+				fw_type = 2;
+
+			/* fw_type 1: unsigned, fw_type 2: signed */
+			if (fw_type == 1 && soc_version != 7)
+				update_img = 1;
+			else if (fw_type == 2 && soc_version == 7)
+				update_img = 1;
+			else if (fw_type == 2 && mxl86249_fw == 1)
+				update_img = 1;
+
+			if (update_img == 1) {
+				image_start = (u8 *)pimg_header
+						+ sizeof(image_header_t);
+				image_len = ntohl(pimg_header->ih_size);
+
+				LGM_NET_DBG("P34X FW version: %s\n",
+						(fw_type == 2) ? "B0" : "A0");
+				LGM_NET_DBG("image_start = %x\n", image_start);
+				LGM_NET_DBG("image_len = %x\n", image_len);
+
+				*actual_fw_addr = (u32) image_start;
+				*actual_fw_size = image_len;
+
+				result = 0;
+				goto exit;
+			}
+			
+			/* shift pointer to second image in IH_TYPE_MULTI */
+			pimg_header = (image_header_t *)((u32)pimg_header
+					+ sizeof(image_header_t)
+					+ ntohl(pimg_header->ih_size));
+
+			LGM_NET_DBG("pimg_header = %x\n", pimg_header);
+
+			break;
+		}
+	}
+	printf("No suitable GPHY Firmware found in the image\n");
+
+exit:
+	return result;
+}
+
+void echo_gphy_fw_version(struct mac_prv_data *pdata,
+				int phy_addr)
+{
+	u32 phy_data;
+
+	mdio_read(pdata, 0, phy_addr, 0x1e, &phy_data);
+	printf("0x%04x\n", (phy_data & 0xffff));
+}
+
+void __gpy2xx_fabric_wr(void *pdata, u32 data)
+{
+        u16 data_low, data_hi;
+	u32 phy_pdi, phy_data;
+
+        data_hi = (data >> 16) & 0xFFFF;
+        data_low = (data & 0xFFFF);
+
+        /* Fabric indirect access address High register */
+        phy_pdi = AHB_TO_PDI(0x00D3DB50); //FABRIC_PDI_DATAH
+        phy_data = data_hi;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+
+        /* Fabric indirect access address Low register */
+        phy_pdi = AHB_TO_PDI(0x00D3DB4C); //FABRIC_PDI_DATAL
+        phy_data = data_low;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+}
+
+void gpy2xx_fabric_wradr(struct mac_prv_data *pdata, u32 regaddr)
+{
+	u16 lo_addr, hi_addr;
+	u32 phy_pdi, phy_data;
+
+	hi_addr = (regaddr >> 16) & 0xFFFF;
+	lo_addr = (regaddr & 0xFFFF);
+
+       /* Fabric indirect access Access Control register */
+        phy_pdi = AHB_TO_PDI(0x00D3DB40); //FABRIC_PDI_CTRL
+        phy_data = 0x2;
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+
+        /* Fabric indirect access address High register */
+        phy_pdi = AHB_TO_PDI(0x00D3DB48); //FABRIC_PDI_ADDRH
+        phy_data = hi_addr;
+        smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+
+        /* Fabric indirect access address Low register */
+        phy_pdi = AHB_TO_PDI(0x00D3DB44); //FABRIC_PDI_ADDRL
+        phy_data = lo_addr;
+        smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+}
+
+void gphy_reset(struct mac_prv_data *pdata, int phy_addr)
+{
+	u32 std_ctrl;
+	u32 addr = 0;
+	int id;
+
+	for (id = phy_addr + 3; id >= phy_addr; id--) {
+		mdio_read(pdata, addr, id, 0, &std_ctrl);
+		LGM_NET_DBG("Original Std_ctrl: 0x%x\n", std_ctrl);
+		std_ctrl &= 0x7FFF;
+		std_ctrl |= 0x1 << 15;
+		LGM_NET_DBG("Original Std_ctrl after: 0x%x\n", std_ctrl);
+		mdio_write(pdata, addr, id, 0, std_ctrl);
+	}
+}
+
+int gswip_load_firmware_mxl86249(struct mac_prv_data *pdata)
+{
+	u32 i;
+	u32 phy_data;
+	u32 filesize;
+	u32 *p34x_fw;
+	u32 fw_dst_addr, fw_src_addr;
+	u32 actual_fw_addr, actual_fw_size;
+	u32 val;
+	u32 timer;
+
+	/*VSPEC1_MBOX_CMD - Mailbox CMD type and upper 8 bits of AHB address
+	(Register 30.7) loop until bit14 fail bit been set to 1*/
+	timer = 10000;
+	do {
+		mdio_read(pdata, 30, pdata->phy_id, 7, &phy_data);
+
+		mdelay(1);
+		timer--;
+		if (timer <= 0) {
+			printf("timeout on checking VSPEC1_MBOX_CMD bit14 fail bit been set to 1\n");
+			break;
+		}
+
+	} while (!(phy_data & 0x4000));
+
+	/*CHIP_ID_CFG : AHB Bus Address = 0x00D288C0 , PDI Address = 0xA230 */
+	xgmac_mb16_read(pdata, 0x1e, 0x10, 0xD288C0, &phy_data);
+	if ((phy_data & 0x1) == 0) {
+		mxl86249_fw = 0;
+		printf("CHIP_ID_CFG[0] != 1, not new OTP\n");
+		return -1;
+	} else {
+		mxl86249_fw = 1;
+	}
+
+	mdio_read(pdata, 30, pdata->phy_id, 7, &phy_data);
+	phy_data = (phy_data & 0xF0FF) | 0x900;
+	mdio_write(pdata, 30, pdata->phy_id, 7, phy_data);
+	timer = 10000;
+	do {
+		mdio_read(pdata, 30, pdata->phy_id, 13, &phy_data);
+
+		mdelay(1);
+		timer--;
+		if (timer <= 0) {
+			printf("timeout on checking 0xA5A5 which returned by otp fw.\n");
+			break;
+		}
+
+	} while (phy_data != 0xA5A5);
+
+	fw_dst_addr = (u32)malloc(CONFIG_LGM_UNCOMPRESSED_GPHY_FW_SIZE * 2);
+	fw_src_addr = CONFIG_LGM_GPHY_FW_ADDR;
+
+	if (get_gphy_firmware(pdata, fw_dst_addr,
+				fw_src_addr, &actual_fw_addr,
+				&actual_fw_size)) {
+		printf("cannot find gphy firmware!!\n");
+		return -EINVAL;
+	}
+
+	p34x_fw = (u32 *)actual_fw_addr;
+	filesize = actual_fw_size / 4;
+
+	for (i = 0; i < filesize; i++) {
+		val = p34x_fw[i];
+		mdio_write(pdata, 30, pdata->phy_id, 5, (val & 0xffff));
+		mdio_write(pdata, 30, pdata->phy_id, 7, ((val >> 16) & 0xffff));
+	}
+
+	/*set STD_CTRL.RST=1*/
+	mdio_read(pdata, 0, pdata->phy_id, 0, &phy_data);
+	phy_data = (phy_data | 0x8000);
+	mdio_write(pdata, 0, pdata->phy_id, 0, phy_data);
+
+	/*If bootloader is booting from RAM, TOP_FCR register(AHB:0xD2880C) should have value 0x4120.
+	If its value is 0xC000, it means the boot loader is still in OTP mode.
+	This may suggest FW authentication failure.
+	xgmac_mb16_read(pdata, 0x1e, 0x10, 0xD2880C, &phy_data);
+	printf("TOP_FCR:MBOX(0xD2880C): 0x%04x\n", (phy_data & 0xffff));
+	*/
+	/*bit14 fail bit should be reset to 0 if authentication pass.*/
+	timer = 20000;
+	do {
+		mdio_read(pdata, 30, pdata->phy_id, 7, &phy_data);
+
+		mdelay(1);
+		timer--;
+		if (timer <= 0) {
+			printf("timeout on checking VSPEC1_MBOX_CMD bit14 fail bit been set to 1\n");
+			break;
+		}
+
+	} while ((phy_data & 0x4000) == 0x4000);
+
+	return 0;
+}
+
+int gswip_load_firmware(struct mac_prv_data *pdata)
+{
+	u32 i;
+	u32 phy_pdi, phy_data;
+	u32 filesize;
+	u32 *p34x_fw;
+	u32 fw_dst_addr, fw_src_addr;
+	u32 actual_fw_addr, actual_fw_size;
+
+	LGM_NET_DBG("Check Mailbox access to GPHY Top level registers to enable SMDIO\n");
+	xgmac_mb16_read(pdata, 0x1e, 0x0, 0xD20100, &phy_data);
+	xgmac_mb16_read(pdata, 0x1e, 0x0, 0xd3d200, &phy_data);
+
+	LGM_NET_DBG("Read Top Level register via SMDIO @ PDI Address\n");
+	smdio_read(pdata, 0x0, 0x1f, 0xf480, &phy_data);
+	print_smdio_data(pdata, 0, 0x1f, 0xf480, phy_data);
+	smdio_read(pdata, 0x0, 0x1f, 0x8040, &phy_data);
+	print_smdio_data(pdata, 0, 0x1f, 0x8040, phy_data);
+
+	LGM_NET_DBG("FW programming sequence starting... \n");
+	phy_pdi = AHB_TO_PDI(0x00D29404);
+	phy_data = 0x1778;
+
+	fw_dst_addr = (u32)malloc(CONFIG_LGM_UNCOMPRESSED_GPHY_FW_SIZE * 2);
+	fw_src_addr = CONFIG_LGM_GPHY_FW_ADDR;
+	if (get_gphy_firmware(pdata, fw_dst_addr,
+				fw_src_addr, &actual_fw_addr,
+				&actual_fw_size)) {
+		printf("cannot find gphy firmware!!\n");
+		return -EINVAL;
+	}
+
+	p34x_fw = (u32 *)actual_fw_addr;
+
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG("Master slice resetted... \n");
+
+	filesize = actual_fw_size / 4;
+
+	LGM_NET_DBG(">>>FW size: %u\n", actual_fw_size);
+
+	gpy2xx_fabric_wradr(pdata, 0x000A0000);
+	LGM_NET_DBG("P34x fabric address updated... \n");
+	LGM_NET_DBG("FW size: %d\n", filesize);
+	for (i = 0; i < filesize; i++) {
+		__gpy2xx_fabric_wr(pdata, p34x_fw[i]);
+		LGM_NET_DBG(".");
+	}
+
+	LGM_NET_DBG("\ndone updating fw\n");
+
+	/* Set BOOTSEL = RAM */
+	phy_pdi = AHB_TO_PDI(0x00D2880C);
+	phy_data = 0x4000; //TOP_FCR
+	smdio_write(pdata, 0, 0x1f, phy_pdi, phy_data);
+	LGM_NET_DBG(">>>BOOTSEL from SRAM... \n");
+
+	/* Get BOOTROM & BOOT Loader Exit Path */
+	LGM_NET_DBG(">>>Top indicator value... \n");
+	phy_pdi = AHB_TO_PDI(0x00D28814); //TOP_INDICATOR
+	smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data);
+	print_smdio_data(pdata, 0, 0x1f, phy_pdi, phy_data);
+
+	/* MDIO read */
+	phy_pdi = 0xf480;
+	smdio_read(pdata, 0, 0x1f, phy_pdi, &phy_data);
+	print_smdio_data(pdata, 0, 0x1f, phy_pdi, phy_data);
+
+	return 0;
+
+}
+
+void gswip_force_autoneg(struct mac_prv_data *pdata, int phy_addr)
+{
+	int i, slice = 4;
+	u32 rd_reg;
+
+	for (i = phy_addr + slice - 1; i >= phy_addr; i--) {
+		LGM_NET_DBG("Re-ANEG Slice %d\n", i);
+		mdio_read(pdata, 0, i, 0, &rd_reg);
+		LGM_NET_DBG("Original Std_ctrl: 0x%x\n",rd_reg);
+		rd_reg &= 0xfdff;
+		rd_reg |= 0x1 << 9;
+		LGM_NET_DBG("Original Std_ctrl after: 0x%x\n", rd_reg);
+		mdio_write(pdata, 0, i, 0, rd_reg);
+	}
+}
+
+static void xgmac_reset_sequence(struct udevice *dev, struct mac_prv_data *pdata)
+{
+	int i;
+
+	for (i = 3; i < 7; i++) {
+		gswss_xgmac_reset(&pdata[i], 1);
+#if !defined(CONFIG_LIGHTNING_A0)
+		/* xgmac in B0 do not self clear, xgmac will not
+		 * be out of reset
+		 */
+		gswss_xgmac_reset(&pdata[i], 0);
+#endif /* !CONFIG_LIGHTNING_A0 */
+		gswss_lmac_reset(&pdata[i], 1);
+		lightning_mountain_mac_init(dev, &pdata[i]);
+	}
+}
+#endif
+
+#if defined(CONFIG_LGM_P34X_SUPPORT) || defined(CONFIG_XPCS5_USXGMII_RTL8261)
+int init_gswip_core(struct udevice *dev, struct mac_prv_data *pdata)
+{
+	int ret, cdb_clock = 1;
+	unsigned int num_ports, vports, total_ports;
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	u32 value;
+	u32 timeout = 0xffff;
+	
+	if (!priv)
+		return -1;
+
+	while (!((REG32(CGU_LJPLL3_CFG0) & LJPLL3_CFG0_PLLEN_MASK)
+			>> LJPLL3_CFG0_PLLEN_POS == 1)) {
+		timeout--;
+		if (timeout <= 0) {
+			LGM_NET_DBG("PLL3 not ready\n");
+			return -1;
+		}
+	}
+
+	/* config cdb clock to 25Mhz */
+	if (cdb_clock == 1) {
+		LGM_NET_DBG("\nLJPLL3_CFG1 default readout: 0x%x\n", REG32(CGU_LJPLL3_CFG1));
+
+		REG32(CGU_LJPLL3_CFG1) &= ~(0x1 << 24); //FOUT0EN Bit 24 PLL Clock Output 0 Disable
+		REG32(CGU_LJPLL3_CFG1) = (REG32(CGU_LJPLL3_CFG1) & ~0x7) | 0x7; //POST_DIV0A=0X7
+		REG32(CGU_LJPLL3_CFG1) = (REG32(CGU_LJPLL3_CFG1) & ~(0x7<<3)) | (0x4<<3); //POST_DIV0B=0X4
+
+		//To wait for LJPLL3 lock status
+		while((REG32(CGU_LJPLL3_CFG0) & LJPLL3_CFG0_PLLEN_MASK)!=1);
+
+		REG32(CGU_LJPLL3_CFG1) |= 0x1 << 24; //FOUT0EN Bit 24 PLL Clock Output 0 Enable
+		LGM_NET_DBG("\nLJPLL3_CFG1 configured for 25Mhz: 0x%x\n", REG32(CGU_LJPLL3_CFG1));	//POST_DIV0A=0X7, POST_DIV0B=0X4
+	}
+
+	/* release gswip, dma1 rx/tx out of reset */
+	value = readl(RCU_RST_REQ_ETHNOC);
+	value &= (0xFFFFFEF0);
+	writel(value, RCU_MODULE_BASE + RST_REQ_ETHNOC);
+
+        gsw_r32(priv->gswip_o_base, ETHSW_CAP_1_PPORTS_OFFSET,
+                ETHSW_CAP_1_PPORTS_SHIFT,
+                ETHSW_CAP_1_PPORTS_SIZE, &value);
+
+	num_ports = (unsigned int) value;
+        gsw_r32(priv->gswip_o_base, ETHSW_CAP_1_VPORTS_OFFSET,
+		ETHSW_CAP_1_VPORTS_SHIFT,
+                ETHSW_CAP_1_VPORTS_SIZE, &value);
+	vports = (unsigned int) value;
+	total_ports = num_ports + vports;
+
+	LGM_NET_DBG("num ports = %d, vports = %d\n", num_ports, vports);
+	LGM_NET_DBG("Initialize microcode for %d ports\n", total_ports);
+	/* microcode init */
+	ret = lightning_mountain_load_microcode(dev, num_ports);
+	if (ret)
+		return ret;
+	/* mac init */
+	ret = lightning_mountain_mac_config(dev);
+	if (ret)
+		return ret;
+	/* enable switch */
+	ret = lightning_mountain_switch_enable(dev, total_ports);
+	if (ret)
+		return ret;
+
+#if defined(CONFIG_LGM_P34X_SUPPORT)
+	xgmac_reset_sequence(dev, pdata);
+#endif
+	timeout = 0xffff;
+	while(!((REG32(RCU_RST_REQ_ETHNOC) & RST_REQ_ETHNOC_GSWIPO_MASK)
+		>> RST_REQ_ETHNOC_GSWIPO_POS == 0)) {
+		timeout--;
+		if (timeout <= 0) {
+			LGM_NET_DBG("Error waiting for ETHNOC reset\n");
+			return -1;
+		}
+	}
+
+	XGMAC_RGWR(pdata, 0x220, 0x80000000);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_LGM_P34X_SUPPORT
+void gphy_usxgmii_lb_en(struct mac_prv_data *pdata)
+{
+        u32 addr = 0x10000;     //SR_PMA_CTRL1
+        int loopback_en = 0;
+
+        if (loopback_en == 1){  //to enable bit 0
+                __usxgmii_fabric_wr(pdata, addr, 0x0041);
+                LGM_NET_DBG("Enabling USXGMII P34X PMA loopback...\n");
+        }
+        if (loopback_en == 2){  //to disable bit 0
+                __usxgmii_fabric_wr(pdata, addr, 0x400040);
+                LGM_NET_DBG("Disabling USXGMII P34X PMA loopback...\n");
+        }
+        LGM_NET_DBG("READ 6.1_SR_PMA_CTRL: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x10000));
+
+        LGM_NET_DBG("ANEG complete status (VR_MII_AN_INTR_STS) ...\n");
+
+#ifdef LGM_NET_VERBOSE
+        u32 read_val = 0x0;
+
+        read_val = __usxgmii_fabric_rd(pdata, 0x1f8002); //VR_MII_AN_INTR_STS
+        LGM_NET_DBG("ANEG reg value Port 0: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1f8002));
+        LGM_NET_DBG("ANEG Complete for Port 0: 0x%x\n",(read_val & 0x1));
+
+        read_val = __usxgmii_fabric_rd(pdata, 0x1a8002); //VR_MII_1_AN_INTR_STS
+        LGM_NET_DBG("ANEG reg value Port 1: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1a8002));
+        LGM_NET_DBG("ANEG Complete for Port 1: 0x%x\n",(read_val & 0x1));
+
+        read_val = __usxgmii_fabric_rd(pdata, 0x1b8002); //VR_MII_2_AN_INTR_STS
+        LGM_NET_DBG("ANEG reg value Port 2: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1b8002));
+        LGM_NET_DBG("ANEG Complete for Port 2: 0x%x\n",(read_val & 0x1));
+
+        read_val = __usxgmii_fabric_rd(pdata, 0x1c8002); //VR_MII_3_AN_INTR_STS
+        LGM_NET_DBG("ANEG reg value Port 3: 0x%x\n",__usxgmii_fabric_rd(pdata, 0x1c8002));
+        LGM_NET_DBG("ANEG Complete for Port 3: 0x%x\n",(read_val & 0x1));
+#endif /* LGM_NET_VERBOSE */
+}
+
+static void disable_ieee(struct mac_prv_data *pdata, int phy_addr)
+{
+	int port;
+
+	/* disable ieee for 1G */
+	for (port = phy_addr + 3; port >= phy_addr; port--)
+		mdio_write(pdata, 0x7, port, 0x3c, 0x0);
+
+	/* disable ieee for 2.5G */
+	for (port = phy_addr + 3; port >= phy_addr; port--)
+		mdio_write(pdata, 0x7, port, 0x3e, 0x0);
+}
+
+static void disable_2p5g_advert(struct mac_prv_data *pdata,
+				 bool *aneg_ports, int phy_addr)
+{
+	int port, max_port = P34X_MAX_PORT;
+	u16 mmd_reg = (MS_MAN_EN_MASK | FR_MASK);
+
+	for (port = phy_addr; port < phy_addr + max_port; port++) {
+		if (aneg_ports[port - phy_addr] == true)
+			mdio_write(pdata, MDIO_MMD_AN, port,
+				   ANEG_MGBT_AN_CTRL_REG, mmd_reg);
+	}
+}
+
+void switch_reset_toggle(void)
+{
+	u32 value;
+
+	/* release gswip, dma1 rx/tx out of reset */
+	value = readl(RCU_RST_REQ_ETHNOC);
+	value |= RST_REQ_ETHNOC_GSWIPO_MASK;
+	writel(value, RCU_MODULE_BASE + RST_REQ_ETHNOC);
+
+	mdelay(10);
+
+	value &= ~(RST_REQ_ETHNOC_GSWIPO_MASK);
+	writel(value, RCU_MODULE_BASE + RST_REQ_ETHNOC);
+}
+
+#define MAX_NUM_PHY		4
+#define PHY_LED			0x1B	/* LED control */
+#define GPY_LED_MAX	2
+#define VSPEC1_LED0	0x01
+#define VSPEC1_LED1	0x02
+#define VSPEC1_LED2	0x03
+#define VSPEC1_LED_CON_LINK10	BIT(4)
+#define VSPEC1_LED_CON_LINK100	BIT(5)
+#define VSPEC1_LED_CON_LINK1000	BIT(6)
+#define VSPEC1_LED_CON_LINK2500	BIT(7)
+#define VSPEC1_LED_TXACT	BIT(8)
+#define VSPEC1_LED_RXACT	BIT(9)
+
+static void slim_phy_write_mmd(struct mac_prv_data *pdata,
+			 u32 dev_adr,
+			 u32 phy_reg,
+			 u32 phy_reg_data)
+{
+	u32 phy_id;
+
+	for (phy_id = 0; phy_id < MAX_NUM_PHY; phy_id++)
+	{
+		mdio_write(pdata, dev_adr, phy_id, phy_reg, phy_reg_data);
+	}
+}
+
+static void slim_phy_modify(struct mac_prv_data *pdata,
+			int phy_addr,
+			 u32 phy_reg,
+			 u32 and_mask,
+			 u32 or_value)
+{
+	u32 phy_data = 0;
+
+	mdio_read(pdata, 0, phy_addr, phy_reg, &phy_data);
+
+	phy_data &= ~and_mask;
+	phy_data |= or_value;
+
+	mdio_write(pdata, 0, phy_addr, phy_reg, phy_data);
+}
+
+/* Configure default behavior of LED and board-specific setting */
+static int gphy_config_led(struct mac_prv_data *pdata, int phy_addr)
+{
+	int val;
+	int inv = CONFIG_GPHY_LED_INV_VALUE;
+
+	/* all-links + tx/rx activity */	
+	val = VSPEC1_LED_CON_LINK10 | VSPEC1_LED_CON_LINK100 |
+	      VSPEC1_LED_CON_LINK1000 | VSPEC1_LED_CON_LINK2500 |
+	      VSPEC1_LED_TXACT | VSPEC1_LED_RXACT;
+
+	slim_phy_write_mmd(pdata, MDIO_MMD_VEND1, VSPEC1_LED0, val);
+
+	/* 1000 link */
+	val = VSPEC1_LED_CON_LINK1000;
+	slim_phy_write_mmd(pdata, MDIO_MMD_VEND1, VSPEC1_LED1, val);
+
+	/* 2500 link */
+	val = VSPEC1_LED_CON_LINK2500;
+	slim_phy_write_mmd(pdata, MDIO_MMD_VEND1, VSPEC1_LED2, val);
+
+	slim_phy_modify(pdata, phy_addr, PHY_LED, GENMASK(14, 12), inv << 12);
+
+	return 0;
+}
+
+void p34x_hrst(void)
+{
+	u32 reg;
+	reg = readl(RCU_RST_REQ_TNOC);
+	reg |= RST_REQ_TNOC_HRST_MASK;
+	writel(reg, RCU_RST_REQ_TNOC);
+	reg &= ~(RST_REQ_TNOC_HRST_MASK);
+	writel(reg, RCU_RST_REQ_TNOC);
+}
+
+static void disable_2p5g(bool *aneg_ports, struct mac_prv_data *pdata, int phy_addr)
+{
+	/* force 1G BaseT auto neg if selected in menuconf */
+	/* seem like ANEG advertisement of 2.5G & 5G are turn off */
+
+	#if CONFIG_IS_ENABLED(LGM_P34X_P1_25G_OFF)
+	aneg_ports[0] = true;
+        #endif /* CONFIG_IS_ENABLED() */
+	#if CONFIG_IS_ENABLED(LGM_P34X_P2_25G_OFF)
+	aneg_ports[1] = true;
+        #endif /* CONFIG_IS_ENABLED() */
+	#if CONFIG_IS_ENABLED(LGM_P34X_P3_25G_OFF)
+	aneg_ports[2] = true;
+	#endif /* CONFIG_IS_ENABLED() */
+	#if CONFIG_IS_ENABLED(LGM_P34X_P4_25G_OFF)
+	aneg_ports[3] = true;
+	#endif /* CONFIG_IS_ENABLED() */
+	disable_2p5g_advert(pdata, &aneg_ports[0], phy_addr);
+	gswip_force_autoneg(pdata, phy_addr);
+}
+
+void p34x_mb_wr(u32 mb_addr, u32 bit_pos, u32 bit_value)
+{
+	u32 data;
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	u32 dev_addr, phy_addr;
+	u32 reg_addr_LA, reg_addr_HA, reg_addr_DATA;
+	dev_addr = 0x1E;
+	phy_addr = 0x10;
+	reg_addr_LA = 0x6;
+	reg_addr_HA = 0x7;
+	reg_addr_DATA = 0x5;
+
+	mdio_write(pdata, dev_addr, phy_addr, reg_addr_LA, mb_addr & 0xffff);
+	mdio_write(pdata, dev_addr, phy_addr, reg_addr_HA, (mb_addr >> 16) & 0xffff);
+	mdio_read(pdata, dev_addr, phy_addr, reg_addr_DATA, &data);
+
+	data &= ~(1 << bit_pos);
+	data |= (bit_value << bit_pos);
+
+	mdio_write(pdata, dev_addr, phy_addr, reg_addr_DATA, data);
+	mdio_write(pdata, dev_addr, phy_addr, reg_addr_LA, mb_addr & 0xffff);
+	mdio_write(pdata, dev_addr, phy_addr, reg_addr_HA, (0x0100 | (mb_addr >> 16)) & 0xffff);
+}
+
+#define MAX_BUSY_RETRY           100
+#define RETURN_FROM_FUNC   1
+
+static int __is_mbox_busy(struct mac_prv_data *pdata, u8 action)
+{
+     int retCode = 0;
+
+     do {
+           u32 value = 0;
+           u32 busyRetry = MAX_BUSY_RETRY;
+
+           do {
+                //retCode = PHY_READ_MMD(phy, 30, 7);
+				mdio_read(pdata, 30, pdata->phy_id, 7, &retCode);
+
+                if (retCode < 0)
+                      return retCode;
+
+                value = retCode;
+                value = value & 0x8000u;
+           } while ((!value) && (--busyRetry));
+
+           if ((!value && !busyRetry)) {
+                printf("\nERROR: MBOX busy for too long @ ");
+                printf("%s %d\n", __func__, __LINE__);
+
+                if (RETURN_FROM_FUNC == action)
+                      return -1;
+
+                retCode = -1;
+           }
+     } while (0);
+
+     return retCode;
+}
+
+static int gpy2xx_mbox_read16(struct mac_prv_data *pdata, u32 regaddr, u32 *data)
+{
+     int ret;
+     u32 _mbox_cmd = 0;
+
+     u16 data_low = 0;
+     u16 addr_high = regaddr >> 16;
+     u16 addr_low = regaddr & 0xFFFF;
+
+     //Address to read
+     //ret = PHY_WRITE_MMD(phy, 30, 6, addr_low);
+	 mdio_write(pdata, 30, pdata->phy_id, 6, addr_low);
+
+     _mbox_cmd |= addr_high & 0xFFu;
+     _mbox_cmd |= 0 << 8;  // read command
+
+     //ret = PHY_WRITE_MMD(phy, 30, 7, _mbox_cmd);
+	 mdio_write(pdata, 30, pdata->phy_id, 7, _mbox_cmd);
+	 
+     if (__is_mbox_busy(pdata, RETURN_FROM_FUNC) < 0) {
+           return -1;
+     }
+
+     //Read Low-Data
+     //ret = PHY_READ_MMD(phy, 30, 5);
+	 mdio_read(pdata, 30, pdata->phy_id, 5, &ret);
+
+     if (ret < 0)
+           return ret;
+
+     data_low = ret;
+
+     *data = data_low;
+
+     return 0;
+}
+
+void p34x_set_voltage(void)
+{
+	u32 gpio2_val = 0;
+	u32 gpio26_val = 0;
+
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	u32 pvt_value = 0;
+
+	gpy2xx_mbox_read16(pdata, 0xD288B4, &pvt_value);
+
+	/*
+		LMTSYS-7170 gphy voltage control table in octopus schematic is wrong
+		
+		641 table
+		Case 	PVT Code	 Core Voltage 	 GPIO26/GPIO2
+		1		< = 301			1V				1 / 1
+		2		302-324			0.95V			0 / 1
+		3		325-346			0.9V			1 / 0 
+		4		> 346			0.85V			0 / 0
+
+		851 table
+		Case 	PVT Code	 Core Voltage 	 GPIO26/GPIO2
+		1		< = 301			1V				1 / 1
+		2		302-324			0.95V			1 / 0
+		3		325-346			0.9V			0 / 1 
+		4		> 346			0.85V			0 / 0
+	*/
+
+	if (pvt_value <= 301)
+	{
+		gpio26_val = 1;	
+		gpio2_val = 1;
+	}
+	else if ((pvt_value >= 302) && (pvt_value <= 324))
+	{
+		if (cpu_is_urx6x1())
+		{
+			gpio26_val = 0;	
+			gpio2_val = 1;
+		}
+		else
+		{
+			gpio26_val = 1;	
+			gpio2_val = 0;
+		}	
+	}
+	else if ((pvt_value >= 325) && (pvt_value <= 346))
+	{
+		if (cpu_is_urx6x1())
+		{
+			gpio26_val = 1;	
+			gpio2_val = 0;
+		}
+		else
+		{
+			gpio26_val = 0;	
+			gpio2_val = 1;
+		}	
+	}
+	else /* (pvt_value > 346) */
+	{
+		gpio26_val = 0;	
+		gpio2_val = 0;
+	}
+		
+/*set p34x gpio26*/
+	p34x_mb_wr(GPIO_PDI_REGISTERS_GPIO2_ALTSEL1, 10, 0);
+	p34x_mb_wr(GPIO_PDI_REGISTERS_GPIO2_ALTSEL0, 10, 0);
+	p34x_mb_wr(GPIO_PDI_REGISTERS_GPIO2_DIR, 10, 1);
+	p34x_mb_wr(GPIO_PDI_REGISTERS_GPIO2_OUT, 10, gpio26_val);
+/*set p34x gpio2*/
+	p34x_mb_wr(GPIO_PDI_REGISTERS_GPIO_ALTSEL1, 2, 0);
+	p34x_mb_wr(GPIO_PDI_REGISTERS_GPIO_ALTSEL0, 2, 0);
+	p34x_mb_wr(GPIO_PDI_REGISTERS_GPIO_DIR, 2, 1);
+	p34x_mb_wr(GPIO_PDI_REGISTERS_GPIO_OUT, 2, gpio2_val);
+}
+
+int internal_fw_load(void)
+{
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	int ret;
+	/* TODO: Remove CONFIG_ENABLED after fuse issue is fixed */
+	if ((!CONFIG_IS_ENABLED(BOARD_OCTOPUS) && (!cpu_is_urx6x1()))
+		|| !CONFIG_IS_ENABLED(EXTERNAL_P34X_ATTACHED)) {
+
+		ret = gswip_load_firmware(&pdata[0]);
+		if (ret)
+			return -1;
+		gphy_usxgmii_en(&pdata[0]);
+		smdio_write(&pdata[0], 0x0, 0x1f, 0xa501, 0x1070);
+	}
+	return 0;
+}
+
+int external_fw_load(void)
+{
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	int ret;
+
+	ret = gswip_load_firmware_mxl86249(&pdata[0]);
+	if (ret)
+		return -1;
+	gphy_usxgmii_en(&pdata[0]);
+	smdio_write(&pdata[0], 0x0, 0x1f, 0xa501, 0x1070);
+
+	return 0;
+}
+
+u32 show_phy_id(void)
+{
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	u32 testdata;
+	mdio_read(pdata, 0, pdata->phy_id, 3, &testdata);
+	return testdata;
+}
+
+#endif
+
+#ifdef CONFIG_WAN_XPCS
+static void configure_wan_select(struct udevice *dev)
+{
+#ifdef CONFIG_DM_GPIO
+	struct gpio_desc gpio_pin;
+	/*gpio38, 0=wan eth, 1=wan sfp*/
+	gpio_request_by_name(dev, "wan-sel-gpio", 0,
+			     &gpio_pin, GPIOD_IS_OUT);
+
+#ifdef CONFIG_WAN_SFP
+	/*wan using sfp*/
+	dm_gpio_set_value(&gpio_pin, 1);
+
+	/*gpio73, 0=tx enable, 1=tx disable*/
+	gpio_request_by_name(dev, "tx-disable-gpios", 0,
+			     &gpio_pin, GPIOD_IS_OUT);
+	dm_gpio_set_value(&gpio_pin, 0);
+
+	gpio_request_by_name(dev, "los-gpios", 0,
+			     &gpio_pin, GPIOD_IS_IN);
+	gpio_request_by_name(dev, "mod-def0-gpios", 0,
+			     &gpio_pin, GPIOD_IS_IN);
+	gpio_request_by_name(dev, "tx-fault-gpios", 0,
+			     &gpio_pin, GPIOD_IS_IN);
+#else
+	/*wan using eth*/
+	dm_gpio_set_value(&gpio_pin, 0);
+#endif
+#else
+	int gpio_pin;
+
+	/*gpio38, 0=wan eth, 1=wan sfp*/
+	if (IS_ENABLED(CONFIG_BOARD_OCTOPUS))
+		gpio_pin = 38;
+	else
+		gpio_pin = 73;
+	/* octopus: set gpio38=0 use wan rj45,
+	 * lgp: set gpio73=0 use wan rj45,
+	 * set gpio38=1 use wan sfp
+	*/
+	config_gpio(gpio_pin, GPIO_OUTPUT_DIR, 0);
+#ifdef CONFIG_WAN_SFP
+	/*wan using sfp*/
+	gpio_direction_output(gpio_pin, 1);
+
+	/*gpio73, 0=tx enable, 1=tx disable*/
+	config_gpio(73, GPIO_OUTPUT_DIR, 0);
+	gpio_direction_output(73, 0);
+
+	/*los,input to lgm*/
+	config_gpio(69, GPIO_INPUT_DIR, 0);
+	/*tx fault,input to lgm*/
+	config_gpio(72, GPIO_INPUT_DIR, 0);
+	/*mode def0,input to lgm*/
+	config_gpio(82, GPIO_INPUT_DIR, 0);
+
+#else
+	/*wan using eth*/
+	gpio_direction_output(gpio_pin, 0);
+
+#endif
+#endif
+}
+#endif /* CONFIG_WAN_XPCS */
+
+#if defined(CONFIG_LAN_HSIO_R_USXGMII_10G) || defined(CONFIG_WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G) || defined(CONFIG_XPCS5_USXGMII_RTL8261)
+int lightning_mountain_mdio_cfg(struct udevice *dev)
+{
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	u32 value,value2;
+	int phy_addr = priv->phy_addr;
+
+	/* release gswip, dma1 rx/tx out of reset */
+	value = readl(RCU_RST_REQ_ETHNOC);
+	value2 = value;
+	value &= (0xFFFFFEF0);
+	writel(value, RCU_MODULE_BASE + RST_REQ_ETHNOC);
+
+/*init aqn phy regs*/
+	mdio_write(pdata, 0x1e, phy_addr, 0x31a, 0x3);
+	mdio_write(pdata, 0x1e, phy_addr, 0x31b, 0xc0);
+	mdio_write(pdata, 0x1e, phy_addr, 0x31c, 0xc0);
+	mdio_write(pdata, 0x1e, phy_addr, 0x31d, 0xc0);
+	mdio_write(pdata, 0x1e, phy_addr, 0x31e, 0xc0);
+	mdio_write(pdata, 0x1e, phy_addr, 0x31f, 0xc0);
+	mdio_write(pdata, 0x4, phy_addr, 0xc441, 0x8);
+	mdio_write(pdata, 0x1e, phy_addr, 0x0, 0x0);
+
+/*init aic rtl8261 phy regs*/
+	mdelay(100);
+	mdio_write(pdata, 0x1e, phy_addr, 0x0141, 0x8003);
+	mdio_write(pdata, 0x1e, phy_addr, 0x0143, 0x8c07);
+
+	writel(value2, RCU_MODULE_BASE + RST_REQ_ETHNOC);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_OCTOPUS_I2C_CONTROL_PCIE
+#if CONFIG_IS_ENABLED(DM_I2C)
+extern int octopus_i2c_control_pcie(void);
+extern int hsec8_mxl3710_aic_init(void);
+#endif
+#endif
+
+#if defined(CONFIG_HSIO1_XPCS1_HSIO3_PHY0_C10)
+u32 AN_speed = 0;
+u32 gpy215_mdio_setting = 0;
+
+u32 read_AN_speed(u32 phy_addr)
+{
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	u32 reg_value;
+	u32 clause = 0;/*0=clause 45 , 1=clause 22*/
+
+	mdio_set_clause(pdata,clause, phy_addr);
+	mdelay(1);
+	mdio_read(pdata, 0x1e, phy_addr, 0x9, &reg_value);
+	return (reg_value & 0x3);
+}
+
+int gpy215_mdio_cfg(struct udevice *dev)
+{
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	u32 value,value2,reg_value=0x55aa;
+	int phy_addr = priv->phy_addr;
+	u32 clause_22 = 1;
+	u32 clause_45 = 0;
+
+	/* release gswip, dma1 rx/tx out of reset */
+	value = readl(RCU_RST_REQ_ETHNOC);
+	value2 = value;
+	value &= (0xFFFFFEF0);
+	writel(value, RCU_MODULE_BASE + RST_REQ_ETHNOC);
+
+/*init aic rtl8261 phy regs*/
+	mdelay(100);
+
+	if (gpy215_mdio_setting == 1){
+		mdio_set_clause(pdata,clause_45, phy_addr);
+		mdelay(1);
+		mdio_write(pdata, 0x1e, phy_addr, 0x1, 0x3f0);
+		mdio_write(pdata, 0x1e, phy_addr, 0x2, 0x40);
+		mdio_write(pdata, 0x1e, phy_addr, 0x3, 0x80);
+
+		mdio_set_clause(pdata,clause_22, phy_addr);
+		mdelay(1);
+		mdio_write(pdata, 0x0, phy_addr, 0x19, 0x0);
+		mdio_read(pdata, 0x0, phy_addr, 0x1a, &reg_value);
+		mdio_write(pdata, 0x0, phy_addr, 0x19, 0x0);
+		mdio_write(pdata, 0x0, phy_addr, 0x19, 0x0);
+		mdio_read(pdata, 0x0, phy_addr, 0x0, &reg_value);
+		mdio_read(pdata, 0x0, phy_addr, 0x0, &reg_value);
+
+		mdio_set_clause(pdata,clause_45, phy_addr);
+		mdelay(1);
+		mdio_read(pdata, 0x7, phy_addr, 0x10, &reg_value);
+		mdio_write(pdata, 0x7, phy_addr, 0x10, 0xde1);
+		mdio_read(pdata, 0x7, phy_addr, 0x20, &reg_value);
+
+		mdio_set_clause(pdata,clause_22, phy_addr);
+		mdelay(1);
+		mdio_read(pdata, 0x0, phy_addr, 0x9, &reg_value);
+		mdio_write(pdata, 0x0, phy_addr, 0x9, 0x200);
+
+		mdio_set_clause(pdata,clause_45, phy_addr);
+		mdelay(1);
+		mdio_read(pdata, 0x7, phy_addr, 0x0, &reg_value);
+		mdio_write(pdata, 0x7, phy_addr, 0x0, 0x3200);
+
+		mdio_write(pdata, 0x1e, phy_addr, 0x8, 0x24da);
+	}
+
+	mdio_set_clause(pdata,clause_22, phy_addr);
+	mdelay(1);
+	mdio_read(pdata, 0x0, phy_addr, 0x0, &reg_value);
+	mdio_read(pdata, 0x0, phy_addr, 0x1, &reg_value);
+	mdio_read(pdata, 0x0, phy_addr, 0x18, &reg_value);
+
+	mdio_set_clause(pdata,clause_45, phy_addr);
+	mdelay(1);
+	mdio_read(pdata, 0x7, phy_addr, 0x1, &reg_value);
+	mdio_read(pdata, 0x7, phy_addr, 0x13, &reg_value);
+	mdio_read(pdata, 0x7, phy_addr, 0x21, &reg_value);
+
+	mdio_set_clause(pdata,clause_22, phy_addr);
+	mdelay(1);
+	mdio_read(pdata, 0x0, phy_addr, 0xa, &reg_value);
+
+
+	mdio_set_clause(pdata,clause_45, phy_addr);
+	mdelay(1);
+	mdio_read(pdata, 0x1e, phy_addr, 0x8, &reg_value);
+
+	mdio_set_clause(pdata,clause_22, phy_addr);
+	mdelay(1);
+	mdio_read(pdata, 0x0, phy_addr, 0x13, &reg_value);
+
+	mdio_set_clause(pdata,clause_45, phy_addr);
+	mdelay(1);
+	mdio_read(pdata, 0x1, phy_addr, 0x82, &reg_value);
+
+	if ((gpy215_mdio_setting == 0) && (gpy215_sgmii_1g == 1)){
+		mdelay(3800);/*delay to let auto negotiate complete to find out connected port speed*/
+		AN_speed = read_AN_speed(phy_addr);/*gpy215 phy addr=0x1b*/
+		/*printf("2:1g, 3:2.5g , read_AN_speed(0x1b)=0x%x \n", AN_speed);*/
+	}
+
+	writel(value2, RCU_MODULE_BASE + RST_REQ_ETHNOC);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_XPCS5_USXGMII_RTL8261
+int xpcs5_rtl8261_init(struct udevice *dev)
+{
+	int ret;
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	int i, val;
+	pdata->phy_id = priv->phy_addr;
+	sso_init(0);
+	sso_output(18, 1, 255);	/*release from reset, sso 18=lan rtl8261 reset pin*/
+	config_gpio(15, GPIO_OUTPUT_DIR, 0);/*GPIO15, 0 = rtl8261, 1 = external p34x.*/
+	mdelay(200);
+
+	/* Enable XGMII clk for B0 xpcs5 init */
+	writel(readl(XPCS5_CFG_REG) | CHIP_TOP_XGMII_CLK_EN,
+		XPCS5_CFG_REG);
+
+	ret = init_gswip_core(dev, &pdata[0]);
+	if (ret)
+		return -1;
+
+	val = XGMAC_RGRD(pdata, MDIO_SCCDR);
+	val &= ~MDC_CLK_DIV_MSK;
+
+	/*change MDC/MDIO (GPIO94/95) drive strength to 12 mA*/
+	REG32(GPIO_PAD_CONTROL_DCC_5) |= 0xf0000000;
+	/*change MDC frequency to 5.56MHz*/
+	val |= 0x80380000;
+
+	XGMAC_RGWR(pdata, MDIO_SCCDR, val);
+
+	gswip_xpcs5_init_rtl8261(0);
+
+	for (i = MAC_START; i < MAC_LAST; i++) {
+		xgmac_powerup(&xgmac_prv_data[i]);
+	}
+
+	lightning_mountain_mdio_cfg(dev);
+	combophy_hsio_init_xpcs5_rtl8261(0);
+	return 0;
+}
+#endif
+
+int lightning_mountain_sw_init(struct udevice *dev)
+{
+	int ret;
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+
+	if (!priv)
+		return -EINVAL;
+
+#ifdef CONFIG_OCTOPUS_I2C_CONTROL_PCIE
+#if CONFIG_IS_ENABLED(DM_I2C)
+	hsec8_mxl3710_aic_init();
+	//octopus_i2c_control_pcie();
+#endif
+#endif
+
+#ifdef CONFIG_LGM_P34X_SUPPORT
+	struct mac_prv_data *pdata = &xgmac_prv_data[0];
+	/* config all ports to @ 2.5g */
+	bool aneg_ports[P34X_MAX_PORT] = {false, false, false, false};
+	int i, val;
+	pdata->phy_id = priv->phy_addr;
+	
+#if !defined(CONFIG_LIGHTNING_A0)
+	/* Enable XGMII clk for B0 P34X init */
+	writel(readl(XPCS5_CFG_REG) | CHIP_TOP_XGMII_CLK_EN,
+		XPCS5_CFG_REG);
+#endif
+
+	/*toggle HRST to reset p34x after switch init to make it stable.*/
+	if ((!CONFIG_IS_ENABLED(BOARD_OCTOPUS) && (!cpu_is_urx6x1()))
+		|| !CONFIG_IS_ENABLED(EXTERNAL_P34X_ATTACHED)) {
+		p34x_hrst();
+	}
+	printf("p34x-lan loading gphy fw version: ");
+
+	ret = init_gswip_core(dev, &pdata[0]);
+	if (ret)
+		return -1;
+
+	val = XGMAC_RGRD(pdata, MDIO_SCCDR);
+	val &= ~MDC_CLK_DIV_MSK;
+#ifdef CONFIG_BOARD_OCTOPUS
+
+	/*change MDC/MDIO (GPIO94/95) drive strength to 12 mA*/
+	REG32(GPIO_PAD_CONTROL_DCC_5) |= 0xf0000000;
+
+	if(cpu_is_lgmc()){
+		/*change MDC frequency to 25MHz, octopus 640 add clk buffer to MDC*/
+		val |= 0x80000000;
+	} else {
+		/*change MDC frequency to 5.56MHz, some octopus 641 has no clk buffer in MDC*/
+		val |= 0x80380000;
+	}
+	/* Octopus 640 has a lan select swith to switch between
+	 * RTL8261 or MXL86249
+	*/
+	if (IS_ENABLED(CONFIG_DM_GPIO)) {
+		struct gpio_desc lan_sel_gpio;
+
+		gpio_request_by_name(dev, "lan-serdes5-sel-gpio", 0,
+				&lan_sel_gpio,
+				GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	} else {
+		config_gpio(15, GPIO_OUTPUT_DIR, 1);
+	}
+#else
+/*change MDC frequency to 25MHz*/
+	val |= 0x80000000;
+#endif
+	XGMAC_RGWR(pdata, MDIO_SCCDR, val);
+
+	gswip_xpcs5_init(0);
+
+	for (i = MAC_START; i < MAC_LAST; i++) {
+		xgmac_powerup(&xgmac_prv_data[i]);
+	}
+
+	/* 2 functions is a WA for ieee issue, shall be fixed in FW when it
+	 * is available
+	 */
+	disable_ieee(pdata, priv->phy_addr);
+	disable_2p5g(aneg_ports, pdata, priv->phy_addr);
+
+	gphy_config_led(pdata, priv->phy_addr);
+
+	gphy_usxgmii_lb_en(pdata);
+
+#endif /* CONFIG_LGM_P34X_SUPPORT */
+
+#ifdef CONFIG_XPCS5_USXGMII_RTL8261
+	xpcs5_rtl8261_init(dev);
+#endif /*CONFIG_XPCS5_USXGMII_RTL8261*/
+
+#ifdef CONFIG_LAN_HSIO_R
+	printf("lan1 P20/21 ");
+	gpy215_sgmii_1g = 0;
+#ifdef CONFIG_LAN_HSIO_R_USXGMII_10G
+	lightning_mountain_mdio_cfg(dev);
+#endif
+	combophy_hsio_init(0);
+#endif
+
+#ifdef CONFIG_LAN_HSIO_L
+	printf("lan0 P10/11 ");
+
+#ifdef CONFIG_LGMC_SGMII
+	LGMC_SGMII_CONNECTION_SEL_t 	lgmc_sgmii_connection;
+	LGMC_SGMII_SPEED_SEL_t		lgmc_sgmii_speed;
+	sso_init(0);
+#ifdef CONFIG_HSIO1_XPCS1_HSIO3_PHY0_C10
+	lgmc_sgmii_connection = HSIO1_XPCS1_HSIO3_PHY0_C10;
+	sso_output(16, 1, 255);	/*release from reset,24-8=16, gpio16=gpy215 reset pin*/
+#else
+	lgmc_sgmii_connection = HSIO2_XPCS1_HSIO4_PHY0_C10;
+	sso_output(17, 1, 255);	/*gpio pin,value,duty cycle.release from reset,25-8=17, gpio17=gsw120 reset pin*/
+#endif /* CONFIG_HSIO1_XPCS1_HSIO3_PHY0_C10 */
+
+	lgmc_sgmii_speed = LGMC_SGMII_1G;
+	mdelay(50);
+#if defined(CONFIG_HSIO1_XPCS1_HSIO3_PHY0_C10)
+	gpy215_mdio_setting = 1;
+	gpy215_mdio_cfg(dev);
+#endif
+#endif
+	/*1g sgmii setting*/
+	combophy_hsio_c10phy_init(lgmc_sgmii_connection);
+set_2g5:
+	if (gpy215_sgmii_1g == 0){
+		REG32(0xd0c40008) &= ~0x2;//SRAM_LOAD_DONE=0x2
+		combophy_hsio_init(1);
+	}
+#endif
+
+/* TODO: using command to select speed */
+#ifdef CONFIG_WAN_XPCS
+	configure_wan_select(dev);
+	mdelay(10);
+ #ifdef CONFIG_XFI_10G_KR_NO_ANEG
+  #ifdef CONFIG_WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G
+	printf("init wan xpcs usxgmii phy \n");
+	lightning_mountain_mdio_cfg(dev);
+  #else
+	printf("wan no-autoneg 10G ");
+  #endif /* CONFIG_WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G */
+	wan_init(XFI_10G_KR_NO_ANEG);
+ #elif CONFIG_SGMII_1000BASEX
+	wan_init(SGMII_1000BASEX);
+ #elif (CONFIG_SGMII_1G)
+	printf("wan no-autoneg 1G ");
+	wan_init(SGMII_1G); /* bring-up */
+ #endif /* CONFIG_XFI_10G_KR_NO_ANEG */
+#endif /* CONFIG_WAN_XPCS */
+
+#ifdef CONFIG_LGMC_SGMII
+	if (gpy215_sgmii_1g == 0){
+#ifdef CONFIG_HSIO2_XPCS1_HSIO4_PHY0_C10
+	LGMC_SGMII_CONNECTION_SEL_t 	lgmc_sgmii_connection;
+	LGMC_SGMII_SPEED_SEL_t		lgmc_sgmii_speed;
+#endif
+	sso_init(0);
+#ifdef CONFIG_HSIO1_XPCS1_HSIO3_PHY0_C10
+	lgmc_sgmii_connection = HSIO1_XPCS1_HSIO3_PHY0_C10;
+	sso_output(16, 1, 255);	/*release from reset,24-8=16, gpio16=gpy215 reset pin*/
+#else
+	lgmc_sgmii_connection = HSIO2_XPCS1_HSIO4_PHY0_C10;
+	sso_output(17, 1, 255);	/*gpio pin,value,duty cycle.release from reset,25-8=17, gpio17=gsw120 reset pin*/
+#endif /* CONFIG_HSIO1_XPCS1_HSIO3_PHY0_C10 */
+
+	lgmc_sgmii_speed = LGMC_SGMII_2G5;
+	mdelay(50);
+#if defined(CONFIG_HSIO1_XPCS1_HSIO3_PHY0_C10)
+	gpy215_mdio_setting = 1;
+	gpy215_mdio_cfg(dev);
+#endif
+	lgmc_sgmii_init(lgmc_sgmii_connection, lgmc_sgmii_speed);
+	}
+#endif /*CONFIG_LGMC_SGMII*/
+
+/* For P34X the switch core is initialized before
+ * the mac and xpcs settings.
+ * In other modes, this is done in reverse
+ */
+#if !defined(CONFIG_LGM_P34X_SUPPORT)
+	u32 value;
+	unsigned int num_ports, vports, total_ports;
+
+	/* release gswip, dma1 rx/tx out of reset */
+	value = readl(RCU_RST_REQ_ETHNOC);
+	value &= (0xFFFFFEF0);
+	writel(value, RCU_MODULE_BASE + RST_REQ_ETHNOC);
+
+        gsw_r32(priv->gswip_o_base, ETHSW_CAP_1_PPORTS_OFFSET,
+                ETHSW_CAP_1_PPORTS_SHIFT,
+                ETHSW_CAP_1_PPORTS_SIZE, &value);
+
+	num_ports = (unsigned int) value;
+        gsw_r32(priv->gswip_o_base, ETHSW_CAP_1_VPORTS_OFFSET,
+		ETHSW_CAP_1_VPORTS_SHIFT,
+                ETHSW_CAP_1_VPORTS_SIZE, &value);
+	vports = (unsigned int) value;
+	total_ports = num_ports + vports;
+
+	LGM_NET_DBG("num ports = %d, vports = %d\n", num_ports, vports);
+	LGM_NET_DBG("Initialize microcode for %d ports\n", total_ports);
+	/* microcode init */
+	ret = lightning_mountain_load_microcode(dev, num_ports);
+	if (ret)
+		return ret;
+	/* mac init */
+	ret = lightning_mountain_mac_config(dev);
+	if (ret)
+		return ret;
+	/* enable switch */
+	ret = lightning_mountain_switch_enable(dev, total_ports);
+	if (ret)
+		return ret;
+#endif
+	/* configure QoS queue to prevent buffer overflow */
+	gswip_qos_wred_config(dev);
+
+	/* Init DMA */
+	ret = lightning_mountain_dma_init(dev);
+	if (ret)
+		return ret;
+
+	/* added for LMAC NCO change to support 100BT & 10BT */
+	REG32(GSWIP_O_SUBSYSTEM_NCO3_LSB) = 0x5555;
+	REG32(GSWIP_O_SUBSYSTEM_NCO3_MSB) = 0x35;
+	REG32(GSWIP_O_SUBSYSTEM_NCO4_LSB) = 0xaaaa;
+	REG32(GSWIP_O_SUBSYSTEM_NCO4_MSB) = 0x6a;
+
+#ifdef CONFIG_LGM_P34X_SUPPORT	
+	mdelay(3);
+	/* set p34x gpio voltage settings */
+	p34x_set_voltage();
+	/* set serdes tune value if needed */
+	p34x_serdes_tune(pdata, 0x8, pdata->phy_id, priv->p34x_tune_val);
+#endif /* CONFIG_LGM_P34X_SUPPORT */
+
+#if defined(CONFIG_HSIO1_XPCS1_HSIO3_PHY0_C10)
+	gpy215_mdio_setting = 0;
+	gpy215_mdio_cfg(dev);
+	if((AN_speed != 2) && (gpy215_sgmii_1g == 1)){
+		gpy215_sgmii_1g = 0;
+		goto set_2g5;
+
+	}
+
+	if(gpy215_sgmii_1g == 1)
+		printf("\nHSIOL XPCS1 1g sgmii AN is up.\n");
+
+#endif
+
+#ifdef CONFIG_LGM_P34X_SUPPORT
+	usxgmii_stat_chk(5, KR_10G, &g_usxspeed_defs[0]);
+	echo_gphy_fw_version(pdata, priv->phy_addr);
+#endif /* CONFIG_LGM_P34X_SUPPORT */
+
+	return 0;
+}
+
+int lightning_mountain_mdio_read(struct mii_dev *bus, int phy_addr, int dev_addr,
+			int reg_addr)
+{
+	int ret;
+	u32 data;
+	struct mac_prv_data *pdata;
+
+	if (!strncmp(bus->name, "mdio0", 8)) {
+		pdata = &xgmac_prv_data[0];
+	} else if (!strncmp(bus->name, "mdio1", 8)) {
+		pdata = &xgmac_prv_data[1];
+	} else {
+		printf("Wrong devname: %s\n", bus->name);
+		return -EINVAL;
+	}
+
+	ret = mdio_read(pdata, dev_addr, phy_addr, reg_addr, &data);
+	if (ret)
+		return ret;
+
+	return (int)data;
+}
+
+int lightning_mountain_mdio_write(struct mii_dev *bus, int phy_addr, int dev_addr,
+			int reg_addr, u16 data)
+{
+	struct mac_prv_data *pdata;
+
+	if (!strncmp(bus->name, "mdio0", 8)) {
+		pdata = &xgmac_prv_data[0];
+	} else if (!strncmp(bus->name, "mdio1", 8)) {
+		pdata = &xgmac_prv_data[1];
+	} else {
+		printf("Wrong devname: %s\n", bus->name);
+		return -EINVAL;
+	}
+
+	mdio_write(pdata, dev_addr, phy_addr, reg_addr, data);
+	return 0;
+}
+
+int lightning_mountain_mdio_init(struct udevice *dev, char *mdio_name)
+{
+	int ret;
+	struct gpio_desc mdio_gpio, mdc_gpio;
+	struct mii_dev *bus;
+
+	bus = mdio_alloc();
+	if (!bus) {
+		printf("Error allocating mdio\n");
+		return -ENOMEM;
+	}
+
+	if (IS_ENABLED(CONFIG_DM_GPIO)) {
+		gpio_request_by_name(dev, "mdc-lan", 0,
+				     &mdc_gpio, GPIOD_IS_OUT);
+		gpio_request_by_name(dev, "mdio-lan", 0,
+				     &mdio_gpio, GPIOD_IS_OUT);
+	} else {
+		/* gpio 94 MDC */
+		REG32(GPIO_PAD_CONTROL_PORTMUXC94) = 0x1;
+		/* gpio 95 MDIO */
+		REG32(GPIO_PAD_CONTROL_PORTMUXC95) = 0x1;
+	}
+
+	bus->read = lightning_mountain_mdio_read;
+	bus->write = lightning_mountain_mdio_write;
+	strlcpy(bus->name, mdio_name, 6);
+
+	ret = mdio_register(bus);
+	if (ret) {
+		printf("mdio register failed\n");
+		free(bus);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lightning_mountain_eth_probe(struct udevice *dev)
+{
+	struct lightning_mountain_eth_priv *priv = dev_get_priv(dev);
+	void *blob = (void *)gd->fdt_blob;
+	int node = dev_of_offset(dev);
+	unsigned long addr, size;
+	const char *list, *end;
+	void *base;
+	const fdt32_t *cell;
+	int parent, addrc, sizec;
+	int len, ret, idx, i;
+	char mdio_name[6];
+
+	if (!priv)
+		return -EINVAL;
+
+	memset(priv, 0, sizeof(struct lightning_mountain_eth_priv));
+	parent = fdt_parent_offset(blob, node);
+	fdt_support_default_count_cells(blob, parent, &addrc, &sizec);
+	list = fdt_getprop(blob, node, "reg-names", &len);
+	if (!list)
+		return -ENOENT;
+
+	end = list + len;
+	cell = fdt_getprop(blob, node, "reg", &len);
+	if (!cell)
+		return -ENOENT;
+
+	idx = 0;
+	while (list < end) {
+		addr = fdt_translate_address((void *)blob,
+					node, cell + idx);
+		size = fdt_addr_to_cpu(cell[idx + addrc]);
+		base = map_physmem(addr, size, MAP_NOCACHE);
+		len = strlen(list);
+		if (strcmp(list, "gswip_l_base") == 0)
+			priv->gswip_l_base = (u32)base;
+		else if (strcmp(list, "gswip_o_base") == 0)
+			priv->gswip_o_base = (u32)base;
+		else if (strcmp(list, "gswip_oss_base") == 0)
+			priv->gswip_oss_base = (u32)base;
+		else if (strcmp(list, "dma_tx_base") == 0)
+			priv->dma_tx_base = (u32)base;
+		else if (strcmp(list, "dma_rx_base") == 0)
+			priv->dma_rx_base = (u32)base;
+
+		idx += addrc + sizec;
+		list += (len + 1);
+	}
+
+	LGM_NET_DBG("gswip_l_base: 0x%08x, gswip_o_base: 0x%08x\n",
+			(u32)priv->gswip_l_base, (u32)priv->gswip_o_base);
+	priv->pmac_id = fdtdec_get_int(blob, node,
+		"pmac-id", 0);
+
+	if (CONFIG_IS_ENABLED(LGM_P34X_SUPPORT)) {
+		priv->phy_addr = fdtdec_get_int(blob, node,
+					"p34x-phy-id", 0);
+		priv->p34x_tune_val = fdtdec_get_int(blob, node,
+					"p34x-serdes-tune", 0);
+	} else if (CONFIG_IS_ENABLED(WAN_XPCS))
+		priv->phy_addr = fdtdec_get_int(blob, node,
+					"wan-phy-id", 0);
+	else if (CONFIG_IS_ENABLED(LAN_HSIO_R_USXGMII_10G))
+		priv->phy_addr = fdtdec_get_int(blob, node,
+					"lan-hsio-r-phy-id", 0);
+	else if (CONFIG_IS_ENABLED(HSIO2_XPCS1_HSIO4_PHY0_C10))
+		priv->phy_addr = fdtdec_get_int(blob, node,
+					"lan-gsw120-id", 0);
+	else if (CONFIG_IS_ENABLED(HSIO1_XPCS1_HSIO3_PHY0_C10))
+		priv->phy_addr = fdtdec_get_int(blob, node,
+					"lan-gpy215-id", 0 );
+	else if (CONFIG_IS_ENABLED(XPCS5_USXGMII_RTL8261))
+		priv->phy_addr = fdtdec_get_int(blob, node,
+					"lan-rtl8261", 0 );
+	/* we only register the two mdio iface */
+	for (i = 0; i < 2; i++) {
+		snprintf(mdio_name, sizeof(mdio_name) / sizeof(char),
+				"mdio%d", i);
+		lightning_mountain_mdio_init(dev, mdio_name);
+	}
+
+	ret = lightning_mountain_sw_init(dev);
+	if (ret)
+		return ret;
+	wmb();
+
+	return 0;
+}
+
+static const struct eth_ops lightning_mountain_ops = {
+	.start = lightning_mountain_switch_init,
+	.send = lightning_mountain_switch_send,
+	.recv = lightning_mountain_switch_recv,
+	.stop = lightning_mountain_switch_halt,
+};
+
+static const struct udevice_id lightning_mountain_ids[] = {
+	{ .compatible = "mxl,gswip-3.2" },
+	{}
+};
+
+U_BOOT_DRIVER(lightning_mountain_eth) = {
+	.name	= "lightning_mountain_eth",
+	.id	= UCLASS_ETH,
+	.of_match = lightning_mountain_ids,
+	.ops	= &lightning_mountain_ops,
+	.plat_auto = sizeof(struct eth_pdata),
+	.priv_auto = sizeof(struct lightning_mountain_eth_priv),
+	.probe	= lightning_mountain_eth_probe,
+};
diff --git a/drivers/net/lightning_mountain_sw.h b/drivers/net/lightning_mountain_sw.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lightning_mountain_sw.h
@@ -0,0 +1,1852 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright © 2022 MaxLinear, Inc.
+ *
+ * Lightning Mountain Slim Ethernet Driver
+ *
+ */
+#ifndef __LIGHTNING_MOUNTAIN_SW_H
+#define __LIGHTNING_MOUNTAIN_SW_H
+
+#include <asm/io.h>
+#include <asm/arch/project.h>
+
+#ifdef LGM_NET_VERBOSE
+#define LGM_NET_DBG(fmt,args...)	printf(fmt, ##args)
+#else
+#define LGM_NET_DBG(fmt,args...)
+#endif
+
+#define GPHY241_ID 	0x241
+#define GPHY241_MASK 	0x3FF
+
+#define GPIO_PDI_REGISTERS_GPIO2_ALTSEL1 	0x00D3CE30
+#define GPIO_PDI_REGISTERS_GPIO2_ALTSEL0 	0x00D3CE2C
+#define GPIO_PDI_REGISTERS_GPIO2_DIR 		0x00D3CE28
+#define GPIO_PDI_REGISTERS_GPIO2_OUT		0x00D3CE20
+#define GPIO_PDI_REGISTERS_GPIO_ALTSEL1		0x00D3CE10
+#define GPIO_PDI_REGISTERS_GPIO_ALTSEL0		0x00D3CE0C
+#define GPIO_PDI_REGISTERS_GPIO_DIR		0x00D3CE08
+#define GPIO_PDI_REGISTERS_GPIO_OUT		0x00D3CE00
+
+#define LEGACY_MAC_BASE			GSWIP_O_LEGACY_MAC_MODULE_BASE
+#define GSWIP_SS			GSWIP_O_SUBSYSTEM_MODULE_BASE
+#define XGMAC_CTRL_REG(idx)		((GSWIP_SS) + (0x1298 + ((idx) * 0x100)))
+#define XGMAC_DATA1_REG(idx)		((GSWIP_SS) + (0x1294 + ((idx) * 0x100)))
+#define XGMAC_DATA0_REG(idx)		((GSWIP_SS) + (0x1290 + ((idx) * 0x100)))
+
+/* MAC register offsets */
+#define MAC_TCR                         0x0000
+#define MAC_RCR                         0x0004
+#define MAC_PFR                         0x0008
+#define MAC_WTR                         0x000c
+#define MAC_HTR0                        0x0010
+#define MAC_VLANTR                      0x0050
+#define MAC_VLANHTR                     0x0058
+#define MAC_VLANIR                      0x0060
+#define MAC_IVLANIR                     0x0064
+#define MAC_RETMR                       0x006c
+#define MAC_Q0TFCR                      0x0070
+#define MAC_RFCR                        0x0090
+#define MAC_RQC0R                       0x00a0
+#define MAC_RQC1R                       0x00a4
+#define MAC_RQC2R                       0x00a8
+#define MAC_RQC3R                       0x00ac
+#define MAC_ISR                         0x00b0
+#define MAC_IER_R                       0x00b4
+#define MAC_RTSR_R                      0x00b8
+#define MAC_PMTCSR                      0x00c0
+#define MAC_RWKPFR                      0x00c4
+#define MAC_LPICSR                      0x00d0
+#define MAC_LPITCR                      0x00d4
+#define MAC_VR                          0x0110
+#define MAC_DR                          0x0114
+#define MAC_HWF0R                       0x011c
+#define MAC_HWF1R                       0x0120
+#define MAC_HWF2R                       0x0124
+#define MAC_EXTCFG                      0x0140
+#define MAC_GPIOCR                      0x0278
+#define MAC_GPIOSR                      0x027c
+#define MAC_MACA0HR                     0x0300
+#define MAC_MACA0LR                     0x0304
+#define MAC_MACA1HR                     0x0308
+#define MAC_MACA1LR                     0x030c
+#define MAC_RSSCR                       0x0c80
+#define MAC_RSSAR                       0x0c88
+#define MAC_RSSDR                       0x0c8c
+#define MAC_TSCR                        0x0d00
+#define MAC_SSIR                        0x0d04
+#define MAC_STSR                        0x0d08
+#define MAC_STNR                        0x0d0c
+#define MAC_STSUR                       0x0d10
+#define MAC_STNUR                       0x0d14
+#define MAC_TSAR                        0x0d18
+#define MAC_TSSR                        0x0d20
+#define MAC_TXSNR                       0x0d30
+#define MAC_TXSSR                       0x0d34
+#define MAC_PTOCTL                      0x0dc0
+
+#define MAC_RCR_ACS_INDEX               1
+#define MAC_RCR_ACS_WIDTH               1
+#define MAC_RCR_CST_INDEX               2
+#define MAC_RCR_CST_WIDTH               1
+#define MAC_RCR_DCRCC_INDEX             3
+#define MAC_RCR_DCRCC_WIDTH             1
+#define MAC_RCR_HDSMS_INDEX             12
+#define MAC_RCR_HDSMS_WIDTH             3
+#define MAC_RCR_IPC_INDEX               9
+#define MAC_RCR_IPC_WIDTH               1
+#define MAC_RCR_JE_INDEX                8
+#define MAC_RCR_JE_WIDTH                1
+#define MAC_RCR_LM_INDEX                10
+#define MAC_RCR_LM_WIDTH                1
+#define MAC_RCR_RE_INDEX                0
+#define MAC_RCR_RE_WIDTH                1
+#define MAC_RCR_WD_INDEX                7
+#define MAC_RCR_WD_WIDTH				1
+#define MAC_RCR_GPSLCE_INDEX            6
+#define MAC_RCR_GPSLCE_WIDTH			1
+#define MAC_RCR_GPSL_INDEX              16
+#define MAC_RCR_GPSL_WIDTH				14
+
+#define MAC_TCR_USS_INDEX               31
+#define MAC_TCR_USS_WIDTH               1
+#define MAC_TCR_SS_INDEX                29
+#define MAC_TCR_SS_WIDTH                2
+#define MAC_TCR_TE_INDEX                0
+#define MAC_TCR_TE_WIDTH                1
+#define MAC_TCR_JD_INDEX                16
+#define MAC_TCR_JD_WIDTH				1
+#define MAC_TCR_IPG_INDEX               8
+#define MAC_TCR_IPG_WIDTH				3
+#define MAC_TCR_IFP_INDEX               11
+#define MAC_TCR_IFP_WIDTH				1
+
+/* RX THRESHOLD operations */
+#define MTL_RX_THRESHOLD_32				0x01
+#define MTL_RX_THRESHOLD_64             0x00
+#define MTL_RX_THRESHOLD_96             0x02
+#define MTL_RX_THRESHOLD_128            0x03
+#define MTL_TX_THRESHOLD_32             0x01
+#define MTL_TX_THRESHOLD_64             0x00
+#define MTL_TX_THRESHOLD_96             0x02
+#define MTL_TX_THRESHOLD_128            0x03
+#define MTL_TX_THRESHOLD_192            0x04
+#define MTL_TX_THRESHOLD_256            0x05
+#define MTL_TX_THRESHOLD_384            0x06
+#define MTL_TX_THRESHOLD_512            0x07
+
+#define MTL_ETSALG_WRR                  0x00
+#define MTL_ETSALG_WFQ                  0x01
+#define MTL_ETSALG_DWRR                 0x02
+#define MTL_RAA_SP                      0x00
+#define MTL_RAA_WSP                     0x01
+
+#define MTL_Q_DISABLED                  0x00
+#define MTL_Q_ENABLED                   0x02
+#define XGMAC_MAX_JUMBO_PACKET  9018
+#define XGMAC_MAX_GPSL                  9000 /* Defualt maximum Gaint Packet Size Limit */
+#define XGMAC_MAX_SUPPORTED_MTU 16380
+#define LGM_MAX_MTU					10000
+
+#define MAC_ISR_LSI_INDEX               0
+#define MAC_ISR_LSI_WIDTH               1
+#define MAC_ISR_SMI_INDEX               1
+#define MAC_ISR_SMI_WIDTH               1
+#define MAC_ISR_PMTIS_INDEX             4
+#define MAC_ISR_PMTIS_WIDTH             1
+#define MAC_ISR_LPIIS_INDEX             5
+#define MAC_ISR_LPIIS_WIDTH             1
+#define MAC_ISR_MMCRXIS_INDEX           9
+#define MAC_ISR_MMCRXIS_WIDTH           1
+#define MAC_ISR_MMCTXIS_INDEX           10
+#define MAC_ISR_MMCTXIS_WIDTH           1
+#define MAC_ISR_TSIS_INDEX              12
+#define MAC_ISR_TSIS_WIDTH              1
+#define MAC_ISR_TXESIS_INDEX            13
+#define MAC_ISR_TXESIS_WIDTH            1
+#define MAC_ISR_RXESIS_INDEX            14
+#define MAC_ISR_RXESIS_WIDTH            1
+#define MAC_ISR_GPIIS_INDEX             15
+#define MAC_ISR_GPIIS_WIDTH             1
+#define MAC_ISR_LS_INDEX                24
+#define MAC_ISR_LS_WIDTH                2
+
+#define MAC_IER_TSIE_INDEX              12
+#define MAC_IER_TSIE_WIDTH              1
+#define MAC_IER_TXESIE_INDEX            13
+#define MAC_IER_TXESIE_WIDTH            1
+#define MAC_IER_RXESIE_INDEX            14
+#define MAC_IER_RXESIE_WIDTH            1
+#define MAC_IER_LPIIE_INDEX             5
+#define MAC_IER_LPIIE_WIDTH             1
+#define MAC_IER_PMTIE_INDEX             4
+#define MAC_IER_PMTIE_WIDTH             1
+
+#define MAC_LPICSR_LPITXEN_INDEX        16
+#define MAC_LPICSR_LPITXEN_WIDTH        1
+#define MAC_LPICSR_LPIATE_INDEX         20
+#define MAC_LPICSR_LPIATE_WIDTH         1
+#define MAC_LPICSR_LPITXA_INDEX         19
+#define MAC_LPICSR_LPITXA_WIDTH         1
+#define MAC_LPICSR_PLS_INDEX            17
+#define MAC_LPICSR_PLS_WIDTH            1
+#define MAC_LPITCR_LST_INDEX            16
+#define MAC_LPITCR_LST_WIDTH            10
+#define MAC_LPITCR_TWT_INDEX            0
+#define MAC_LPITCR_TWT_WIDTH            16
+
+#define MAC_MACA1HR_AE_INDEX            31
+#define MAC_MACA1HR_AE_WIDTH            1
+
+#define MAC_PFR_PM_INDEX                4
+#define MAC_PFR_PM_WIDTH                1
+#define MAC_PFR_PR_INDEX                0
+#define MAC_PFR_PR_WIDTH                1
+#define MAC_PFR_VTFE_INDEX              16
+#define MAC_PFR_VTFE_WIDTH              1
+#define MAC_PFR_RA_INDEX                31
+#define MAC_PFR_RA_WIDTH                1
+
+
+/* MTL queue register entry bit positions and sizes */
+#define MTL_Q_RQMPOCR_MISCNTOVF_INDEX	31
+#define MTL_Q_RQMPOCR_MISCNTOVF_WIDTH	 1
+#define MTL_Q_RQMPOCR_MISPKTCNT_INDEX	16
+#define MTL_Q_RQMPOCR_MISPKTCNT_WIDTH	11
+#define MTL_Q_RQMPOCR_OVFCNTOVF_INDEX	15
+#define MTL_Q_RQMPOCR_OVFCNTOVF_WIDTH	 1
+#define MTL_Q_RQMPOCR_OVFPKTCNT_INDEX	 0
+#define MTL_Q_RQMPOCR_OVFPKTCNT_WIDTH	11
+
+#define MTL_Q_TQUR_UFCNTOVF_INDEX		15
+#define MTL_Q_TQUR_UFCNTOVF_WIDTH		1
+#define MTL_Q_TQUR_UFPKTCNT_INDEX		0
+#define MTL_Q_TQUR_UFPKTCNT_WIDTH		11
+
+#define MTL_Q_RQDR_PRXQ_INDEX           16
+#define MTL_Q_RQDR_PRXQ_WIDTH           14
+#define MTL_Q_RQDR_RXQSTS_INDEX         4
+#define MTL_Q_RQDR_RXQSTS_WIDTH         2
+#define MTL_Q_RQFCR_RFA_INDEX           1
+#define MTL_Q_RQFCR_RFA_WIDTH           6
+#define MTL_Q_RQFCR_RFD_INDEX           17
+#define MTL_Q_RQFCR_RFD_WIDTH           6
+#define MTL_Q_RQOMR_EHFC_INDEX          7
+#define MTL_Q_RQOMR_EHFC_WIDTH          1
+#define MTL_Q_RQOMR_RQS_INDEX           16
+#define MTL_Q_RQOMR_RQS_WIDTH           9
+#define MTL_Q_RQOMR_RSF_INDEX           5
+#define MTL_Q_RQOMR_RSF_WIDTH           1
+#define MTL_Q_RQOMR_RTC_INDEX           0
+#define MTL_Q_RQOMR_RTC_WIDTH           2
+#define MTL_Q_RQOMR_FUP_INDEX           3
+#define MTL_Q_RQOMR_FUP_WIDTH           1
+#define MTL_Q_RQOMR_FEF_INDEX           4
+#define MTL_Q_RQOMR_FEF_WIDTH           1
+
+#define MTL_Q_RQDG_PRXQ_INDEX           16
+#define MTL_Q_RQDG_PRXQ_WIDTH           14
+#define MTL_Q_RQDG_RXQSTS_INDEX         4
+#define MTL_Q_RQDG_RXQSTS_WIDTH         2
+#define MTL_Q_RQDG_RRCSTS_INDEX         1
+#define MTL_Q_RQDG_RRCSTS_WIDTH         2
+
+#define MTL_Q_TQOMR_FTQ_INDEX           0
+#define MTL_Q_TQOMR_FTQ_WIDTH           1
+#define MTL_Q_TQOMR_Q2TCMAP_INDEX       8
+#define MTL_Q_TQOMR_Q2TCMAP_WIDTH       3
+#define MTL_Q_TQOMR_TQS_INDEX           16
+#define MTL_Q_TQOMR_TQS_WIDTH           10
+#define MTL_Q_TQOMR_TSF_INDEX           1
+#define MTL_Q_TQOMR_TSF_WIDTH           1
+#define MTL_Q_TQOMR_TTC_INDEX           4
+#define MTL_Q_TQOMR_TTC_WIDTH           3
+#define MTL_Q_TQOMR_TXQEN_INDEX         2
+#define MTL_Q_TQOMR_TXQEN_WIDTH         2
+
+#define MTL_Q_TQDG_TXQSTS_INDEX         4
+#define MTL_Q_TQDG_TXQSTS_WIDTH         1
+#define MTL_Q_TQDG_TRCSTS_INDEX         1
+#define MTL_Q_TQDG_TRCSTS_WIDTH         2
+
+#define MTL_Q_IER_TXUIE_INDEX			0
+#define MTL_Q_IER_TXUIE_WIDTH			1
+#define MTL_Q_IER_ABPSIE_INDEX			1
+#define MTL_Q_IER_ABPSIE_WIDTH			1
+#define MTL_Q_IER_RXOIE_INDEX			16
+#define MTL_Q_IER_RXOIE_WIDTH			1
+
+#define MTL_Q_ISR_TXUNFIS_INDEX			0
+#define MTL_Q_ISR_TXUNFIS_WIDTH			1
+#define MTL_Q_ISR_ABPSIS_INDEX			1
+#define MTL_Q_ISR_ABPSIS_WIDTH			1
+#define MTL_Q_ISR_RXOVFIS_INDEX			16
+#define MTL_Q_ISR_RXOVFIS_WIDTH			1
+
+#define MAC_IF_CFG_ADAP_RES_POS         15
+#define MAC_IF_CFG_ADAP_RES_WIDTH       1
+#define MAC_IF_CFG_LMAC_RES_POS         14
+#define MAC_IF_CFG_LMAC_RES_WIDTH       1
+#define MAC_IF_CFG_XGMAC_RES_POS        13
+#define MAC_IF_CFG_XGMAC_RES_WIDTH      1
+#define MAC_IF_CFG_MAC_EN_POS           12
+#define MAC_IF_CFG_MAC_EN_WIDTH         1
+#define MAC_IF_CFG_PTP_DIS_POS          11
+#define MAC_IF_CFG_PTP_DIS_WIDTH        1
+#define MAC_IF_CFG_CFG1G_POS            1
+#define MAC_IF_CFG_CFG1G_WIDTH          1
+#define MAC_IF_CFG_CFGFE_POS            2
+#define MAC_IF_CFG_CFGFE_WIDTH          1
+#define MAC_IF_CFG_CFG2G5_POS           0
+#define MAC_IF_CFG_CFG2G5_WIDTH         1
+
+/* MMC register offsets */
+#define MMC_CR                          0x0800
+#define MMC_RISR                        0x0804
+#define MMC_TISR                        0x0808
+#define MMC_RIER                        0x080c
+#define MMC_TIER                        0x0810
+
+#define MMC_TXOCTETCOUNT_GB_LO          0x0814
+#define MMC_TXOCTETCOUNT_GB_HI          0x0818
+#define MMC_TXFRAMECOUNT_GB_LO          0x081c
+#define MMC_TXFRAMECOUNT_GB_HI          0x0820
+#define MMC_TXBROADCASTFRAMES_G_LO      0x0824
+#define MMC_TXBROADCASTFRAMES_G_HI      0x0828
+#define MMC_TXMULTICASTFRAMES_G_LO      0x082c
+#define MMC_TXMULTICASTFRAMES_G_HI      0x0830
+#define MMC_TX64OCTETS_GB_LO            0x0834
+#define MMC_TX64OCTETS_GB_HI            0x0838
+#define MMC_TX65TO127OCTETS_GB_LO       0x083c
+#define MMC_TX65TO127OCTETS_GB_HI       0x0840
+#define MMC_TX128TO255OCTETS_GB_LO      0x0844
+#define MMC_TX128TO255OCTETS_GB_HI      0x0848
+#define MMC_TX256TO511OCTETS_GB_LO      0x084c
+#define MMC_TX256TO511OCTETS_GB_HI      0x0850
+#define MMC_TX512TO1023OCTETS_GB_LO     0x0854
+#define MMC_TX512TO1023OCTETS_GB_HI     0x0858
+#define MMC_TX1024TOMAXOCTETS_GB_LO     0x085c
+#define MMC_TX1024TOMAXOCTETS_GB_HI     0x0860
+#define MMC_TXUNICASTFRAMES_GB_LO       0x0864
+#define MMC_TXUNICASTFRAMES_GB_HI       0x0868
+#define MMC_TXMULTICASTFRAMES_GB_LO     0x086c
+#define MMC_TXMULTICASTFRAMES_GB_HI     0x0870
+#define MMC_TXBROADCASTFRAMES_GB_LO     0x0874
+#define MMC_TXBROADCASTFRAMES_GB_HI     0x0878
+#define MMC_TXUNDERFLOWERROR_LO         0x087c
+#define MMC_TXUNDERFLOWERROR_HI         0x0880
+#define MMC_TXOCTETCOUNT_G_LO           0x0884
+#define MMC_TXOCTETCOUNT_G_HI           0x0888
+#define MMC_TXFRAMECOUNT_G_LO           0x088c
+#define MMC_TXFRAMECOUNT_G_HI           0x0890
+#define MMC_TXPAUSEFRAMES_LO            0x0894
+#define MMC_TXPAUSEFRAMES_HI            0x0898
+#define MMC_TXVLANFRAMES_G_LO           0x089c
+#define MMC_TXVLANFRAMES_G_HI           0x08a0
+
+#define MMC_RXFRAMECOUNT_GB_LO          0x0900
+#define MMC_RXFRAMECOUNT_GB_HI          0x0904
+#define MMC_RXOCTETCOUNT_GB_LO          0x0908
+#define MMC_RXOCTETCOUNT_GB_HI          0x090c
+#define MMC_RXOCTETCOUNT_G_LO           0x0910
+#define MMC_RXOCTETCOUNT_G_HI           0x0914
+#define MMC_RXBROADCASTFRAMES_G_LO      0x0918
+#define MMC_RXBROADCASTFRAMES_G_HI      0x091c
+#define MMC_RXMULTICASTFRAMES_G_LO      0x0920
+#define MMC_RXMULTICASTFRAMES_G_HI      0x0924
+#define MMC_RXCRCERROR_LO               0x0928
+#define MMC_RXCRCERROR_HI               0x092c
+#define MMC_RXRUNTERROR                 0x0930
+#define MMC_RXJABBERERROR               0x0934
+#define MMC_RXUNDERSIZE_G               0x0938
+#define MMC_RXOVERSIZE_G                0x093c
+#define MMC_RX64OCTETS_GB_LO            0x0940
+#define MMC_RX64OCTETS_GB_HI            0x0944
+#define MMC_RX65TO127OCTETS_GB_LO       0x0948
+#define MMC_RX65TO127OCTETS_GB_HI       0x094c
+#define MMC_RX128TO255OCTETS_GB_LO      0x0950
+#define MMC_RX128TO255OCTETS_GB_HI      0x0954
+#define MMC_RX256TO511OCTETS_GB_LO      0x0958
+#define MMC_RX256TO511OCTETS_GB_HI      0x095c
+#define MMC_RX512TO1023OCTETS_GB_LO     0x0960
+#define MMC_RX512TO1023OCTETS_GB_HI     0x0964
+#define MMC_RX1024TOMAXOCTETS_GB_LO     0x0968
+#define MMC_RX1024TOMAXOCTETS_GB_HI     0x096c
+#define MMC_RXUNICASTFRAMES_G_LO        0x0970
+#define MMC_RXUNICASTFRAMES_G_HI        0x0974
+#define MMC_RXLENGTHERROR_LO            0x0978
+#define MMC_RXLENGTHERROR_HI            0x097c
+#define MMC_RXOUTOFRANGETYPE_LO         0x0980
+#define MMC_RXOUTOFRANGETYPE_HI         0x0984
+#define MMC_RXPAUSEFRAMES_LO            0x0988
+#define MMC_RXPAUSEFRAMES_HI            0x098c
+#define MMC_RXFIFOOVERFLOW_LO           0x0990
+#define MMC_RXFIFOOVERFLOW_HI           0x0994
+#define MMC_RXVLANFRAMES_GB_LO          0x0998
+#define MMC_RXVLANFRAMES_GB_HI          0x099c
+#define MMC_RXWATCHDOGERROR             0x09a0
+
+/* MMC register entry bit positions and sizes */
+#define MMC_CR_CR_INDEX                         0
+#define MMC_CR_CR_WIDTH                         1
+#define MMC_CR_CSR_INDEX                        1
+#define MMC_CR_CSR_WIDTH                        1
+#define MMC_CR_ROR_INDEX                        2
+#define MMC_CR_ROR_WIDTH                        1
+#define MMC_CR_MCF_INDEX                        3
+#define MMC_CR_MCF_WIDTH                        1
+#define MMC_CR_MCT_INDEX                        4
+#define MMC_CR_MCT_WIDTH                        2
+
+#define MMC_RIER_ALL_INTERRUPTS_INDEX           0
+#define MMC_RIER_ALL_INTERRUPTS_WIDTH           23
+#define MMC_RISR_RXFRAMECOUNT_GB_INDEX          0
+#define MMC_RISR_RXFRAMECOUNT_GB_WIDTH          1
+#define MMC_RISR_RXOCTETCOUNT_GB_INDEX          1
+#define MMC_RISR_RXOCTETCOUNT_GB_WIDTH          1
+#define MMC_RISR_RXOCTETCOUNT_G_INDEX           2
+#define MMC_RISR_RXOCTETCOUNT_G_WIDTH           1
+#define MMC_RISR_RXBROADCASTFRAMES_G_INDEX      3
+#define MMC_RISR_RXBROADCASTFRAMES_G_WIDTH      1
+#define MMC_RISR_RXMULTICASTFRAMES_G_INDEX      4
+#define MMC_RISR_RXMULTICASTFRAMES_G_WIDTH      1
+#define MMC_RISR_RXCRCERROR_INDEX               5
+#define MMC_RISR_RXCRCERROR_WIDTH               1
+#define MMC_RISR_RXRUNTERROR_INDEX              6
+#define MMC_RISR_RXRUNTERROR_WIDTH              1
+#define MMC_RISR_RXJABBERERROR_INDEX            7
+#define MMC_RISR_RXJABBERERROR_WIDTH            1
+#define MMC_RISR_RXUNDERSIZE_G_INDEX            8
+#define MMC_RISR_RXUNDERSIZE_G_WIDTH            1
+#define MMC_RISR_RXOVERSIZE_G_INDEX             9
+#define MMC_RISR_RXOVERSIZE_G_WIDTH             1
+#define MMC_RISR_RX64OCTETS_GB_INDEX            10
+#define MMC_RISR_RX64OCTETS_GB_WIDTH            1
+#define MMC_RISR_RX65TO127OCTETS_GB_INDEX       11
+#define MMC_RISR_RX65TO127OCTETS_GB_WIDTH       1
+#define MMC_RISR_RX128TO255OCTETS_GB_INDEX      12
+#define MMC_RISR_RX128TO255OCTETS_GB_WIDTH      1
+#define MMC_RISR_RX256TO511OCTETS_GB_INDEX      13
+#define MMC_RISR_RX256TO511OCTETS_GB_WIDTH      1
+#define MMC_RISR_RX512TO1023OCTETS_GB_INDEX     14
+#define MMC_RISR_RX512TO1023OCTETS_GB_WIDTH     1
+#define MMC_RISR_RX1024TOMAXOCTETS_GB_INDEX     15
+#define MMC_RISR_RX1024TOMAXOCTETS_GB_WIDTH     1
+#define MMC_RISR_RXUNICASTFRAMES_G_INDEX        16
+#define MMC_RISR_RXUNICASTFRAMES_G_WIDTH        1
+#define MMC_RISR_RXLENGTHERROR_INDEX            17
+#define MMC_RISR_RXLENGTHERROR_WIDTH            1
+#define MMC_RISR_RXOUTOFRANGETYPE_INDEX         18
+#define MMC_RISR_RXOUTOFRANGETYPE_WIDTH         1
+#define MMC_RISR_RXPAUSEFRAMES_INDEX            19
+#define MMC_RISR_RXPAUSEFRAMES_WIDTH            1
+#define MMC_RISR_RXFIFOOVERFLOW_INDEX           20
+#define MMC_RISR_RXFIFOOVERFLOW_WIDTH           1
+#define MMC_RISR_RXVLANFRAMES_GB_INDEX          21
+#define MMC_RISR_RXVLANFRAMES_GB_WIDTH          1
+#define MMC_RISR_RXWATCHDOGERROR_INDEX          22
+#define MMC_RISR_RXWATCHDOGERROR_WIDTH          1
+
+#define MMC_TIER_ALL_INTERRUPTS_INDEX           0
+#define MMC_TIER_ALL_INTERRUPTS_WIDTH           18
+
+#define MMC_TISR_TXOCTETCOUNT_GB_INDEX          0
+#define MMC_TISR_TXOCTETCOUNT_GB_WIDTH          1
+#define MMC_TISR_TXFRAMECOUNT_GB_INDEX          1
+#define MMC_TISR_TXFRAMECOUNT_GB_WIDTH          1
+#define MMC_TISR_TXBROADCASTFRAMES_G_INDEX      2
+#define MMC_TISR_TXBROADCASTFRAMES_G_WIDTH      1
+#define MMC_TISR_TXMULTICASTFRAMES_G_INDEX      3
+#define MMC_TISR_TXMULTICASTFRAMES_G_WIDTH      1
+#define MMC_TISR_TX64OCTETS_GB_INDEX            4
+#define MMC_TISR_TX64OCTETS_GB_WIDTH            1
+#define MMC_TISR_TX65TO127OCTETS_GB_INDEX       5
+#define MMC_TISR_TX65TO127OCTETS_GB_WIDTH       1
+#define MMC_TISR_TX128TO255OCTETS_GB_INDEX      6
+#define MMC_TISR_TX128TO255OCTETS_GB_WIDTH      1
+#define MMC_TISR_TX256TO511OCTETS_GB_INDEX      7
+#define MMC_TISR_TX256TO511OCTETS_GB_WIDTH      1
+#define MMC_TISR_TX512TO1023OCTETS_GB_INDEX     8
+#define MMC_TISR_TX512TO1023OCTETS_GB_WIDTH     1
+#define MMC_TISR_TX1024TOMAXOCTETS_GB_INDEX     9
+#define MMC_TISR_TX1024TOMAXOCTETS_GB_WIDTH     1
+#define MMC_TISR_TXUNICASTFRAMES_GB_INDEX       10
+#define MMC_TISR_TXUNICASTFRAMES_GB_WIDTH       1
+#define MMC_TISR_TXMULTICASTFRAMES_GB_INDEX     11
+#define MMC_TISR_TXMULTICASTFRAMES_GB_WIDTH     1
+#define MMC_TISR_TXBROADCASTFRAMES_GB_INDEX     12
+#define MMC_TISR_TXBROADCASTFRAMES_GB_WIDTH     1
+#define MMC_TISR_TXUNDERFLOWERROR_INDEX         13
+#define MMC_TISR_TXUNDERFLOWERROR_WIDTH         1
+#define MMC_TISR_TXOCTETCOUNT_G_INDEX           14
+#define MMC_TISR_TXOCTETCOUNT_G_WIDTH           1
+#define MMC_TISR_TXFRAMECOUNT_G_INDEX           15
+#define MMC_TISR_TXFRAMECOUNT_G_WIDTH           1
+#define MMC_TISR_TXPAUSEFRAMES_INDEX            16
+#define MMC_TISR_TXPAUSEFRAMES_WIDTH            1
+#define MMC_TISR_TXVLANFRAMES_G_INDEX           17
+#define MMC_TISR_TXVLANFRAMES_G_WIDTH           1
+
+#define MAC_IF_CFG_ADAP_RES_INDEX	15
+#define MAC_IF_CFG_ADAP_RES_WIDTH	1
+#define MAC_IF_CFG_LMAC_RES_INDEX	14
+#define MAC_IF_CFG_LMAC_RES_WIDTH	1
+#define MAC_IF_CFG_XGMAC_RES_INDEX	13
+#define MAC_IF_CFG_XGMAC_RES_WIDTH	1
+#define MAC_IF_CFG_MAC_EN_INDEX	    12
+#define MAC_IF_CFG_MAC_EN_WIDTH	    1
+#define MAC_IF_CFG_CFG1G_INDEX		1
+#define MAC_IF_CFG_CFG1G_WIDTH		1
+#define MAC_IF_CFG_CFGFE_INDEX		2
+#define MAC_IF_CFG_CFGFE_WIDTH		1
+#define MAC_IF_CFG_CFG2G5_INDEX		0
+#define MAC_IF_CFG_CFG2G5_WIDTH		1
+
+#define MAC_CTRL0_GMII_INDEX      0
+#define MAC_CTRL0_GMII_WIDTH      2
+#define MAC_CTRL0_FDUP_INDEX      2
+#define MAC_CTRL0_FDUP_WIDTH      2
+#define MAC_CTRL0_FCON_INDEX      4
+#define MAC_CTRL0_FCON_WIDTH      2
+#define MAC_CTRL0_FCS_INDEX       7
+#define MAC_CTRL0_FCS_WIDTH       1
+#define MAC_CTRL0_PADEN_INDEX     8
+#define MAC_CTRL0_PADEN_WIDTH     1
+#define MAC_CTRL0_VPADEN_INDEX    9
+#define MAC_CTRL0_VPADEN_WIDTH    1
+#define MAC_CTRL0_VPAD2EN_INDEX   10
+#define MAC_CTRL0_VPAD2EN_WIDTH   1
+#define MAC_CTRL0_APADEN_INDEX    11
+#define MAC_CTRL0_APADEN_WIDTH    1
+#define MAC_PSTAT(idx)			(0x400 + (idx * (0x30)))
+#define MAC_PISR(idx)			(0x404 + (idx * (0x30)))
+#define MAC_PIER(idx)			(0x408 + (idx * (0x30)))
+#define MAC_CTRL0(idx)			(0x40C + (idx * (0x30)))
+#define MAC_CTRL1(idx)			(0x410 + (idx * (0x30)))
+#define MAC_CTRL2(idx)			(0x414 + (idx * (0x30)))
+#define MAC_CTRL3(idx)			(0x418 + (idx * (0x30)))
+#define MAC_CTRL4(idx)			(0x41C + (idx * (0x30)))
+#define MAC_CTRL5(idx)			(0x420 + (idx * (0x30)))
+#define MAC_TESTEN(idx)			(0x42C + (idx * (0x30)))
+#define MAC_LPITIMER0(idx)		(0x424 + (idx * (0x30)))
+#define MAC_LPITIMER1(idx)		(0x428 + (idx * (0x30)))
+#define MAC_IF_CFG(idx)			(0x1200 + (idx * (0x100)))
+#define MAC_OP_CFG(idx)			(0x1204 + (idx * (0x100)))
+#define MAC_MTU_CFG(idx)		(0x1208 + (idx * (0x100)))
+#define MAC_GINT_CFG(idx)		(0x120C + (idx * (0x100)))
+
+#define PHY_MODE_FCONRX_INDEX		5
+#define PHY_MODE_FCONRX_WIDTH		2
+#define PHY_MODE_FCONTX_INDEX		7
+#define PHY_MODE_FCONTX_WIDTH		2
+#define PHY_MODE_FDUP_INDEX			9
+#define PHY_MODE_FDUP_WIDTH			2
+#define PHY_MODE_SPEEDLSB_INDEX		11
+#define PHY_MODE_SPEEDLSB_WIDTH		2
+#define PHY_MODE_LINKST_INDEX		13
+#define PHY_MODE_LINKST_WIDTH		2
+#define PHY_MODE_SPEEDMSB_INDEX		15
+#define PHY_MODE_SPEEDMSB_WIDTH		1
+
+#define PHY_STAT_TXPAUEN_INDEX		0
+#define PHY_STAT_TXPAUEN_WIDTH		1
+#define PHY_STAT_RXPAUEN_INDEX		1
+#define PHY_STAT_RXPAUEN_WIDTH		1
+#define PHY_STAT_FDUP_INDEX			2
+#define PHY_STAT_FDUP_WIDTH			1
+#define PHY_STAT_SPEEDLSB_INDEX		3
+#define PHY_STAT_SPEEDLSB_WIDTH		2
+#define PHY_STAT_LSTAT_INDEX		5
+#define PHY_STAT_LSTAT_WIDTH		1
+#define PHY_STAT_EEECAP_INDEX		7
+#define PHY_STAT_EEECAP_WIDTH		1
+#define PHY_STAT_CLKSTOPCAP_INDEX	8
+#define PHY_STAT_CLKSTOPCAP_WIDTH	1
+#define PHY_STAT_SPEEDMSB_INDEX		11
+#define PHY_STAT_SPEEDMSB_WIDTH		1
+
+/* XGMAC MDIO */ 
+#define MDIO_C_45	0
+#define MDIO_C_22	1
+
+#define MDIO_SCAR		0x200
+#define MDIO_SCCDR		0x204
+#define MDIO_CWAR		0x208
+#define MDIO_CWDR		0x20C
+#define MDIO_CSPE		0x210
+#define MDIO_ISR		0x214
+#define MDIO_IER		0x218
+#define MDIO_PSR		0x21C
+#define MDIO_C22P		0x220
+#define MDIO_DIUR(port)	(0x230 + (port * 0x10))
+#define MDIO_LSR(port)	(0x234 + (port * 0x10))
+#define MDIO_ASR(port)	(0x238 + (port * 0x10))
+
+#define MDIO_SCAR_DA_INDEX	21
+#define MDIO_SCAR_DA_WIDTH	 5
+#define MDIO_SCAR_PA_INDEX	16
+#define MDIO_SCAR_PA_WIDTH	 5
+#define MDIO_SCAR_RA_INDEX	 0
+#define MDIO_SCAR_RA_WIDTH	16	/* Clause 22 (only lower 5 bits are used) */
+
+#define MDIO_SCCDR_BUSY_INDEX	22
+#define MDIO_SCCDR_BUSY_WIDTH	1
+#define MDIO_SCCDR_CR_INDEX		19
+#define MDIO_SCCDR_CR_WIDTH		3
+#define MDIO_SCCDR_SADDR_INDEX	18
+#define MDIO_SCCDR_SADDR_WIDTH	1
+#define MDIO_SCCDR_CMD_INDEX	16
+#define MDIO_SCCDR_CMD_WIDTH	2
+#define MDIO_SCCDR_SDATA_INDEX	0
+#define MDIO_SCCDR_SDATA_WIDTH	16
+
+#define MDIO_CWAR_CWB_INDEX			22
+#define MDIO_CWAR_CWB_WIDTH			1
+#define MDIO_CWAR_CPRT_INDEX		21
+#define MDIO_CWAR_CPRT_WIDTH		1
+#define MDIO_CWAR_CADDR_INDEX		16
+#define MDIO_CWAR_CADDR_WIDTH		5
+#define MDIO_CWAR_CREGADDR_INDEX	0
+#define MDIO_CWAR_CREGADDR_WIDTH	16
+
+#define MDIO_CWDR_CDATA_INDEX		0
+#define MDIO_CWDR_CDATA_WIDTH		16
+
+#define MDIO_CSPE_PORT3_INDEX		3
+#define MDIO_CSPE_PORT3_WIDTH		1
+#define MDIO_CSPE_PORT2_INDEX		2
+#define MDIO_CSPE_PORT2_WIDTH		1
+#define MDIO_CSPE_PORT1_INDEX		1
+#define MDIO_CSPE_PORT1_WIDTH		1
+#define MDIO_CSPE_PORT0_INDEX		0
+#define MDIO_CSPE_PORT0_WIDTH		1
+
+#define MDIO_ISR_CWCOMPINT_INDEX	13
+#define MDIO_ISR_CWCOMPINT_WIDTH	1
+#define MDIO_ISR_SNGLCOMPINT_INDEX	12
+#define MDIO_ISR_SNGLCOMPINT_WIDTH	1
+#define MDIO_ISR_PRT3ALINT_INDEX	11
+#define MDIO_ISR_PRT3ALINT_WIDTH	1
+#define MDIO_ISR_PRT2ALINT_INDEX	10
+#define MDIO_ISR_PRT2ALINT_WIDTH	1
+#define MDIO_ISR_PRT1ALINT_INDEX	9
+#define MDIO_ISR_PRT1ALINT_WIDTH	1
+#define MDIO_ISR_PRT0ALINT_INDEX	8
+#define MDIO_ISR_PRT0ALINT_WIDTH	1
+#define MDIO_ISR_PRT3LSINT_INDEX	7
+#define MDIO_ISR_PRT3LSINT_WIDTH	1
+#define MDIO_ISR_PRT2LSINT_INDEX	6
+#define MDIO_ISR_PRT2LSINT_WIDTH	1
+#define MDIO_ISR_PRT1LSINT_INDEX	5
+#define MDIO_ISR_PRT1LSINT_WIDTH	1
+#define MDIO_ISR_PRT0LSINT_INDEX	4
+#define MDIO_ISR_PRT0LSINT_WIDTH	1
+#define MDIO_ISR_PRT3CONINT_INDEX	3
+#define MDIO_ISR_PRT3CONINT_WIDTH	1
+#define MDIO_ISR_PRT2CONINT_INDEX	2
+#define MDIO_ISR_PRT2CONINT_WIDTH	1
+#define MDIO_ISR_PRT1CONINT_INDEX	1
+#define MDIO_ISR_PRT1CONINT_WIDTH	1
+#define MDIO_ISR_PRT0CONINT_INDEX	0
+#define MDIO_ISR_PRT0CONINT_WIDTH	1
+
+#define MDIO_IER_CWCOMPIE_INDEX		13
+#define MDIO_IER_CWCOMPIE_WIDTH		1
+#define MDIO_IER_SNGLCOMPIE_INDEX	12
+#define MDIO_IER_SNGLCOMPIE_WIDTH	1
+#define MDIO_IER_PRT3ALIE_INDEX		11
+#define MDIO_IER_PRT3ALIE_WIDTH		1
+#define MDIO_IER_PRT2ALIE_INDEX		10
+#define MDIO_IER_PRT2ALIE_WIDTH		1
+#define MDIO_IER_PRT1ALIE_INDEX		9
+#define MDIO_IER_PRT1ALIE_WIDTH		1
+#define MDIO_IER_PRT0ALIE_INDEX		8
+#define MDIO_IER_PRT0ALIE_WIDTH		1
+#define MDIO_IER_PRT3LSIE_INDEX		7
+#define MDIO_IER_PRT3LSIE_WIDTH		1
+#define MDIO_IER_PRT2LSIE_INDEX		6
+#define MDIO_IER_PRT2LSIE_WIDTH		1
+#define MDIO_IER_PRT1LSIE_INDEX		5
+#define MDIO_IER_PRT1LSIE_WIDTH		1
+#define MDIO_IER_PRT0LSIE_INDEX		4
+#define MDIO_IER_PRT0LSIE_WIDTH		1
+#define MDIO_IER_PRT3CONIE_INDEX	3
+#define MDIO_IER_PRT3CONIE_WIDTH	1
+#define MDIO_IER_PRT2CONIE_INDEX	2
+#define MDIO_IER_PRT2CONIE_WIDTH	1
+#define MDIO_IER_PRT1CONIE_INDEX	1
+#define MDIO_IER_PRT1CONIE_WIDTH	1
+#define MDIO_IER_PRT0CONIE_INDEX	0
+#define MDIO_IER_PRT0CONIE_WIDTH	1
+
+#define MDIO_PSR_PORT3CON_INDEX		3
+#define MDIO_PSR_PORT3CON_WIDTH		1
+#define MDIO_PSR_PORT2CON_INDEX		2
+#define MDIO_PSR_PORT2CON_WIDTH		1
+#define MDIO_PSR_PORT1CON_INDEX		1
+#define MDIO_PSR_PORT1CON_WIDTH		1
+#define MDIO_PSR_PORT0CON_INDEX		0
+#define MDIO_PSR_PORT0CON_WIDTH		1
+
+#define MDIO_CL22P_PORT3_INDEX		3
+#define MDIO_CL22P_PORT3_WIDTH		1
+#define MDIO_CL22P_PORT2_INDEX		2
+#define MDIO_CL22P_PORT2_WIDTH		1
+#define MDIO_CL22P_PORT1_INDEX		1
+#define MDIO_CL22P_PORT1_WIDTH		1
+#define MDIO_CL22P_PORT0_INDEX		0
+#define MDIO_CL22P_PORT0_WIDTH		1
+
+#define MDIO_DIUR_PVSD2_INDEX		31
+#define MDIO_DIUR_PVSD2_WIDTH		1
+#define MDIO_DIUR_PVSD1_INDEX		30
+#define MDIO_DIUR_PVSD1_WIDTH		1
+#define MDIO_DIUR_PTC_INDEX			6
+#define MDIO_DIUR_PTC_WIDTH			1
+#define MDIO_DIUR_PDTEXS_INDEX		5
+#define MDIO_DIUR_PDTEXS_WIDTH		1
+#define MDIO_DIUR_PPHYXS_INDEX		4
+#define MDIO_DIUR_PPHYXS_WIDTH		1
+#define MDIO_DIUR_PPCS_INDEX		3
+#define MDIO_DIUR_PPCS_WIDTH		1
+#define MDIO_DIUR_PWIS_INDEX		2
+#define MDIO_DIUR_PWIS_WIDTH		1
+#define MDIO_DIUR_PPMDPMA_INDEX		1
+#define MDIO_DIUR_PPMDPMA_WIDTH		1
+
+#define MDIO_LSR_PVSD2_INDEX		31
+#define MDIO_LSR_PVSD2_WIDTH		1
+#define MDIO_LSR_PVSD1_INDEX		30
+#define MDIO_LSR_PVSD1_WIDTH		1
+#define MDIO_LSR_PTC_INDEX			6
+#define MDIO_LSR_PTC_WIDTH			1
+#define MDIO_LSR_PDTEXS_INDEX		5
+#define MDIO_LSR_PDTEXS_WIDTH		1
+#define MDIO_LSR_PPHYXS_INDEX		4
+#define MDIO_LSR_PPHYXS_WIDTH		1
+#define MDIO_LSR_PPCS_INDEX			3
+#define MDIO_LSR_PPCS_WIDTH			1
+#define MDIO_LSR_PWIS_INDEX			2
+#define MDIO_LSR_PWIS_WIDTH			1
+#define MDIO_LSR_PPMDPMA_INDEX		1
+#define MDIO_LSR_PPMDPMA_WIDTH		1
+
+#define MDIO_ASR_PVSD2_INDEX		31
+#define MDIO_ASR_PVSD2_WIDTH		1
+#define MDIO_ASR_PVSD1_INDEX		30
+#define MDIO_ASR_PVSD1_WIDTH		1
+#define MDIO_ASR_PTC_INDEX			6
+#define MDIO_ASR_PTC_WIDTH			1
+#define MDIO_ASR_PDTEXS_INDEX		5
+#define MDIO_ASR_PDTEXS_WIDTH		1
+#define MDIO_ASR_PPHYXS_INDEX		4
+#define MDIO_ASR_PPHYXS_WIDTH		1
+#define MDIO_ASR_PPCS_INDEX			3
+#define MDIO_ASR_PPCS_WIDTH			1
+#define MDIO_ASR_PWIS_INDEX			2
+#define MDIO_ASR_PWIS_WIDTH			1
+#define MDIO_ASR_PPMDPMA_INDEX		1
+#define MDIO_ASR_PPMDPMA_WIDTH		1
+
+/** \brief Slave MDIO's Target Base Address Register's Address */
+#define SMDIO_BADR              0x1F
+/** \brief Slave MDIO's Target Offset Address */
+#define SMDIO_TOFF              0x00
+/* GPHY_API MBOX API's */
+#define VSPEC1_MBOX_ADDRLO                      0xC
+#define VSPEC1_MBOX_CMD                         0xE
+#define VSPEC1_MBOX_DATA                        0xA
+#define VSPEC1_MBOX_CMD_READY_MASK      0x8000
+//! Constant READ - Cmd to read a data located at AHB address
+#define CONST_VSPEC1_MBOX_CMD_CMD_READ 0x0
+//! Constant WRITE - Cmd to write a data located at AHB address
+#define CONST_VSPEC1_MBOX_CMD_CMD_WRITE 0x1
+
+//! Field ADDRHI - AHB HighAddress or LLAPI ID.
+#define VSPEC1_MBOX_CMD_ADDRHI_POS 0
+//! Field ADDRHI - AHB HighAddress or LLAPI ID.
+#define VSPEC1_MBOX_CMD_ADDRHI_MASK 0xFFu
+
+//! Field CMD - MBOX Command type
+#define VSPEC1_MBOX_CMD_CMD_POS 8
+//! Field CMD - MBOX Command type
+#define VSPEC1_MBOX_CMD_CMD_MASK 0xf00u
+
+#define MAC_EXTCFG_SBDIOEN_POS			16
+#define MAC_EXTCFG_SBDIOEN_INDEX		8
+#define MAC_EXTCFG_SBDIOEN_WIDTH		1
+
+/* TODO: clean-up */
+#define FIELD_GET(val, name) (((val) & (name ## _MASK)) >> (name ## _POS))
+#define FIELD_SET(val, name) (((val) << (name ## _POS)) & (name ## _MASK))
+#define FIELD_REPLACE(src, val, name) (src = (((src) & (~(name ## _MASK))) | (FIELD_SET(val, name))))
+#define MAC_GET_N_BITS(reg, pos, n) \
+	(((reg) >> (pos)) & ((0x1 << (n)) - 1))
+
+#define MAC_SET_N_BITS(reg, pos, n, val)                            \
+	do {                                                    \
+		(reg) &= ~(((0x1 << (n)) - 1) << (pos));               \
+		(reg) |= (((val) & ((0x1 << (n)) - 1)) << (pos));     \
+	} while (0)
+
+#define MAC_GET_VAL(var, reg, field)				\
+	MAC_GET_N_BITS((var),					\
+		   reg##_##field##_POS, 			\
+		   reg##_##field##_WIDTH)
+
+#define MAC_SET_VAL(var, reg, field, val)			\
+	MAC_SET_N_BITS((var),					\
+		   reg##_##field##_POS, 			\
+		   reg##_##field##_WIDTH, (val))
+
+#define GET_BITS(var, _index, _width)                                  \
+	(((var) >> (_index)) & ((0x1 << (_width)) - 1))
+
+#define SET_BITS_VAL(var, _index, _width, _val)                            \
+	do {                                                                    \
+		(var) &= ~(((0x1 << (_width)) - 1) << (_index));               \
+		(var) |= (((_val) & ((0x1 << (_width)) - 1)) << (_index));     \
+	} while (0)
+
+#define XGMAC_GET_BITS(var, prefix, field)                           \
+	GET_BITS((var),                                                \
+		 prefix##_##field##_INDEX,                            \
+		 prefix##_##field##_WIDTH)
+
+#define XGMAC_SET_BITS(var, prefix, field, _val)                     \
+	SET_BITS_VAL((var),                                                \
+		 prefix##_##field##_INDEX,                            \
+		 prefix##_##field##_WIDTH, (_val))
+
+#define XGMAC_RGRD_BITS(pdata, reg, field)                         \
+	GET_BITS(XGMAC_RGRD(pdata, reg),                          \
+		 reg##_##field##_INDEX,                               \
+		 reg##_##field##_WIDTH)
+
+#define XGMAC_RGWR_BITS(pdata, reg, field, _val)                  \
+	do {                                                                    \
+		u32 reg_val = XGMAC_RGRD(pdata, reg);                \
+		SET_BITS_VAL(reg_val,                                               \
+			 reg##_##field##_INDEX,                               \
+			 reg##_##field##_WIDTH, (_val));                      \
+		XGMAC_RGWR(pdata, reg, reg_val);                         \
+	} while (0)
+
+#define MASK(reg, field) 			(1 << reg##_##field##_INDEX)
+
+#define GSWSS_GET_BITS(var, prefix, field)                           \
+	GET_BITS((var),                                                \
+		 prefix##_##field##_INDEX,                            \
+		 prefix##_##field##_WIDTH)
+
+#define GSWSS_SET_BITS(var, prefix, field, _val)                     \
+	SET_BITS_VAL((var),                                                \
+		 prefix##_##field##_INDEX,                            \
+		 prefix##_##field##_WIDTH, (_val))
+
+#define GSWSS_RGRD_BITS(reg, field)                         \
+	GET_BITS(GSWSS_RGRD(reg),                          \
+		 reg##_##field##_INDEX,                               \
+		 reg##_##field##_WIDTH)
+
+#define GSWSS_RGWR_BITS(reg, field, val)                  \
+	do {                                                                    \
+		u32 reg_val = GSWSS_RGRD(reg);                \
+		SET_BITS_VAL(reg_val,                                               \
+			 reg##_##field##_INDEX,                               \
+			 reg##_##field##_WIDTH, (val));                      \
+		GSWSS_RGWR(reg, reg_val);                         \
+	} while (0)
+
+#define LMAC_RGRD_BITS(reg, field)                         \
+	GET_BITS(LMAC_RGRD(reg),                          \
+		 reg##_##field##_INDEX,                               \
+		 reg##_##field##_WIDTH)
+
+#define LMAC_RGWR_BITS(reg, field, val)                  \
+	do {                                                                    \
+		u32 reg_val = LMAC_RGRD(reg);                \
+		SET_BITS_VAL(reg_val,                                               \
+			 reg##_##field##_INDEX,                               \
+			 reg##_##field##_WIDTH, (val));                      \
+		LMAC_RGWR(reg, reg_val);                         \
+	} while (0)
+
+#define LMAC_GET_BITS(var, prefix, field)                           \
+	GET_BITS((var), 											   \
+		 prefix##_##field##_INDEX,							  \
+		 prefix##_##field##_WIDTH)
+
+#define LMAC_SET_BITS(var, prefix, field, _val)                     \
+	SET_BITS_VAL((var), 											   \
+		 prefix##_##field##_INDEX,							  \
+		 prefix##_##field##_WIDTH, (_val))
+
+
+#define MAC_TXTS_0(idx)			(0x1250 + (idx * (0x100)))
+#define MAC_TXTS_1(idx)			(0x1254 + (idx * (0x100)))
+#define MAC_TXTS_2(idx)			(0x1258 + (idx * (0x100)))
+#define MAC_TXTS_3(idx)			(0x125C + (idx * (0x100)))
+#define MAC_TXTS_CIC(idx)		(0x1260 + (idx * (0x100)))
+#define MAC_TXTS_ACC(idx)		(0x1264 + (idx * (0x100)))
+#define PHY_MODE(idx)			(0x1270 + (idx * (0x100)))
+#define PHY_STAT(idx)			(0x1274 + (idx * (0x100)))
+#define AHB_TO_PDI(arc_addr) 		(((arc_addr) / 4) & 0xFFFF)
+
+/* PTP Clock in Mhz */
+#define PTP_CLK					 500
+
+#ifdef CONFIG_LGMC_SGMII
+typedef enum
+{
+	HSIO1_XPCS1_HSIO3_PHY0_C10	= 0,
+	HSIO2_XPCS1_HSIO4_PHY0_C10	= 1,
+} LGMC_SGMII_CONNECTION_SEL_t;
+
+typedef enum
+{
+	LGMC_SGMII_1G		= 0,
+	LGMC_SGMII_2G5		= 1,
+} LGMC_SGMII_SPEED_SEL_t;
+#endif
+
+/** \brief Ethernet port duplex status.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum
+{
+	/** Port operates in full-duplex mode */
+	GSW_DUPLEX_FULL	= 0,
+	/** Port operates in half-duplex mode */
+	GSW_DUPLEX_HALF		= 1,
+	/** Port operates in Auto mode */
+	GSW_DUPLEX_AUTO		= 2,
+} GSW_portDuplex_t;
+
+/** \brief Force the MAC and PHY link modus.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum
+{
+	/** Link up. Any connected LED
+	   still behaves based on the real PHY status. */
+	GSW_PORT_LINK_UP	= 0,
+	/** Link down. */
+	GSW_PORT_LINK_DOWN	= 1,
+	/** Link Auto. */
+	GSW_PORT_LINK_AUTO	= 2,
+} GSW_portLink_t;
+
+/** \brief Ethernet port interface mode.
+    A port might support only a subset of the possible settings.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum
+{
+	/** Normal PHY interface (twisted pair), use the internal MII Interface. */
+	GSW_PORT_HW_MII		= 0,
+	/** Reduced MII interface in normal mode. */
+	GSW_PORT_HW_RMII	= 1,
+	/** GMII or MII, depending upon the speed. */
+	GSW_PORT_HW_GMII	= 2,
+	/** RGMII mode. */
+	GSW_PORT_HW_RGMII	= 3,
+	/** XGMII mode. */
+	GSW_PORT_HW_XGMII	= 4,
+} GSW_MII_Mode_t;
+
+typedef enum {
+	MAC_AUTO_DPLX = 0,
+	MAC_FULL_DPLX,
+	MAC_RES_DPLX,
+	MAC_HALF_DPLX,
+} MAC_DUPLEX;
+
+typedef enum {
+	SPEED_10M = 0,
+	SPEED_100M,
+	SPEED_1G,
+	SPEED_10G,
+	SPEED_2G5,
+	SPEED_5G,
+	SPEED_FLEX,
+	SPEED_AUTO
+} SPEED_CFG;
+
+typedef enum {
+	SPEED_LMAC_10M = 0,
+	SPEED_LMAC_100M,
+	SPEED_LMAC_200M,
+	SPEED_LMAC_1G,
+	SPEED_XGMAC_10M,
+	SPEED_XGMAC_100M,
+	SPEED_XGMAC_1G,
+	SPEED_XGMII_25G,
+	SPEED_XGMAC_5G,
+	SPEED_XGMAC_10G,
+	SPEED_GMII_25G,
+	SPEED_MAC_AUTO,
+} SPEED_MAC_CFG;
+
+struct xgmac_mmc_stats {
+	/* Tx Stats */
+	u32 txoctetcount_gb;
+	u32 txframecount_gb;
+	u32 txbroadcastframes_g;
+	u32 txmulticastframes_g;
+	u32 tx64octets_gb;
+	u32 tx65to127octets_gb;
+	u32 tx128to255octets_gb;
+	u32 tx256to511octets_gb;
+	u32 tx512to1023octets_gb;
+	u32 tx1024tomaxoctets_gb;
+	u32 txunicastframes_gb;
+	u32 txmulticastframes_gb;
+	u32 txbroadcastframes_gb;
+	u32 txunderflowerror;
+	u32 txoctetcount_g;
+	u32 txframecount_g;
+	u32 txpauseframes;
+	u32 txvlanframes_g;
+
+	/* Rx Stats */
+	u32 rxframecount_gb;
+	u32 rxoctetcount_gb;
+	u32 rxoctetcount_g;
+	u32 rxbroadcastframes_g;
+	u32 rxmulticastframes_g;
+	u32 rxcrcerror;
+	u32 rxrunterror;
+	u32 rxjabbererror;
+	u32 rxundersize_g;
+	u32 rxoversize_g;
+	u32 rx64octets_gb;
+	u32 rx65to127octets_gb;
+	u32 rx128to255octets_gb;
+	u32 rx256to511octets_gb;
+	u32 rx512to1023octets_gb;
+	u32 rx1024tomaxoctets_gb;
+	u32 rxunicastframes_g;
+	u32 rxlengtherror;
+	u32 rxoutofrangetype;
+	u32 rxpauseframes;
+	u32 rxfifooverflow;
+	u32 rxvlanframes_gb;
+	u32 rxwatchdogerror;
+};
+
+struct hwtstamp_config {
+	int flags;
+	int tx_type;
+	int rx_filter;
+};
+
+typedef enum {
+	LMAC_MII = 0,
+	LMAC_GMII,
+	XGMAC_GMII,
+	XGMAC_XGMII,
+} if_mode;
+
+/** \brief Ethernet port speed mode.
+    For certain generations of GSWIP, a port might support only a subset of the possible settings.
+    Used by \ref GSW_portLinkCfg_t. */
+typedef enum
+{
+	/** 10 Mbit/s */
+	GSW_PORT_SPEED_10	= 10,
+	/** 100 Mbit/s */
+	GSW_PORT_SPEED_100	= 100,
+	/** 200 Mbit/s */
+	GSW_PORT_SPEED_200	= 200,
+	/** 1000 Mbit/s */
+	GSW_PORT_SPEED_1000	= 1000,
+	/** 2.5 Gbit/s */
+	GSW_PORT_SPEED_25000	= 25000,
+	/** 10 Gbit/s */
+	GSW_PORT_SPEED_100000= 100000,
+} GSW_portSpeed_t;
+
+/* This structure contains flags that indicate what hardware features
+ * or configurations are present in the device.
+ */
+struct xgmac_hw_features {
+	/* HW Version */ 
+	u32 version;
+
+	/* HW Feature Register0 */
+	u32 gmii;              /* 1000 Mbps support */
+	u32 vlhash;            /* VLAN Hash Filter */
+	u32 sma;               /* SMA(MDIO) Interface */
+	u32 rwk;               /* PMT remote wake-up packet */
+	u32 mgk;               /* PMT magic packet */
+	u32 mmc;               /* RMON module */
+	u32 aoe;               /* ARP Offload */
+	u32 ts;                /* IEEE 1588-2008 Advanced Timestamp */
+	u32 eee;               /* Energy Efficient Ethernet */
+	u32 tx_coe;            /* Tx Checksum Offload */
+	u32 rx_coe;            /* Rx Checksum Offload */
+	u32 addn_mac;          /* Additional MAC Addresses */
+	u32 ts_src;            /* Timestamp Source */
+	u32 sa_vlan_ins;       /* Source Address or VLAN Insertion */
+	u32 vxn;                                /* VxLAN/NVGRE Support */
+	u32 ediffc;                     /* Different Descriptor Cache */
+	u32 edma;                               /* Enhanced DMA */
+
+	/* HW Feature Register1 */
+	u32 rx_fifo_size;      /* MTL Receive FIFO Size */
+	u32 tx_fifo_size;      /* MTL Transmit FIFO Size */
+	u32 osten;                      /* One-Step Timestamping Enable */
+	u32 ptoen;                      /* PTP Offload Enable */
+	u32 adv_ts_hi;         /* Advance Timestamping High Word */
+	u32 dma_width;         /* DMA width */
+	u32 dcb;               /* DCB Feature */
+	u32 sph;               /* Split Header Feature */
+	u32 tso;               /* TCP Segmentation Offload */
+	u32 dma_debug;         /* DMA Debug Registers */
+	u32 rss;               /* Receive Side Scaling */
+	u32 tc_cnt;            /* Number of Traffic Classes */
+	u32 hash_table_size;   /* Hash Table Size */
+	u32 l3l4_filter_num;   /* Number of L3-L4 Filters */
+	/* HW Feature Register2 */
+	u32 rx_q_cnt;          /* Number of MTL Receive Queues */
+	u32 tx_q_cnt;          /* Number of MTL Transmit Queues */
+	u32 rx_ch_cnt;         /* Number of DMA Receive Channels */
+	u32 tx_ch_cnt;         /* Number of DMA Transmit Channels */
+	u32 pps_out_num;       /* Number of PPS outputs */
+	u32 aux_snap_num;      /* Number of Aux snapshot inputs */
+};
+
+struct ptp_flags {
+	u32 ptp_rx_en;
+	u32 ptp_tx_en;
+};
+
+struct mac_prv_data {
+	/* XGMAC registers for indirect accessing */
+	u32 xgmac_ctrl_reg;
+	u32 xgmac_data0_reg;
+	u32 xgmac_data1_reg;
+
+	/* Index to point XGMAC 2/3/4 */
+	u32 mac_idx;
+
+	/* TX/RX Queues supported by HW */
+	u32 tx_q_count;
+	u32 rx_q_count;
+
+	/* Tx settings */
+	u32 tx_sf_mode;
+	u32 tx_threshold;
+
+	/* Rx settings */
+	u32 rx_sf_mode;
+	u32 rx_threshold;
+
+	/* Flow control settings */
+	u32 pause_autoneg;
+	u32 tx_pause;
+	u32 rx_pause;
+	u32 pause_time;
+	u32 pause_frm_enable;
+
+	u32 mac_en;
+
+	/* MAC Addr */
+	u8 mac_addr[6];
+
+	/* Rmon related settings */
+	struct xgmac_mmc_stats mmc_stats;
+	u32 rmon_reset;
+
+	/* Timestamp support */
+	struct hwtstamp_config tstamp_config;
+	struct ptp_flags ptp_flgs;
+	u32 def_addend;
+	u32 tstamp_addend;
+	u64 tx_tstamp;
+	u32 sec;
+	u32 nsec;
+	u32 one_nsec_accuracy;
+	u32 two_step;
+	u32 snaptype;
+	u32 tsmstrena;
+	u32 tsevntena;
+	u32 ttse;
+	u32 ostc;
+	u32 ostc_avail;
+
+	/* Hardware features of the device */
+	struct xgmac_hw_features hw_feat;
+
+	/* MAC rx mode */
+	u32 promisc_mode;
+	u32 all_mcast_mode;
+
+	u32 rfa;
+	u32 rfd;
+
+	u32 tx_mtl_alg;
+	u32 rx_mtl_alg;
+
+	u32 mtu;
+
+	u32 rx_checksum_offload;
+
+	/* Reg Read/Write */
+	u32 reg_off;
+	u32 reg_val;
+
+	/* Phy status */
+	u32 phy_speed;
+	u32 phymode_speed;
+	u32 phy_link;
+	u32 phy_mode;
+
+	/* Loopback */
+	u32 loopback;
+
+	/* EEE mode */
+	u32 eee_enable;
+	u32 twt;
+	u32 lst;
+	u32 lpitxa;
+
+	/* CRC stripping */
+	u32 crc_strip;
+	u32 crc_strip_type;
+	u32 padcrc_strip;
+
+	/* Debug Mode */
+	u32 dbg_en;
+	u32 dbg_pktie;
+	u32 dbg_rst_sel;
+	u32 dbg_rst_all;
+	u32 dbg_pktstate;
+	u32 dbg_data;
+	u32 dbg_mode;
+	u32 dbg_byteen;
+
+	/* Forward Error paackets */
+	u32 fef;
+	u32 fup;
+
+	/* interrupts */
+	u32 enable_mac_int;
+	u32 enable_mtl_int;
+
+	/* IPG */
+	u32 ipg;
+
+	/* PMT */
+	u32 magic_pkt_en;
+	u32 rwk_pkt_en;
+	u32 rwk_filter_values[8];
+	u32 rwk_filter_length;
+	u32 gucast;
+
+	u32 extcfg;
+
+	u32 set_all;
+	u32 duplex_mode;
+
+	u32 init_val;
+
+	u32 jd;
+	u32 wd;
+
+	u32 linksts;
+
+	u32 fcsgen;
+
+	u32 mdio_cl;
+	u32 dev_adr;
+	u32 phy_id;
+	u32 phy_reg;
+	u32 phy_reg_st;
+	u32 phy_reg_end;
+	u32 phy_data;
+	u32 mdio_int;
+
+	u32 ptp_clk;
+
+	/*struct mac_ops mac_op; */
+};
+
+typedef enum {
+                CTP_PORT_RX_RMON                                                  = 0x00,
+                CTP_PORT_TX_RMON                                                   = 0x01,
+                BRIDGE_PORT_RX_RMON                                                           = 0x02,
+                BRIDGE_PORT_TX_RMON                                                           = 0x03,
+                CTP_PORT_PCE_BYPASS_TX_RMON                                      = 0x04,
+                FLOW_RX_RMON                                                                            = 0x05,
+                FLOW_TX_RMON                                                                            = 0x06,
+                WFQ_PARAM                                                                    = 0x08,
+                PQM_THRESHOLD                                                                           = 0x09,
+                PQM_PACKET_PTR                                                                         = 0x0A,
+                SSL_NEXT_PTR_MEM                                                    = 0x0B,
+                SSL_HEADER_DES_MEM1                                                            = 0x0C,
+                SSL_HEADER_DES_MEM2                                                            = 0x0D,
+                BUF_MGR_Q_MAP_TABLE                                                         = 0x0E,
+                METER_RMON_COUNTER                                                           = 0x19,
+                ROUTING_RMON_COUNTER                                                     = 0x1B,
+                PMAC_RMON_COUNTER                                                            = 0x1C,
+} BM_Table_ID;
+
+/* GSWIP BM Table Address */
+typedef union {
+                u16 raw;
+                struct {
+                                u16 b0: 1, b1: 1, b2: 1, b3: 1, b4: 1, b5: 1, b6: 1, b7: 1,
+                                    b8: 1, b9: 1, b10: 1, b11: 1, b12: 1, b13: 1, b14: 1, b15: 1;
+                } bits;
+                struct {
+                                u16 counterOffset: 6, portOffset: 10;
+                } rmon;
+                struct {
+                                u16 nQueueId: 6, reserved0: 10;
+                } wfq;
+                struct {
+                                u16 color_or_submode: 2, mode: 1, nQueueId: 6, reserved1: 7;
+                } pqmThr;
+                struct {
+                                u16 ptr: 11, reserved2: 5;
+                } pqmPtr;
+                struct {
+                                u16 ptr: 10, reserved3: 6;
+                } ssl;
+                struct {
+                                u16 nQueueId: 6, reserved4: 10;
+                } qMapTbl;
+                struct {
+                                u16 meterNo: 7, reserved5: 1, color: 2, reserved6: 6;
+                } meterRmon;
+                struct {
+                                u16 portNo: 4, counterType: 4, reserved7: 8;
+                } routingRmon;
+                struct {
+                                u16 channel_or_port: 5, count: 3, pmacNo: 3, reserved8: 5;
+                } pmacRmon;
+} BM_Table_Address ;
+
+/* GSWIP BM Table programming structure */
+typedef struct {
+                BM_Table_ID  tableID;
+                BM_Table_Address adr;
+                u32 value[10];
+                int b64bitMode;
+                u32 numValues;
+} bmtbl_prog_t;
+
+
+enum {
+	XPCS0 = 0,
+	XPCS1,
+	XPCS2,
+	XPCS3,
+	WAN_XPCS4,
+	XPCS5,
+};
+
+#define XPCS_PORT_MAX	XPCS5+1
+
+enum {
+	PMA_TYPE_10G_BASE_CX4 = 0,
+	PMA_TYPE_10G_BASE_EW,
+	PMA_TYPE_10G_BASE_LW,
+	PMA_TYPE_10G_BASE_SW,
+	PMA_TYPE_10G_BASE_LX4,
+	PMA_TYPE_10G_BASE_ER,
+	PMA_TYPE_10G_BASE_LR,
+	PMA_TYPE_10G_BASE_SR,
+	PMA_TYPE_10G_BASE_LRM,
+	PMA_TYPE_10G_BASE_T,
+	PMA_TYPE_10G_BASE_KX4,
+	PMA_TYPE_10G_BASE_KR,
+	PMA_TYPE_1G_BASE_T,
+	PMA_TYPE_1G_BASE_KX,
+	PMA_TYPE_100_BASE_TX,
+	PMA_TYPE_10_BASE_T
+};
+
+enum{
+	XFI_10G_KR_NO_ANEG =1,
+	XFI_10G_KR,
+	XFI_5G_KR_NO_ANEG,
+	XFI_5G_KR,
+	SGMII_2500BASEX,	
+	SGMII_2P5G,
+	SGMII_1000BASEX,
+	SGMII_1G,
+	USXGMII_10G,
+	USXGMII_5G,
+	USXGMII_2P5G,
+	RXAUI_10G,
+};
+
+enum{
+	LEFT = 1,
+	RIGHT,
+};
+
+enum{
+	USX_10G = 0,
+	USX_5G,
+	USX_2P5G,
+};
+
+enum{
+	KR_10G = 0,
+	KR_5G,
+	KR_2P5G,
+	BASER_10G,
+};
+
+enum{
+	DISABLE_PRBS = 0,
+	PRBS31,
+	PRBS23,
+	PRBS23_2,
+	PRBS16,
+	PRBS15,
+	PRBS11,
+	PRBS9,
+	PRBS7,
+};
+
+enum{
+	EVAL_BRD = 0,
+	REF_BRD,
+};
+
+enum{
+	USX_SINGLE = 0,
+	USX_QUAD,
+};
+
+enum{
+	TX2RX_SER_LB = 0,
+	RX2TX_PAR_LB,
+	DISABLE_LB,
+};
+
+struct usxspd{
+	int usx_p0_spd;
+	int usx_p1_spd;
+	int usx_p2_spd;
+	int usx_p3_spd;	
+};
+
+/* ANEG register */
+#define ANEG_MGBT_AN_CTRL_REG	0x20
+#define MS_MAN_EN_MASK		0x4000
+#define FR_MASK			0x2
+
+/*XPCS Indirect ADD and DATA Registers */
+#define XPCS0_BASE_DAT									(0xD0A42000)
+#define XPCS1_BASE_DAT									(0xD0B42000)
+#define XPCS2_BASE_DAT									(0xC0A42000)
+#define XPCS3_BASE_DAT									(0xC0B42000)
+#define WAN_XPCS4_BASE_DAT								(0xE7842000) /*Need to confirm. Expected from datasheet is 0xE780 0000 */
+#define XPCS5_BASE_DAT									(0xE7600000) /*Need to confirm again. May be 0xE7642000 */
+
+#define XPCS0_BASE_ADD									(XPCS0_BASE_DAT + 4*(0xFF))
+#define XPCS1_BASE_ADD									(XPCS1_BASE_DAT + 4*(0xFF))
+#define XPCS2_BASE_ADD									(XPCS2_BASE_DAT + 4*(0xFF))
+#define XPCS3_BASE_ADD									(XPCS3_BASE_DAT + 4*(0xFF))
+#define WAN_XCPS4_BASE_ADD								(WAN_XPCS4_BASE_DAT + 4*(0xFF))
+#define XPCS5_BASE_ADD									(XPCS5_BASE_DAT + 4*(0xFF))
+
+/*XPCS Registers */
+#define SR_PMA_CTRL1                                   0x040000
+#define SR_PMA_STATUS1                                 0x040004
+#define SR_PMA_DEV_ID_1                                0x040008
+#define SR_PMA_DEV_ID_2                                0x04000C
+#define SR_PMA_SPD_ABL                                 0x040010
+#define SR_PMA_DEV_PKG1                                0x040014
+#define SR_PMA_DEV_PKG2                                0x040018
+#define SR_PMA_CTRL2                                   0x04001C
+#define SR_PMA_STATUS2                                 0x040020
+#define SR_PMA_TX_DIS                                  0x040024
+#define SR_PMA_RX_SIG_DET                              0x040028
+#define SR_PMA_EXT_ABL                                 0x04002C
+#define SR_PMA_PKG1                                    0x040038
+#define SR_PMA_PKG2                                    0x04003C
+#define SR_PMA_2PT5G_5G_EXT_ABL                        0x040054
+#define SR_PMA_KR_PMD_CTRL                             0x040258
+#define SR_PMA_KR_PMD_STS                              0x04025C
+#define SR_PMA_KR_LP_CEU                               0x040260
+#define SR_PMA_KR_LP_CESTS                             0x040264
+#define SR_PMA_KR_LD_CEU                               0x040268
+#define SR_PMA_KR_LD_CESTS                             0x04026C
+#define SR_PMA_KX_CTRL                                 0x040280
+#define SR_PMA_KX_STS                                  0x040284
+#define SR_PMA_KR_FEC_ABL                              0x0402A8
+#define SR_PMA_KR_FEC_CTRL                             0x0402AC
+#define SR_PMA_KR_FEC_CORR_BLK1                        0x0402B0
+#define SR_PMA_KR_FEC_CORR_BLK2                        0x0402B4
+#define SR_PMA_KR_FEC_UCORR_BLK1                       0x0402B8
+#define SR_PMA_KR_FEC_UCORR_BLK2                       0x0402BC
+#define SR_PMA_TIME_SYNC_PMA_ABL                       0x041C20
+#define SR_PMA_TIME_SYNC_TX_MAX_DLY_LWR                0x041C24
+#define SR_PMA_TIME_SYNC_TX_MAX_DLY_UPR                0x041C28
+#define SR_PMA_TIME_SYNC_TX_MIN_DLY_LWR                0x041C2C
+#define SR_PMA_TIME_SYNC_TX_MIN_DLY_UPR                0x041C30
+#define SR_PMA_TIME_SYNC_RX_MAX_DLY_LWR                0x041C34
+#define SR_PMA_TIME_SYNC_RX_MAX_DLY_UPR                0x041C38
+#define SR_PMA_TIME_SYNC_RX_MIN_DLY_LWR                0x041C3C
+#define SR_PMA_TIME_SYNC_RX_MIN_DLY_UPR                0x041C40
+#define VR_PMA_DIG_CTRL1                               0x060000
+#define VR_PMA_KRTR_PRBS_CTRL0                         0x06000C
+#define VR_PMA_KRTR_PRBS_CTRL1                         0x060010
+#define VR_PMA_KRTR_PRBS_CTRL2                         0x060014
+#define VR_PMA_KRTR_TIMER_CTRL0                        0x060018
+#define VR_PMA_KRTR_TIMER_CTRL1                        0x06001C
+#define VR_PMA_KRTR_TIMER_CTRL2                        0x060020
+#define VR_PMA_KRTR_RX_EQ_CTRL                         0x060024
+#define VR_PMA_KRTR_TX_EQ_STS_CTRL                     0x06002C
+#define VR_PMA_KRTR_TX_EQ_CFF_CTRL                     0x060030
+#define VR_PMA_PHY_TX_EQ_STS                           0x060034
+#define VR_PMA_PHY_RX_EQ_CEU                           0x060038
+#define VR_PMA_DIG_STS                                 0x060040
+#define VR_PMA_GPIO                                    0x060054
+#define VR_XS_PMA_RX_LSTS                              0x060080
+#define VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL0             0x0600C0
+#define VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1             0x0600C4
+#define VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2             0x0600C8
+#define VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL           0x0600CC
+#define VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL            0x0600D0
+#define VR_XS_PMA_GEN5_12G_16G_TX_POWER_STATE_CTRL     0x0600D4
+#define VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0             0x0600D8
+#define VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1             0x0600DC
+#define VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL2             0x0600E0
+#define VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL3             0x0600E4
+#define VR_XS_PMA_GEN5_12G_16G_EQ_INIT_CTRL0           0x0600E8
+#define VR_XS_PMA_GEN5_12G_16G_EQ_INIT_CTRL1           0x0600EC
+#define VR_XS_PMA_GEN5_16G_TX_GEN_CTRL3                0x0600F0
+#define VR_XS_PMA_GEN5_16G_TX_GEN_CTRL4                0x0600F4
+#define VR_XS_PMA_GEN5_16G_TX_MISC_CTRL0               0x0600F8
+#define VR_XS_PMA_GEN5_16G_TX_MISC_CTRL1               0x0600FC
+#define VR_XS_PMA_GEN5_12G_16G_TX_STS                  0x060100
+#define VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL0             0x060140
+#define VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1             0x060144
+#define VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2             0x060148
+#define VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3             0x06014C
+#define VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL            0x060150
+#define VR_XS_PMA_GEN5_12G_16G_RX_POWER_STATE_CTRL     0x060154
+#define VR_XS_PMA_GEN5_12G_16G_RX_CDR_CTRL             0x060158
+#define VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL            0x06015C
+#define VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0                 0x060160
+#define VR_XS_PMA_GEN5_16G_RX_EQ_CTRL1                 0x060164
+#define VR_XS_PMA_GEN5_16G_RX_EQ_CTRL2                 0x060168
+#define VR_XS_PMA_GEN5_16G_RX_EQ_CTRL3                 0x06016C
+#define VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4             0x060170
+#define VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5                 0x060174
+#define VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0           0x060178
+#define VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL1           0x06017C
+#define VR_XS_PMA_GEN5_12G_16G_RX_STS                  0x060180
+#define VR_XS_PMA_GEN5_16G_RX_PPM_STS0                 0x060184
+#define VR_XS_PMA_GEN5_16G_RX_PPM_STS1                 0x060188
+#define VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1                0x060190
+#define VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0                0x060194
+#define VR_XS_PMA_GEN5_16G_RX_PPM_CTRL1                0x060198
+#define VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4                0x0601A0
+#define VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0               0x0601A4
+#define VR_XS_PMA_GEN5_16G_RX_MISC_CTRL1               0x0601A8
+#define VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0                 0x0601AC
+#define VR_XS_PMA_GEN5_16G_RX_IQ_CTRL1                 0x0601B0
+#define VR_XS_PMA_GEN5_16G_RX_IQ_CTRL2                 0x0601B4
+#define VR_XS_PMA_GEN5_16G_RX_IQ_CTRL3                 0x0601B8
+#define VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL           0x0601C0
+#define VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0             0x0601C4
+#define VR_XS_PMA_GEN5_16G_MPLLA_CTRL1                 0x0601C8
+#define VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2             0x0601CC
+#define VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0             0x0601D0
+#define VR_XS_PMA_GEN5_16G_MPLLB_CTRL1                 0x0601D4
+#define VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2             0x0601D8
+#define VR_XS_PMA_GEN5_16G_MPLLA_CTRL3                 0x0601DC
+#define VR_XS_PMA_GEN5_16G_MPLLB_CTRL3                 0x0601E0
+#define VR_XS_PMA_GEN5_16G_MPLLA_CTRL4                 0x0601E4
+#define VR_XS_PMA_GEN5_16G_MPLLA_CTRL5                 0x0601E8
+#define VR_XS_PMA_GEN5_16G_MPLLB_CTRL4                 0x0601EC
+#define VR_XS_PMA_GEN5_16G_MPLLB_CTRL5                 0x0601F0
+#define VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0              0x060240
+#define VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL            0x060244
+#define VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0             0x060248
+#define VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD1             0x06024C
+#define VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD2             0x060250
+#define VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD3             0x060254
+#define VR_XS_PMA_GEN5_16G_VCO_CAL_REF0                0x060258
+#define VR_XS_PMA_GEN5_16G_VCO_CAL_REF1                0x06025C
+#define VR_XS_PMA_GEN5_12G_16G_MISC_STS                0x060260
+#define VR_XS_PMA_GEN5_12G_16G_MISC_CTRL1              0x060264
+#define VR_XS_PMA_GEN5_12G_16G_EEE_CTRL                0x060268
+#define VR_XS_PMA_GEN5_12G_16G_SRAM                    0x06026C
+#define VR_XS_PMA_GEN5_16G_MISC_CTRL2                  0x060270
+#define VR_XS_PMA_SNPS_CR_CTRL                         0x060280
+#define VR_XS_PMA_SNPS_CR_ADDR                         0x060284
+#define VR_XS_PMA_SNPS_CR_DATA                         0x060288
+#define VR_MII_GEN5_12G_16G_SRAM                       0x0802EC
+#define SR_XS_PCS_CTRL1                                0x0C0000
+#define SR_XS_PCS_STS1                                 0x0C0004
+#define SR_XS_PCS_DEV_ID1                              0x0C0008
+#define SR_XS_PCS_DEV_ID2                              0x0C000C
+#define SR_XS_PCS_SPD_ABL                              0x0C0010
+#define SR_XS_PCS_DEV_PKG1                             0x0C0014
+#define SR_XS_PCS_DEV_PKG2                             0x0C0018
+#define SR_XS_PCS_CTRL2                                0x0C001C
+#define SR_XS_PCS_STS2                                 0x0C0020
+#define SR_XS_PCS_STS3                                 0x0C0024
+#define SR_XS_PCS_PKG1                                 0x0C0038
+#define SR_XS_PCS_PKG2                                 0x0C003C
+#define SR_XS_PCS_EEE_ABL                              0x0C0050
+#define SR_XS_PCS_EEE_ABL2                             0x0C0054
+#define SR_XS_PCS_EEE_WKERR                            0x0C0058
+#define SR_XS_PCS_LSTS                                 0x0C0060
+#define SR_XS_PCS_TCTRL                                0x0C0064
+#define SR_XS_PCS_KR_STS1                              0x0C0080
+#define SR_XS_PCS_KR_STS2                              0x0C0084
+#define SR_XS_PCS_TP_A0                                0x0C0088
+#define SR_XS_PCS_TP_A1                                0x0C008C
+#define SR_XS_PCS_TP_A2                                0x0C0090
+#define SR_XS_PCS_TP_A3                                0x0C0094
+#define SR_XS_PCS_TP_B0                                0x0C0098
+#define SR_XS_PCS_TP_B1                                0x0C009C
+#define SR_XS_PCS_TP_B2                                0x0C00A0
+#define SR_XS_PCS_TP_B3                                0x0C00A4
+#define SR_XS_PCS_TP_CTRL                              0x0C00A8
+#define SR_XS_PCS_TP_ERRCTR                            0x0C00AC
+#define SR_PCS_TIME_SYNC_PCS_ABL                       0x0C1C20
+#define SR_PCS_TIME_SYNC_TX_MAX_DLY_LWR                0x0C1C24
+#define SR_PCS_TIME_SYNC_TX_MAX_DLY_UPR                0x0C1C28
+#define SR_PCS_TIME_SYNC_TX_MIN_DLY_LWR                0x0C1C2C
+#define SR_PCS_TIME_SYNC_TX_MIN_DLY_UPR                0x0C1C30
+#define SR_PCS_TIME_SYNC_RX_MAX_DLY_LWR                0x0C1C34
+#define SR_PCS_TIME_SYNC_RX_MAX_DLY_UPR                0x0C1C38
+#define SR_PCS_TIME_SYNC_RX_MIN_DLY_LWR                0x0C1C3C
+#define SR_PCS_TIME_SYNC_RX_MIN_DLY_UPR                0x0C1C40
+#define VR_XS_PCS_DIG_CTRL1                            0x0E0000
+#define VR_XS_PCS_DIG_CTRL2                            0x0E0004
+#define VR_XS_PCS_DIG_ERRCNT_SEL                       0x0E0008
+#define VR_XS_PCS_XAUI_CTRL                            0x0E0010
+#define VR_XS_PCS_DEBUG_CTRL                           0x0E0014
+#define VR_XS_PCS_EEE_MCTRL0                           0x0E0018
+#define VR_XS_PCS_KR_CTRL                              0x0E001C
+#define VR_XS_PCS_EEE_TXTIMER                          0x0E0020
+#define VR_XS_PCS_EEE_RXTIMER                          0x0E0024
+#define VR_XS_PCS_AM_CTRL                              0x0E0028
+#define VR_XS_PCS_EEE_MCTRL1                           0x0E002C
+#define VR_XS_PCS_DIG_STS                              0x0E0040
+#define VR_XS_PCS_ICG_ERRCNT1                          0x0E0044
+#define VR_XS_PCS_ICG_ERRCNT2                          0x0E0048
+#define VR_XS_PCS_DSKW_ERRCTR                          0x0E004C
+#define VR_XS_PCS_TPM_ERRCTR                           0x0E0050
+#define VR_XS_PCS_GPIO                                 0x0E0054
+#define SR_AN_CTRL                                     0x1C0000
+#define SR_AN_STS                                      0x1C0004
+#define SR_AN_DEV_ID1                                  0x1C0008
+#define SR_AN_DEV_ID2                                  0x1C000C
+#define SR_AN_DEV_PKG1                                 0x1C0014
+#define SR_AN_DEV_PKG2                                 0x1C0018
+#define SR_AN_PKG1                                     0x1C0038
+#define SR_AN_PKG2                                     0x1C003C
+#define SR_AN_ADV1                                     0x1C0040
+#define SR_AN_ADV2                                     0x1C0044
+#define SR_AN_ADV3                                     0x1C0048
+#define SR_AN_LP_ABL1                                  0x1C004C
+#define SR_AN_LP_ABL2                                  0x1C0050
+#define SR_AN_LP_ABL3                                  0x1C0054
+#define SR_AN_XNP_TX1                                  0x1C0058
+#define SR_AN_XNP_TX2                                  0x1C005C
+#define SR_AN_XNP_TX3                                  0x1C0060
+#define SR_AN_LP_XNP_ABL1                              0x1C0064
+#define SR_AN_LP_XNP_ABL2                              0x1C0068
+#define SR_AN_LP_XNP_ABL3                              0x1C006C
+#define SR_AN_COMP_STS                                 0x1C00C0
+#define SR_AN_EEE_ABL1                                 0x1C00F0
+#define SR_AN_EEE_LP_ABL1                              0x1C00F4
+#define SR_AN_EEE_ABL2                                 0x1C00F8
+#define SR_AN_EEE_LP_ABL2                              0x1C00FC
+#define VR_AN_DIG_CTRL1                                0x1E0000
+#define VR_AN_INTR_MSK                                 0x1E0004
+#define VR_AN_INTR                                     0x1E0008
+#define VR_AN_KR_MODE_CTRL                             0x1E000C
+#define VR_AN_TIMER_CTRL0                              0x1E0010
+#define VR_AN_TIMER_CTRL1                              0x1E0014
+#define SR_VSMMD_PMA_ID1                               0x780000
+#define SR_VSMMD_PMA_ID2                               0x780004
+#define SR_VSMMD_DEV_ID1                               0x780008
+#define SR_VSMMD_DEV_ID2                               0x78000C
+#define SR_VSMMD_PCS_ID1                               0x780010
+#define SR_VSMMD_PCS_ID2                               0x780014
+#define SR_VSMMD_AN_ID1                                0x780018
+#define SR_VSMMD_AN_ID2                                0x78001C
+#define SR_VSMMD_STS                                   0x780020
+#define SR_VSMMD_CTRL                                  0x780024
+#define SR_VSMMD_PKGID1                                0x780038
+#define SR_VSMMD_PKGID2                                0x78003C
+#define SR_MII_CTRL                                    0x7C0000
+#define SR_MII_STS                                     0x7C0004
+#define SR_MII_DEV_ID1                                 0x7C0008
+#define SR_MII_DEV_ID2                                 0x7C000C
+#define SR_MII_AN_ADV                                  0x7C0010
+#define SR_MII_LP_BABL                                 0x7C0014
+#define SR_MII_AN_EXPN                                 0x7C0018
+#define SR_MII_EXT_STS                                 0x7C003C
+#define VR_MII_DIG_CTRL1                               0x7E0000
+#define VR_MII_AN_CTRL                                 0x7E0004
+#define VR_MII_AN_INTR_STS                             0x7E0008
+#define VR_MII_LINK_TIMER_CTRL                         0x7E0028
+#define VR_MII_GPIO                                    0x7E0054 
+#define SR_MII_1_CTRL                                  0x680000
+#define SR_MII_1_STS                                   0x680004
+#define SR_MII_1_DEV_ID1                               0x680008
+#define SR_MII_1_DEV_ID2                               0x68000c
+#define SR_MII_1_AN_ADV                                0x680010
+#define SR_MII_1_LP_BABL                               0x680014
+#define SR_MII_1_EXPN                                  0x680018
+#define SR_MII_1_EXT_STS                               0x68003c
+#define VR_MII_1_DIG_CTRL1                             0x6a0000
+#define VR_MII_1_AN_CTRL                               0x6a0004
+#define VR_MII_1_AN_INTR_STS                           0x6a0008
+#define VR_MII_1_DBG_CTRL                              0x6a0014
+#define VR_MII_1_LINK_TIMER_CTRL                       0x6a0028
+#define VR_MII_1_DIG_STS                               0x6a0040
+#define VR_MII_1_ICG_ERRCNT1                           0x6a0044
+#define VR_MII_1_DIG_ERRCNT_SEL                        0x6a0388
+#define SR_MII_2_CTRL                                  0x6c0000
+#define SR_MII_2_STS                                   0x6c0004
+#define SR_MII_2_DEV_ID1                               0x6c0008
+#define SR_MII_2_DEV_ID2                               0x6c000c
+#define SR_MII_2_AN_ADV                                0x6c0010
+#define SR_MII_2_LP_BABL                               0x6c0014
+#define SR_MII_2_EXPN                                  0x6c0018
+#define SR_MII_2_EXT_STS                               0x6c003c
+#define VR_MII_2_DIG_CTRL1                             0x6e0000
+#define VR_MII_2_AN_CTRL                               0x6e0004
+#define VR_MII_2_AN_INTR_STS                           0x6e0008
+#define VR_MII_2_DBG_CTRL                              0x6e0014
+#define VR_MII_2_LINK_TIMER_CTRL                       0x6e0028
+#define VR_MII_2_DIG_STS                               0x6e0040
+#define VR_MII_2_ICG_ERRCNT1                           0x6e0044
+#define VR_MII_2_DIG_ERRCNT_SEL                        0x6e0388
+#define SR_MII_3_CTRL                                  0x700000
+#define SR_MII_3_STS                                   0x700004
+#define SR_MII_3_DEV_ID1                               0x700008
+#define SR_MII_3_DEV_ID2                               0x70000c
+#define SR_MII_3_AN_ADV                                0x700010
+#define SR_MII_3_LP_BABL                               0x700014
+#define SR_MII_3_EXPN                                  0x700018
+#define SR_MII_3_EXT_STS                               0x70003c
+#define VR_MII_3_DIG_CTRL1                             0x720000
+#define VR_MII_3_AN_CTRL                               0x720004
+#define VR_MII_3_AN_INTR_STS                           0x720008
+#define VR_MII_3_DBG_CTRL                              0x720014
+#define VR_MII_3_LINK_TIMER_CTRL                       0x720028
+#define VR_MII_3_DIG_STS                               0x720040
+#define VR_MII_3_ICG_ERRCNT1                           0x720044
+#define VR_MII_3_DIG_ERRCNT_SEL                        0x720388
+
+#define VR_MII_Gen5_12G_16G_MISC_CTRL0						 0x7E0240
+#define VR_MII_Gen5_12G_16G_RX_GENCTRL1					 0x7E0144
+#define VR_MII_Gen5_12G_16G_MPLLB_CTRL0					 0x7E01D0
+#define VR_MII_MP_12G_16G_25G_MPLL_CMN_CTRL 				 0x7E01C0
+
+
+/*GSWIP Registers */
+/*GSWIP BASE Register */
+#define GSWIP_O_SUBSYSTEM_BASE	0xE7140000UL
+/*MAC2  */
+#define MAC2_IF_CFG				0x1200
+#define PHY2_MODE				0x1270
+#define PHY_STAT_2				0x1274
+#define ANEG_EEE_2				0x1278
+
+/*MAC3 */
+#define MAC3_IF_CFG				0x1300
+#define PHY3_MODE				0x1370
+#define PHY_STAT_3				0x1374
+#define ANEG_EEE_3				0x1378
+
+/*MAC4 */
+#define MAC4_IF_CFG				0x1400
+#define PHY4_MODE				0x1470
+#define PHY_STAT_4				0x1474
+#define ANEG_EEE_4				0x1478
+
+/*MAC5 */
+#define MAC5_IF_CFG				0x1500
+#define PHY5_MODE				0x1570
+#define PHY_STAT_5				0x1574
+#define ANEG_EEE_5				0x1578
+
+/*MAC6 */
+#define MAC6_IF_CFG				0x1600
+#define PHY6_MODE				0x1670
+#define PHY_STAT_6				0x1674
+#define ANEG_EEE_6				0x1678
+
+/*MAC7 */
+#define MAC7_IF_CFG				0x1700
+#define PHY7_MODE				0x1770
+#define PHY_STAT_7				0x1774
+#define ANEG_EEE_7				0x1778
+
+/*MAC8 */
+#define MAC8_IF_CFG				0x1800
+#define PHY8_MODE				0x1870
+#define PHY_STAT_8				0x1874
+#define ANEG_EEE_8				0x1878
+
+/*MAC9 */
+#define MAC9_IF_CFG				0x1900
+#define PHY9_MODE				0x1970
+#define PHY_STAT_9				0x1974
+#define ANEG_EEE_9				0x1978
+
+/*MAC10 */
+#define MAC10_IF_CFG			0x1A00
+#define PHY10_MODE				0x1A70
+#define PHY_STAT_10				0x1A74
+#define ANEG_EEE_10				0x1A78
+
+u32 indirect_pcs_rd (u32 address, int xpcs_prt);
+u32 indirect_pcs_wr (u32 address, u32 wr_data, int xpcs_prt);
+int sram_init_chk(int port, int base1000x_en);
+void check_rxtx_stable(int port);
+void vr_reset(int port, int base1000x);
+void pma_type_config(int port);
+void xfi_10g5g2p5g_kr_cl73_bringup(int port, int speed);
+void usxgmii_init(int port, int speed, int mode);
+int usxgmii_bringup(int port, int speed, int mode);
+void sgmii_2p5g_bringup(int port);
+void base_1g_bringup(int port);
+void xpcs_loopback(int mode, int port, int workaround_en);
+void pma_loopback(int mode, int port);
+void linkup_status(int port);
+void xpcs_prbs31_enable(int port, int tx_en, int rx_en);
+void xpcs_prbs31_disable(int port);
+void read_xpcs_prbs31_rx_errcnt(int port);
+void eee_disable(int port);
+void xpcs_read(int port, u32 offset);
+void xpcs_write(int port, u32 offset, u32 write_dat);
+int usxgmii_stat_chk(int port, int mode, struct usxspd *usx_speed);
+
+u32 CLEAR_DATA_BITS(u32 data, int startb, int width);
+u32 SET_DATA_BITS(u32 data, int startb, int width, unsigned int set_data);
+u32 GET_DATA_BITS(u32 data, int startb, int width);
+void xpcs_clk_comp_check(int port);
+void disable_an(int port);
+void disable_an_37(int port);
+int __usxgmii_fabric_rd(struct mac_prv_data *pdata, u32 regaddr);
+void __gpy2xx_fabric_wradr(struct mac_prv_data *pdata, u32 regaddr);
+void __usxgmii_fabric_wr(struct mac_prv_data *pdata, u32 regaddr, u32 data);
+
+#define GET_X_BITS(reg, pos, n) \
+	(((reg) >> (pos)) & ((0x1 << (n)) - 1))
+
+#define SET_X_BITS(reg, pos, n, val)                            \
+	do {                                                    \
+		(reg) &= ~(((0x1 << (n)) - 1) << (pos));               \
+		(reg) |= (((val) & ((0x1 << (n)) - 1)) << (pos));     \
+	} while (0)
+		 
+#endif /* __LIGHTNING_MOUNTAIN_SW_H */
diff --git a/drivers/net/lightning_mountain_sw_ucode.h b/drivers/net/lightning_mountain_sw_ucode.h
new file mode 100644
--- /dev/null
+++ b/drivers/net/lightning_mountain_sw_ucode.h
@@ -0,0 +1,497 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright © 2022 MaxLinear, Inc.
+ *
+ * Lightning Mountain Slim Ethernet Driver
+ *
+ */
+typedef struct {
+   u16 val_3;
+   u16 val_2;
+   u16 val_1;
+   u16 val_0;
+} pce_uc_row_t;
+
+typedef struct {
+	u16 key[16];
+	u16 mask[4];
+	u16 val[16];
+	u16 table;
+	u16 table_index;
+	u16 op_mode:2;
+	u16 extop:1;
+	u16 key_format:1;
+	u16 type:1;
+	u16 valid:1;
+	u16 group:4;
+} pce_table_prog_t;
+
+/** Description */
+typedef enum {
+  TABLE_ACCESS_OP_MODE_ADRD = 0,
+  TABLE_ACCESS_OP_MODE_ADWR = 1,
+  TABLE_ACCESS_OP_MODE_KSRD = 2,
+  TABLE_ACCESS_OP_MODE_KSWR = 3
+} table_access_op_mode_t;
+
+#define PCE_MICRO_TABLE_SIZE 256
+#define INSTR 0
+#define IPV6 1
+#define LENACCU 2
+#define GSW_ENABLE	1
+#define GSW_DISABLE 0
+#define GSW_TRUE	1
+#define GSW_FALSE	0
+
+typedef pce_uc_row_t PCE_MICROCODE[PCE_MICRO_TABLE_SIZE];
+
+/* parser's microcode flag type */
+enum {
+	FLAG_NO = 0,
+	FLAG_END,
+	FLAG_CAPWAP,
+	FLAG_GRE,
+	FLAG_LEN,
+	FLAG_GREK,
+	FLAG_NN1,
+	FLAG_NN2,
+	FLAG_ITAG,
+	FLAG_1VLAN,
+	FLAG_2VLAN,  /* 10 */
+	FLAG_3VLAN,
+	FLAG_4VLAN,
+	FLAG_SNAP,
+	FLAG_PPPOES,
+	FLAG_1IPV4,
+	FLAG_1IPV6,
+	FLAG_2IPV4,
+	FLAG_2IPV6,
+	FLAG_ROUTEXP,
+	FLAG_TCP,  /* 20 */
+	FLAG_1UDP,
+	FLAG_IGMP,
+	FLAG_IPV4OPT,
+	FLAG_1IPV6EXT,
+	FLAG_TCPACK,
+	FLAG_IPFRAG,
+	FLAG_EAPOL,
+	FLAG_2IPV6EXT,
+	FLAG_2UDP,
+	FLAG_L2TPNEXP,	/* 30 */
+	FLAG_LROEXP,
+	FLAG_L2TP,
+	FLAG_GRE_VLAN1,
+	FLAG_GRE_VLAN2,
+	FLAG_GRE_PPPOE,
+	FLAG_NN13,
+	FLAG_NN14,
+	FLAG_NN15,
+	FLAG_NN16,
+	FLAG_NN17, /* 40 */
+	FLAG_NN18,
+	FLAG_NN19,
+	FLAG_NN20,
+	FLAG_NN21,
+	FLAG_NN22,
+	FLAG_NN23,
+	FLAG_NN24,
+	FLAG_NN25,
+	FLAG_NN26,
+	FLAG_NN27, /* 50 */
+	FLAG_NN28,
+	FLAG_NN29,
+	FLAG_NN30,
+	FLAG_NN31,
+	FLAG_NN32,
+	FLAG_NN33,
+	FLAG_NN34,
+	FLAG_NN35,
+	FLAG_NN36,
+	FLAG_NN37, /* 60 */
+	FLAG_NN38,
+	FLAG_NN39,
+	FLAG_NN40,
+};
+
+/* parser's microcode output field type */
+enum {
+	OUT_MAC0 = 0,
+	OUT_MAC1,
+	OUT_MAC2,
+	OUT_MAC3,
+	OUT_MAC4,
+	OUT_MAC5,
+	OUT_ITAG0,
+	OUT_ITAG1,
+	OUT_ITAG2,
+	OUT_ITAG3,
+	OUT_1VTAG0, /* 10 */
+	OUT_1VTAG1,
+	OUT_2VTAG0,
+	OUT_2VTAG1,
+	OUT_3VTAG0,
+	OUT_3VTAG1,
+	OUT_4VTAG0,
+	OUT_4VTAG1,
+	OUT_ETYPE,
+	OUT_PPPOE0,
+	OUT_PPPOE1, /* 20 */
+	OUT_PPPOE3,
+	OUT_PPP,
+	OUT_RES,
+	OUT_1IP0,
+	OUT_1IP1,
+	OUT_1IP2, 
+	OUT_1IP3,
+	OUT_1IP4,
+	OUT_1IP5,
+	OUT_1IP6, /* 30 */
+	OUT_1IP7,
+	OUT_1IP8,
+	OUT_1IP9,
+	OUT_1IP10,
+	OUT_1IP11,
+	OUT_1IP12,
+	OUT_1IP13,
+	OUT_1IP14,
+	OUT_1IP15,
+	OUT_1IP16, /* 40 */
+	OUT_1IP17,
+	OUT_1IP18,
+	OUT_1IP19,
+	OUT_2IP0,
+	OUT_2IP1,
+	OUT_2IP2,
+	OUT_2IP3,
+	OUT_2IP4,
+	OUT_2IP5,
+	OUT_2IP6, /* 50 */
+	OUT_2IP7,
+	OUT_2IP8,
+	OUT_2IP9,
+	OUT_2IP10,
+	OUT_2IP11,
+	OUT_2IP12,
+	OUT_2IP13,
+	OUT_2IP14,
+	OUT_2IP15,
+	OUT_2IP16, /* 60 */
+	OUT_2IP17,
+	OUT_2IP18,
+	OUT_2IP19,
+	OUT_APP0,
+	OUT_APP1,
+	OUT_APP2,
+	OUT_APP3,
+	OUT_APP4,		
+	OUT_APP5,
+	OUT_APP6, /* 70 */
+	OUT_APP7,
+	OUT_APP8,
+	OUT_APP9,
+	OUT_1PL,
+	OUT_2PL,
+	OUT_1LNH,
+	OUT_2LNH = 77,
+	OUT_NONE = 127
+};
+typedef struct { 
+	u16 num_key;
+	u16 num_mask;
+	u16 num_val;
+} gsw_pce_tbl_info_t;
+
+#define PCE_MC_M3(val, msk, ns, out, len, type, flags, ipv4_len) \
+    { val, msk, (ns << 8 | out << 0),\
+        (len | type << 5 | flags << 8 | ipv4_len << 7)}
+
+const PCE_MICROCODE pce_mc_max_ifx_tag_m_30 = {/* V31_01 */
+	PCE_MC_M3(0x88C3 , 0xFFFF ,  1 , OUT_ITAG0  , 4 , INSTR , FLAG_ITAG , 0),
+	PCE_MC_M3(0x8100 , 0xFFFF ,  4 , OUT_1VTAG0 , 2 , INSTR , FLAG_1VLAN , 0),
+	PCE_MC_M3(0x88A8 , 0xFFFF ,  4 , OUT_1VTAG0 , 2 , INSTR , FLAG_1VLAN , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 12 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x8100 , 0xFFFF ,  7 , OUT_2VTAG0 , 2 , INSTR , FLAG_2VLAN , 0),
+	PCE_MC_M3(0x88A8 , 0xFFFF ,  7 , OUT_2VTAG0 , 2 , INSTR , FLAG_2VLAN , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 12 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x8100 , 0xFFFF , 10 , OUT_3VTAG0 , 2 , INSTR , FLAG_3VLAN , 0),
+	PCE_MC_M3(0x88A8 , 0xFFFF , 10 , OUT_3VTAG0 , 2 , INSTR , FLAG_3VLAN , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 12 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x8100 , 0xFFFF , 10 , OUT_NONE   , 2 , INSTR , FLAG_ROUTEXP , 0),
+	PCE_MC_M3(0x88A8 , 0xFFFF , 10 , OUT_NONE   , 2 , INSTR , FLAG_ROUTEXP , 0),
+	PCE_MC_M3(0x0000 , 0xF800 , 14 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 20 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0600 , 0x0600 , 20 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 16 , OUT_ETYPE  , 1 , INSTR , FLAG_LEN , 0),
+	PCE_MC_M3(0xAAAA , 0xFFFF , 18 , OUT_APP0   , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 80 , OUT_APP0   , 2 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0300 , 0xFF00 , 20 , OUT_APP1   , 2 , INSTR , FLAG_SNAP , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 80 , OUT_APP1   , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x8864 , 0xFFFF , 25 , OUT_ETYPE  , 4 , INSTR , FLAG_PPPOES , 0),
+	PCE_MC_M3(0x0800 , 0xFFFF , 28 , OUT_ETYPE  , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x86DD , 0xFFFF , 35 , OUT_ETYPE  , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x888E , 0xFFFF , 79 , OUT_ETYPE  , 1 , INSTR , FLAG_EAPOL , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_ETYPE  , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0021 , 0xFFFF , 28 , OUT_PPP    , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0057 , 0xFFFF , 35 , OUT_PPP    , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_PPP    , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 29 , OUT_1IP0   , 4 , INSTR , FLAG_1IPV4 , 1),
+	PCE_MC_M3(0x0011 , 0x00FF , 77 , OUT_1IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0006 , 0x00FF , 74 , OUT_1IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0002 , 0x00FF , 78 , OUT_1IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0029 , 0x00FF , 59 , OUT_1IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0004 , 0x00FF , 54 , OUT_1IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_1IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 36 , OUT_1IP0   , 3 , INSTR , FLAG_1IPV6 , 0),
+	PCE_MC_M3(0x1100 , 0xFF00 , 77 , OUT_1IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0600 , 0xFF00 , 74 , OUT_1IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0400 , 0xFF00 , 54 , OUT_1IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x2900 , 0xFF00 , 59 , OUT_1IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0xFF00 , 44 , OUT_1IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x2B00 , 0xFF00 , 44 , OUT_1IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x3C00 , 0xFF00 , 44 , OUT_1IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_1IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x00F8 , 46 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0xFF00 , 44 , OUT_1LNH   , 1 , IPV6 , FLAG_1IPV6EXT , 0),
+	PCE_MC_M3(0x2B00 , 0xFF00 , 44 , OUT_1LNH   , 1 , IPV6 , FLAG_1IPV6EXT , 0),
+	PCE_MC_M3(0x3C00 , 0xFF00 , 44 , OUT_1LNH   , 1 , IPV6 , FLAG_1IPV6EXT , 0),
+	PCE_MC_M3(0x1100 , 0xFF00 , 77 , OUT_1LNH   , 1 , IPV6 , FLAG_1IPV6EXT , 0),
+	PCE_MC_M3(0x0600 , 0xFF00 , 74 , OUT_1LNH   , 1 , IPV6 , FLAG_1IPV6EXT , 0),
+	PCE_MC_M3(0x0400 , 0xFF00 , 54 , OUT_1LNH   , 1 , IPV6 , FLAG_1IPV6EXT , 0),
+	PCE_MC_M3(0x2900 , 0xFF00 , 59 , OUT_1LNH   , 1 , IPV6 , FLAG_1IPV6EXT , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_1LNH   , 1 , IPV6 , FLAG_1IPV6EXT , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 55 , OUT_2IP0   , 4 , INSTR , FLAG_2IPV4 , 1),
+	PCE_MC_M3(0x0011 , 0x00FF , 77 , OUT_2IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0006 , 0x00FF , 74 , OUT_2IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0002 , 0x00FF , 78 , OUT_2IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_2IP4   , 6 , LENACCU , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 60 , OUT_2IP0   , 3 , INSTR , FLAG_2IPV6 , 0),
+	PCE_MC_M3(0x1100 , 0xFF00 , 77 , OUT_2IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0600 , 0xFF00 , 74 , OUT_2IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0xFF00 , 66 , OUT_2IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x2B00 , 0xFF00 , 66 , OUT_2IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x3C00 , 0xFF00 , 66 , OUT_2IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_2IP3   , 17 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x00F8 , 68 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_NONE   , 0 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0xFF00 , 66 , OUT_2LNH   , 1 , IPV6 , FLAG_2IPV6EXT , 0),
+	PCE_MC_M3(0x2B00 , 0xFF00 , 66 , OUT_2LNH   , 1 , IPV6 , FLAG_2IPV6EXT , 0),
+	PCE_MC_M3(0x3C00 , 0xFF00 , 66 , OUT_2LNH   , 1 , IPV6 , FLAG_2IPV6EXT , 0),
+	PCE_MC_M3(0x1100 , 0xFF00 , 77 , OUT_2LNH   , 1 , IPV6 , FLAG_2IPV6EXT , 0),
+	PCE_MC_M3(0x0600 , 0xFF00 , 74 , OUT_2LNH   , 1 , IPV6 , FLAG_2IPV6EXT , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 79 , OUT_2LNH   , 1 , IPV6 , FLAG_2IPV6EXT , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 75 , OUT_APP0   , 6 , INSTR , FLAG_TCP , 0),
+	PCE_MC_M3(0x0010 , 0x0010 , 80 , OUT_APP6   , 4 , INSTR , FLAG_TCPACK , 0),
+	PCE_MC_M3(0x0000 , 0x0010 , 80 , OUT_APP6   , 4 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 80 , OUT_APP0   , 4 , INSTR , FLAG_1UDP , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 80 , OUT_APP0   , 4 , INSTR , FLAG_IGMP , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 80 , OUT_APP0   , 2 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 81 , OUT_1PL    , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_2PL    , 1 , INSTR , FLAG_NO , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+	PCE_MC_M3(0x0000 , 0x0000 , 82 , OUT_NONE   , 0 , INSTR , FLAG_END , 0),
+};
+
+u32 gsw_reg_read(u32 base_addr, u32 offset)
+{
+	return readl(base_addr + (offset * 4));
+}
+
+u32 gsw_reg_write(u32 base_addr, u32 offset, u32 data)
+{
+	writel(data, base_addr + (offset * 4));
+	return 0;
+}
+
+void gsw_w32(u32 base_addr, short Offset, short Shift, short Size, u32 value)
+{
+	u32 regValue, mask;
+	regValue = gsw_reg_read(base_addr, Offset);
+	mask = (1 << Size) - 1;
+	mask = (mask << Shift);
+	value = ((value << Shift) & mask);
+	value = ((regValue & ~mask) | value);
+	gsw_reg_write(base_addr, Offset, value);
+}
+
+void gsw_r32(u32 base_addr, short Offset, short Shift, short Size, u32 *value)
+{
+	u32 regValue, mask;
+	regValue = gsw_reg_read(base_addr, Offset);
+	mask = (1 << Size) - 1 ;
+	regValue = (regValue >> Shift);
+	*value = (regValue & mask);
+}
+
diff --git a/drivers/net/lightning_mountain_xpcs.c b/drivers/net/lightning_mountain_xpcs.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/lightning_mountain_xpcs.c
@@ -0,0 +1,8609 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright © 2022 MaxLinear, Inc.
+ *
+ * Lightning Mountain Slim Ethernet Driver
+ *
+ */
+#include <common.h>
+#include <config.h>
+#include <dm.h>
+#include <malloc.h>
+#include <net.h>
+#include <asm/io.h>
+#include <asm/arch/project.h>
+#include <asm/lib_dma.h>
+#include <asm/cache.h>
+#include <asm/arch-lightning/chip_top.h>
+#include <linux/delay.h>
+
+#include "lightning_mountain_sw.h"
+#include "lightning_mountain_combophy.h"
+
+#if defined(CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET)
+#define SRAM_INIT_DONE			BIT(2)
+#define SRAM_LOAD_DONE			BIT(1)
+#define XPCS0_XGMII_CLK_CTR_REG						0x130
+#define XPCS1_XGMII_CLK_CTR_REG						0x134
+//#define CHIP_TOP							0xE0020000
+#define XGMII_CLK_EN_POS					16
+#define XGMII_CLK_EN_WIDTH					1
+#define XPCS0_XGMII_CLK_CTR_POS						0
+#define XPCS0_XGMII_CLK_CTR_WIDTH					0x1
+#define XPCS1_XGMII_CLK_CTR_POS						0
+#define XPCS1_XGMII_CLK_CTR_WIDTH					0x1
+#define RSVDP_REG0_XGMII_TX_CLKG_POS		0
+#define RSVDP_REG0_XGMII_TX_CLKG_WIDTH		1
+#define RSVDP_REG0_XGMII_RX_CLKG_POS		1
+#define RSVDP_REG0_XGMII_RX_CLKG_WIDTH		1
+#define RAWLANEN_DIG_AON_RX_ADAPT_DONE(X,Y)				(COMBO_PHY_CR_PORT_TO_BASE(X) + ((0x305e + (Y*0x100)) << 2)) //BIT0 RX_ADAPT_DONE
+#define RAWLANEN_DIG_AON_RX_ADAPT_DONE_OFFSET(Y)		(0x305e + (Y*0x100))
+
+
+
+//int dprint_enable = 0; //Default disable debug print.
+//int ref_use_pad = 0; //Default using internal PLL
+int refclk_mode = 0; //Default '0' is 156.25Mhz + 15.5ppm, '1' is 156.25MHz
+//int pass_flag = 0; //Default is set to FAIL. '1' is success.
+int bert_enable = 0; //Default disable BERT output.
+//int pma_type = 11; //Default 11 10GBASE-KR PMA or PMD type.
+//int pon_eth_sel = 0; //Default '0' for PON and '1' is Ethernet.
+//int auto_10g_enable = 0; //Default '0' disable, '1' enable.
+int pon_mode = 0; //Default '0' for XGSPON and NGPON. 1 = 10G EPON. 2 = Turbo EPON/GPON/NGPON2 asym. 3 = EPON 
+unsigned int pll3_int_configured = 0;
+unsigned int pll3_frac_configured = 0;
+unsigned int loop_pll_int_configured = 0;
+unsigned int loop_pll_frac_configured = 0;
+unsigned int fmx_step = 1; //0 - A-step, 1 - B-step (Default)
+//int autoneg_2p5g = 0; //Default '0' disable (2500BASE-X), '1' (2.5G SGMII ANEG mode) enable. To enable/disable 2.5G SGMII autoneg
+//int autoneg_1g = 0; //Default '0' disable (1000BASE-X), '1' (1G SGMII ANEG mode) enable. To enable/disable 1G SGMII autoneg
+int xpcs_initialized[XPCS_PORT_MAX] = {0};
+u32 srio_data = 0; //Initialized srio_data for link partner reset.
+u32 cl73_break_link_timer	= 0x14DC;		//0x11E1 = 60ms// 0x14DC; //Setting CL73 Break Link Timer to ~70ms = 0x14DC  (BIT[27:16] = 0x14DC)
+u32 cl73_autoneg_link_timer = 0x9502;	//500ms = 0x9502 Setting CL Link Timer to 500ms for CL72 //0xBEB; 	//Setting CL73 Autoneg Link Timer to ~40ms = 0xBEB  (BIT[27:16] = 0x95)	 
+
+#endif
+
+#define VR_RESET BIT(15) /*VR_RESET BIT */
+#define VR_RESET_CNT 		5000
+#define PCIE_PHY_POLL_CNT	5000
+#define RST_STAT_CHK_CNT 	5000
+#define SRAM_INIT_CHK_TIMEOUT	5000
+#define CHECK_TIMEOUT		5000
+#define CR_PORT_BUSY_TIMEOUT	5000
+#define CR_PORT_BUSY_TIMEOUT	5000
+#define CL72_CHECK_LOOP		1
+#define HSIO_R			0
+#define HSIO_L			1
+#define NULL_ARG		0xFF
+
+#define MAX_BUSY_RETRY		2000
+#define XPCS_MODE_USXGMII 0
+#define MPLLB 0
+#define PCS_TYPE_10G_BASE_R 0
+
+#define XPCS_MODE_2500BASEX 1
+#define PCS_TYPE_10G_BASE_X 1
+#define PMA_TYPE_1G_BASE_KX 13
+
+
+#define GET_N_BITS(reg, pos, n) \
+	(((reg) >> (pos)) & ((0x1 << (n)) - 1))
+
+struct xpcs_serdes_cfg {
+	/*
+	 * RX Analog Front End (AFE)
+	 */
+	/* Attenuator */
+	u32 rx_attn_lvl;	/* Attenuation */
+	/* Continuous Time-Linear Equalizer */
+	u32 rx_ctle_boost;	/* Boost level */
+	u32 rx_ctle_pole;	/* Boost pole frequency */
+	/* Voltage Gain Amplifiers */
+	u32 rx_vga1_gain;
+	u32 rx_vga2_gain;
+
+	/*
+	 * RX Decision Feedback Equalizer (DFE)
+	 */
+	u32 rx_dfe_bypass;	/* Bypass (disable) DFE */
+	u32 cont_adapt;		/* Continuous adaptation enable */
+
+	/*
+	 * Calibrate RX AFE and DFE
+	 * Startup calibration is followed by startup adaptation
+	 */
+	u32 rx_cali;		/* Enable RX startup calibration */
+
+	/*
+	 * TX Amplitude Control
+	 * Vswing is peak-to-peak output swing of the TX,
+	 * and nominally equal to the power supply (vptx).
+	 * However, the TX supports the boost function, which is enabled
+	 * by setting tx_vboost_en.
+	 * Formula:
+	 *  Vswing (Vppd) = vptx + 1/16 * (1 + tx_iboost_lvl[3:0])
+	 *                         * max(4*tx_vboost_vref - vptx, 0)
+	 *  12G PHY:
+	 *   tx_vboost_vref = vbg * (10 + 4*tx_vboost_lvl[2:0]) / 127
+	 *   vbg = 1.23V
+	 *   vptx = Analog Transmitter Termination Voltage Supply, usually 0.90V
+	 *  16G PHY:
+	 *   tx_vboost_vref = vbg * (tx_vboost_lvl[2:0] + 6) / 32
+	 *   vbg = 0.8V
+	 *   vptx = Analog Transmitter Termination Voltage Supply, 0.8V or 0.85V
+	 */
+	u32 tx_vboost_en;	/* Enable TX voltage boost */
+	u32 tx_vboost_lvl;	/* TX voltage boost maximum level,
+				 * default value 5 */
+	u32 tx_iboost_lvl;	/* Transmitter current boost level */
+
+	/*
+	 * TX Equalization
+	 * TX driver is implemented with a 3-tap feed-forward equalization.
+	 *  C0  - main tap coefficient
+	 *  C-1 - pre-cursor tap coefficient, negative value
+	 *  C1  - post-cursor tap coefficient, negative value
+	 *  C0    = tx_eq_main[5:0]
+	 *  |C-1| = tx_eq_pre[5:0]/4
+	 *  |C1|  = tx_eq_post[5:0]/4
+	 *                                                 ___        ___
+	 *                   __________                   /   \      /
+	 *     _________    /          \           __    /     \    /
+	 *  __/         \  /            \_________/  \  /       \  /
+	 *  Pre-Amplitude\/Post-Amplitude DC-Swing    \/Max-Swing\/
+	 *  __           /\              _________    /\         /\
+	 *    \_________/  \            /         \__/  \       /  \
+	 *                  \__________/                 \     /    \
+	 *                                                \___/      \___
+	 *
+	 *  pre-amplitude  = Vswing * (C0 + |C-1| - |C1|)/40
+	 *  post-amplitude = Vswing * (C0 - |C-1| + |C1|)/40
+	 *  dc-swing       = Vswing * (C0 - |C-1| - |C1|)/40
+	 *  max-swing      = Vswing * (C0 + |C-1| + |C1|)/40
+	 */
+	u32 tx_eq_main;
+	u32 tx_eq_pre;
+	u32 tx_eq_post;
+
+	u32 tx_eq_ovrride;
+};
+
+struct xpcs_mode_cfg {
+	u32 id;
+	u32 pma_type;
+	u32 pcs_type;
+	u32 lane;
+	u32 ref_clk_ctrl;
+	u32 mplla_mult;
+	u32 mplla_bw;
+	u32 mplla_div165_clk_en;
+	u32 mplla_div10_clk_en;
+	u32 mplla_div8_clk_en;
+	u32 mpllb_mult;
+	u32 mpllb_bw;
+	u32 mpllb_div10_clk_en;
+	u32 mpllb_div8_clk_en;
+	u32 mpllb_div_clk_en;
+	u32 mpllb_div_mult;
+	u32 mpllb_tx_clk_div;
+
+	/* Lane Configure */
+	u32 vco_ld_val;
+	u32 vco_ref_ld;
+	u32 vco_temp_comp_en;
+	u32 vco_step_ctrl;
+	u32 vco_frqband;
+	u32 adpt_sel;
+	u32 adpt_mode;
+	u32 tx_rate;
+	u32 rx_rate;	/* Boost bandwidth */
+	u32 tx_width;
+	u32 rx_width;
+	u32 rx_misc;
+	u32 rx_delta_iq;
+
+	u32 los_thr;
+	u32 cdr_ppm_max;
+	u32 rx_dfe_tap1;
+	u32 rx_margin_iq;
+
+	const struct xpcs_serdes_cfg *lane_cfg;
+
+	u32 rx_vref_ctrl;
+
+	void (*set_mode)(int);
+};
+
+#ifdef CONFIG_LGMC_SGMII
+u32 HSIO_TOP_BASE = 0;
+u32 HSIO_RCU_RST_REQ = 0;
+u32 PAIR_CM1PHY0_CR = 0;
+u32 PAIR_CM1PHY0_APP = 0;
+u32 PAIR_CM1PHY1_CR = 0;
+u32 PAIR_CM1PHY1_APP = 0;
+u32 PAIR_CM2PHY0_CR = 0;
+u32 PAIR_CM2PHY0_APP = 0;
+u32 PAIR_CM2PHY1_CR = 0;
+u32 PAIR_CM2PHY1_APP = 0;
+
+u32 HSIO_XPCS1 = 0;
+#endif
+
+#if defined(CONFIG_LAN_HSIO_R_SGMII_2500BASEX) || defined(CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET)
+
+#define PCS_DBG_CTRL		0xE0014
+u32 lane = 1;
+u32 ref_clk_ctrl = 0x0F1; /* REF_RPT_CLK_EN was enabled in FMX */
+int xpcs_set_mode_2500basex(int port);
+
+static const struct xpcs_serdes_cfg gsw140_xpcs_serdes_cfg = {
+	/* XPCS_MODE_2500BASEX */
+	.rx_attn_lvl = 0,
+
+	.rx_ctle_boost = 18,
+	.rx_ctle_pole = 0,
+	.rx_vga1_gain = 4,
+	.rx_vga2_gain = 4,
+
+	.rx_dfe_bypass = 1,
+	.cont_adapt = 0,
+
+	.rx_cali = 1,
+
+	.tx_vboost_en = 1,
+	.tx_vboost_lvl = 5,
+	.tx_iboost_lvl = 15,
+	.tx_eq_main = 19,
+	.tx_eq_pre = 4,
+	.tx_eq_post = 4,
+	.tx_eq_ovrride = 1,
+};
+
+static const struct xpcs_mode_cfg gsw140_xpcs_mode_cfg = {
+	.id = XPCS_MODE_2500BASEX,
+	.pma_type = PMA_TYPE_1G_BASE_KX,
+	.pcs_type = PCS_TYPE_10G_BASE_X,
+	.lane = 1,
+	.ref_clk_ctrl = 0,
+
+	.mplla_mult = 0x28,
+	.mplla_bw = 0xA017,
+	.mplla_div165_clk_en = 0,
+	.mplla_div10_clk_en = 1,
+	.mplla_div8_clk_en = 0,
+
+	/* can not select MPLL B */
+	.mpllb_mult = 0x28,
+	.mpllb_bw = 0xA017,
+	.mpllb_div10_clk_en = 1,
+	.mpllb_div8_clk_en = 0,
+	.mpllb_div_clk_en = 0,
+	.mpllb_div_mult = 0,
+	.mpllb_tx_clk_div = 0,
+
+	.vco_ld_val = 0x550,
+	.vco_ref_ld = 0x22,
+	.vco_temp_comp_en = 0,
+	.vco_step_ctrl = 1,
+	.vco_frqband = 2,
+	.adpt_sel = 0,
+	.adpt_mode = 0,
+	.tx_rate = 2, /* 3'b010 : baud/4 */
+	.rx_rate = 2, /* 2'b10 : baud/4 */
+	.tx_width = 1, /* 2'b01: 10-bit, 2'b11: 20-bit */
+	.rx_width = 1, /* 2'b01: 10-bit, 2'b11: 20-bit */
+	.rx_misc = 23,
+	.rx_delta_iq = 0,
+
+	.los_thr = 4,
+	.cdr_ppm_max = 18,
+	.rx_dfe_tap1 = 0,
+	.rx_margin_iq = 0,
+	.rx_vref_ctrl = 17,
+
+	.lane_cfg = &gsw140_xpcs_serdes_cfg,
+	.set_mode = (void *)xpcs_set_mode_2500basex,
+};
+#endif
+
+#ifdef CONFIG_LGM_P34X_SUPPORT
+extern void p34x_hrst(void);
+extern int internal_fw_load(void);
+extern int external_fw_load(void);
+extern u32 show_phy_id(void);
+#endif
+struct combo_port g_combo_port_defs[COMBO_PORT_MAX];
+int dprint_enable = 0; /*Default disable debug print. */
+int ref_use_pad = 0; /*Default using internal PLL */
+int pass_flag = 0; /*Default is set to FAIL. '1' is success. */
+int pma_type = 11; /*Default 11 10GBASE-KR PMA or PMD type. */
+int pon_eth_sel = 1; /*Default '1' for Ethernet and '0' is PON. */
+int auto_10g_enable = 0; /*Default '0' disable, '1' enable. */
+int autoneg_2p5g = 0; /*Default '0' disable (2500BASE-X), '1' (2.5G SGMII ANEG mode) enable. To enable/disable 2.5G SGMII autoneg */
+int autoneg_1g = 0; /*Default '0' disable (1000BASE-X), '1' (1G SGMII ANEG mode) enable. To enable/disable 1G SGMII autoneg */
+u32 read_data = 0;
+
+void check_rxtx_stable(int port);
+void set_mode_usxgmii(int xpcs_prt);
+void xpcs_disable_an(int xpcs_prt);
+
+#if defined(CONFIG_LAN_HSIO_R_USXGMII_10G ) || defined(CONFIG_WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G) || defined(CONFIG_XPCS5_USXGMII_RTL8261)
+#if defined(CONFIG_LAN_HSIO_R_USXGMII_10G )
+static void disable_xpcs_clk(u32 base);
+#endif
+static void xpcs_cfg_clk(int xpcs_prt);
+static void xpcs_cfg_table(int xpcs_prt);
+static int xpcs_vs_reset(u32 xpcs_prt);
+static void tx_eq_config_kernel(u32 xpcs_prt);
+static void xpcs_an(u32 xpcs_prt);
+
+u32 XPCS_RGRD(u32 xpcs_prt, u32 reg);
+void XPCS_RGWR(u32 xpcs_prt, u32 reg, u32 reg_val);
+void XPCS_RGWR_VAL_OFF(u32 xpcs_prt, u32 reg, u32 bits_mask, u32 bits_pos, u32 bits_val, u32 regs_shift);
+void XPCS_RGWR_VAL_SHIFT(u32 xpcs_prt, u32 reg, u32 bits_mask, u32 bits_pos, u32 bits_val, u32 bits_shift);
+void XPCS_RGWR_VAL_OFF_SHIFT(u32 xpcs_prt, u32 reg, u32 bits_mask, u32 bits_pos, u32 bits_val, u32 regs_shift, u32 bits_shift);
+
+static const struct xpcs_serdes_cfg lane_cfg_tbl[1] = {
+	{
+		/* XPCS_MODE_USXGMII */
+		.rx_attn_lvl = 7,
+		/* RX_EQ_CTRL0 = 0x0000 */
+		.rx_ctle_boost = 0xa,
+		.rx_ctle_pole = 2,
+		.rx_vga1_gain = 5,
+		.rx_vga2_gain = 5,
+		.rx_dfe_bypass = 0,
+		.cont_adapt = 1,
+		.rx_cali = 0,
+		.tx_vboost_en = 1,
+		.tx_vboost_lvl = 5,
+		.tx_iboost_lvl = 15,
+		.tx_eq_main = 40,
+		.tx_eq_pre = 0,
+		.tx_eq_post = 0,
+		.tx_eq_ovrride = 1,
+	}
+	};
+
+static const struct xpcs_mode_cfg mode_cfg_tbl[1] = {
+	{
+		.id = XPCS_MODE_USXGMII,
+		.pma_type = PMA_TYPE_10G_BASE_KR,
+		.pcs_type = PCS_TYPE_10G_BASE_R,
+		.lane = 1,
+
+		.ref_clk_ctrl = 0x031,
+
+		.mplla_mult = 0x21,
+		.mplla_bw = 0xA03E,
+		.mplla_div165_clk_en = 1,
+		.mplla_div10_clk_en = 0,
+		.mplla_div8_clk_en = 1,
+
+		/* can not select MPLL B */
+		.mpllb_mult = 0,
+		.mpllb_bw = 0,
+		.mpllb_div10_clk_en = 0,
+		.mpllb_div8_clk_en = 0,
+		.mpllb_div_clk_en = 0,
+		.mpllb_div_mult = 0,
+
+		.vco_ld_val = 0x549,
+		.vco_ref_ld = 0x29,
+		.vco_temp_comp_en = 1,
+		.vco_step_ctrl = 1,
+		.vco_frqband = 1,
+		.adpt_sel = 0,
+		.adpt_mode = 3,
+		.tx_rate = 0,
+		.rx_rate = 0,
+		.tx_width = 2,	/* 2'b10 - 16 bit */
+		.rx_width = 2,	/* 2'b10 - 16 bit */
+		.rx_misc = 2,
+		.rx_delta_iq = 3,
+		.los_thr = 7,
+		.cdr_ppm_max = 18,
+		.rx_dfe_tap1 = 0,
+		.rx_margin_iq = 0,
+		.lane_cfg = &lane_cfg_tbl[XPCS_MODE_USXGMII],
+		.rx_vref_ctrl = 17,
+		.set_mode = set_mode_usxgmii,
+	}
+	};
+#endif
+
+struct usxspd g_usxspeed_defs[1] = {
+	{
+		.usx_p0_spd = 4, /*Default 2.5G*/
+		.usx_p1_spd = 4, /*Default 2.5G*/
+		.usx_p2_spd = 4, /*Default 2.5G*/
+		.usx_p3_spd = 4, /*Default 2.5G*/
+	}
+};
+
+struct tx_eq tx_presets[TX_EQ_MAX] = {
+	{
+		/* [PCIe TX Presets 0] De-emphasis = -6.02dB; Pre-shoot = 0.00dB; Boost = 6.02dB */
+		.id = TX_PRST_0,
+		.tx_main_cursor = 30,
+		.tx_pre_cursor	= 0,
+		.tx_post_cursor	= 40,
+		.tx_iboost_lvl 	=  15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl  = 5,
+	}, {
+		/* [PCIe TX Presets 1] De-emphasis = -3.74dB; Pre-shoot = 0.00dB; Boost = 3.74dB */
+		.id = TX_PRST_1,
+		.tx_main_cursor = 33,
+		.tx_pre_cursor	= 0,
+		.tx_post_cursor	= 28,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 2] De-emphasis = -4.44dB; Pre-shoot = 0.00dB; Boost = 4.44dB */
+		.id = TX_PRST_2,
+		.tx_main_cursor = 32,
+		.tx_pre_cursor	= 0,
+		.tx_post_cursor	= 32,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 3] De-emphasis = -2.50dB; Pre-shoot = 0.00dB; Boost = 2.50dB */
+		.id = TX_PRST_3,
+		.tx_main_cursor = 35,
+		.tx_pre_cursor	= 0,
+		.tx_post_cursor	= 20,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 4] De-emphasis = 0.00dB; Pre-shoot = 0.00dB; Boost = 0.00dB */
+		.id = TX_PRST_4,
+		.tx_main_cursor = 40,
+		.tx_pre_cursor	= 0,
+		.tx_post_cursor	= 0,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 5] De-emphasis = 0.00dB; Pre-shoot = 1.94dB; Boost = 1.94dB */
+		.id = TX_PRST_5,
+		.tx_main_cursor = 36,
+		.tx_pre_cursor	= 16,
+		.tx_post_cursor	= 0,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 6] De-emphasis = 0.00dB; Pre-shoot = 2.50dB; Boost = 2.50dB */
+		.id = TX_PRST_6,
+		.tx_main_cursor = 35,
+		.tx_pre_cursor	= 20,
+		.tx_post_cursor	= 0,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 7] De-emphasis = -6.02dB; Pre-shoot = 3.52dB; Boost = 7.96dB */
+		.id = TX_PRST_7,
+		.tx_main_cursor = 28,
+		.tx_pre_cursor	= 16,
+		.tx_post_cursor	= 32,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 8] De-emphasis = -3.52dB; Pre-shoot = 3.52dB; Boost = 6.02dB */
+		.id = TX_PRST_8,
+		.tx_main_cursor = 30,
+		.tx_pre_cursor	= 20,
+		.tx_post_cursor	= 20,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 9] De-emphasis = 0dB; Pre-shoot = 3.74dB; Boost = 3.74dB */
+		.id = TX_PRST_9,
+		.tx_main_cursor = 33,
+		.tx_pre_cursor	= 28,
+		.tx_post_cursor	= 0,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [PCIe TX Presets 10] De-emphasis = -9.12dB; Pre-shoot = 0.00dB; Boost = 9.12dB */
+		.id = TX_PRST_10,
+		.tx_main_cursor = 27,
+		.tx_pre_cursor	= 0,
+		.tx_post_cursor	= 52,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [2.5G Customized] De-emphasis = -0.97dB; Pre-shoot = 0.97dB; Boost = 1.84dB */
+		.id = TX_2P5G_CUSTOM,
+		.tx_main_cursor = 19,
+		.tx_pre_cursor	= 4,
+		.tx_post_cursor	= 4,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [1G Customized] De-emphasis = -1.16dB; Pre-shoot = 1.16dB; Boost = 2.18dB */
+		.id  = TX_1G_CUSTOM,
+		.tx_main_cursor = 16,
+		.tx_pre_cursor	= 4,
+		.tx_post_cursor	= 4,
+		.tx_iboost_lvl 	= 15,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	}, {
+		/* [10G Short] De-emphasis = 0dB; Pre-shoot = 0dB; Boost = 0dB; TxMargin = 3, TX max swing 0.5V */
+		.id = TX_10G_SHORT,
+		.tx_main_cursor = 20,
+		.tx_pre_cursor	= 0,
+		.tx_post_cursor	= 0,
+		.tx_iboost_lvl 	= 5,
+		.tx_vboost_en	= 1,
+		.tx_vboost_lvl	= 5,
+	},
+};
+
+struct rx_eq rx_presets[RX_EQ_MAX] = {
+	{
+		/*16G PCIe GEN4 RX Default Setting */
+		.id = RX_16G,
+		.rx_att_lvl = 0,
+		.rx_vga1_gain = 5,
+		.rx_vga2_gain = 5,
+		.rx_ctle_pole = 2,
+		.rx_ctle_boost = 16,
+		.rx_dfe_tap1 = 10,
+		.rx_dfe_bypass = 0,
+		.rx_adapt_mode = 0,
+		.rx_adapt_sel = 0,
+		.rx_vco_temp_comp_en = 0,
+		.rx_vco_step_ctrl = 0,
+		.rx_vco_frqband	= 2,
+		.rx_misc = 17,
+		.rx_delta_iq = 3,
+		.rx_margin_iq = 0,
+		.rx_los_threshold = 4,
+	}, {
+		/*10G 10GBASE-KR */
+		.id = RX_10G,
+		.rx_att_lvl = 0,
+		.rx_vga1_gain = 5,
+		.rx_vga2_gain = 5,
+		.rx_ctle_pole = 2,
+		.rx_ctle_boost = 16,
+		.rx_dfe_tap1 = 0,
+		.rx_dfe_bypass = 0,
+		.rx_adapt_mode = 3,
+		.rx_adapt_sel = 0,
+		.rx_vco_temp_comp_en = 1,
+		.rx_vco_step_ctrl = 1,
+		.rx_vco_frqband	= 1,
+		.rx_misc = 18,
+		.rx_delta_iq = 0,
+		.rx_margin_iq = 0,
+		.rx_los_threshold = 7,
+	},{
+		/*2x 6.25G RXAUI */
+		.id = RX_6P25G,
+		.rx_att_lvl = 0,
+		.rx_vga1_gain = 4,
+		.rx_vga2_gain = 4,
+		.rx_ctle_pole = 0,
+		.rx_ctle_boost = 14,
+		.rx_dfe_tap1 = 0,
+		.rx_dfe_bypass = 0,
+		.rx_adapt_mode = 3,
+		.rx_adapt_sel = 0,
+		.rx_vco_temp_comp_en = 0,
+		.rx_vco_step_ctrl = 1,
+		.rx_vco_frqband	= 2,
+		.rx_misc = 21,
+		.rx_delta_iq = 0,
+		.rx_margin_iq = 0,
+		.rx_los_threshold = 4,
+	}, {
+		/*5G 5GBASE-KR */
+		.id = RX_5G,
+		.rx_att_lvl = 0,
+		.rx_vga1_gain = 4,
+		.rx_vga2_gain = 4,
+		.rx_ctle_pole = 0,
+		.rx_ctle_boost = 14,
+		.rx_dfe_tap1 = 0,
+		.rx_dfe_bypass = 0,
+		.rx_adapt_mode = 3,
+		.rx_adapt_sel = 0,
+		.rx_vco_temp_comp_en = 0,
+		.rx_vco_step_ctrl = 1,
+		.rx_vco_frqband	= 2,
+		.rx_misc = 21,
+		.rx_delta_iq = 0,
+		.rx_margin_iq = 0,
+		.rx_los_threshold = 4,
+	},{
+		/*2.5G 2.5G SGMII */
+		.id = RX_2P5G,
+		.rx_att_lvl = 0,
+		.rx_vga1_gain = 4,
+		.rx_vga2_gain = 4,
+		.rx_ctle_pole = 0,
+		.rx_ctle_boost = 18,
+		.rx_dfe_tap1 = 0,
+		.rx_dfe_bypass = 1,
+		.rx_adapt_mode = 0,
+		.rx_adapt_sel = 0,
+		.rx_vco_temp_comp_en = 0,
+		.rx_vco_step_ctrl = 1,
+		.rx_vco_frqband	= 2,
+		.rx_misc = 23,
+		.rx_delta_iq = 0,
+		.rx_margin_iq = 0,
+		.rx_los_threshold = 4,
+	}, {
+		/*1G 1G SGMII */
+		.id = RX_1G,
+		.rx_att_lvl = 0,
+		.rx_vga1_gain = 4,
+		.rx_vga2_gain = 4,
+		.rx_ctle_pole = 0,
+		.rx_ctle_boost = 18,
+		.rx_dfe_tap1 = 0,
+		.rx_dfe_bypass = 1,
+		.rx_adapt_mode = 0,
+		.rx_adapt_sel = 0,
+		.rx_vco_temp_comp_en = 1,
+		.rx_vco_step_ctrl = 1,
+		.rx_vco_frqband	= 1,
+		.rx_misc = 22,
+		.rx_delta_iq = 0,
+		.rx_margin_iq = 0,
+		.rx_los_threshold = 4,
+	}, {
+		/*10G USXGMII Short */
+		.id = RX_10G_SHORT,
+		.rx_att_lvl = 7,
+		.rx_vga1_gain = 5,
+		.rx_vga2_gain = 5,
+		.rx_ctle_pole = 2,
+		.rx_ctle_boost = 0,
+		.rx_dfe_tap1 = 0,
+		.rx_dfe_bypass = 1,
+		.rx_adapt_mode = 0,
+		.rx_adapt_sel = 0,
+		.rx_vco_temp_comp_en = 1,
+		.rx_vco_step_ctrl = 1,
+		.rx_vco_frqband	= 1,
+		.rx_misc = 18,
+		.rx_delta_iq = 0,
+		.rx_margin_iq = 0,
+		.rx_los_threshold = 7,
+	},
+};
+
+#ifdef CONFIG_LGMC_SGMII
+void reg_field_clearNset(u32 addr, u32 pos, u32 width, u32 field_val)
+{
+	u32 val;
+	val = REG32(addr);
+	val &= ~(((1 << width) - 1) << pos);
+	val |= (field_val & ((1 << width) - 1)) << pos;
+	REG32(addr) = val;
+}
+
+u32 val_clearNset(u32 val, u32 pos, u32 width, u32 field_val)
+{
+	val &= ~(((1 << width) - 1) << pos);
+	val |= (field_val & ((1 << width) - 1)) << pos;
+	return val;
+}
+
+void config_c10_phy_SGMII2G5_through_xpcs(void)
+{
+/*MPLLB_MULTIPLIER 	Set the values of this field in the register VR_XS_PMA_MP_12G_16G_MPLLB_CTRL0 Register: 
+to 8d_120 
+bit7:0	MPLLB_MULTIPLIER
+MPLLB frequency Multiplier Control
+This field controls the multiplication of reference clock to a frequency suitable for operating speed.
+Any change in this field should be followed by a Vendor-specific Soft Reset to ensure that PHY is properly powered-up in the desired mode.
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,val_clearNset(read_data, 0, 8, 120),HSIO_XPCS1);
+
+/*MPPLB_BANDWIDTH	Set the values of this field in the register VR_XS_PMA_MP_16G_MPLLB_CTRL3 Register: to 16d_77
+bit15:0	MPLLB_BANDWIDTH
+MPLLB Bandwidth Control
+This field controls the bandwidth of MPLLB present in Enterprise Gen5 16G PHY. This field drives the output port 'xpcs_mpllb_bandwidth_o'.
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLB_CTRL3,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLB_CTRL3,val_clearNset(read_data, 0, 16, 77),HSIO_XPCS1);
+
+/*VCO_LD_VAL_0	Set the value of these fields for all the lanes in
+VR_XS_PMA_MP_12G_16G_25G_VCO_CAL_LD {lane} Register to 13d_1360
+bit12:0	VCO_LD_VAL_0
+Rx VCO calibration load value on lane 0 of the PHY
+This field is used to load internal calibration registers in the PHY to perform Rx VCO calibration on lane 0.
+This field drives the output port 'xpcs_rx0_vco_ld_val_o[5:0]'.
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,val_clearNset(read_data, 0, 13, 1360),HSIO_XPCS1);
+/*
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD1,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD1,val_clearNset(read_data, 0, 13, 1360),HSIO_XPCS1);
+
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD2,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD2,val_clearNset(read_data, 0, 13, 1360),HSIO_XPCS1);
+
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD3,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD3,val_clearNset(read_data, 0, 13, 1360),HSIO_XPCS1);
+*/
+/*
+VCO_REF_LD_0	Set the value of these fields for all the lanes in VR_XS_PMA_MP_16G_25G_VCO_CAL_REF0, VR_XS_PMA_MP_16G_25G_VCO_CAL_REF1
+ Registers as follows:
+6d_34 for 156.25 MHz Reference Clock(original 6d_37)
+bit 6:0	VCO_REF_LD_0
+Rx VCO calibration reference load value -lane 0
+This field controls the PHY's internal calibration registers used to perform Rx VCO calibration on lane 0.
+This field drives the output port 'xpcs_rx0_ref_ld_val_o[6:0]'.
+
+.h
+#define VR_XS_PMA_GEN5_16G_VCO_CAL_REF0                0x060258
+#define VR_XS_PMA_GEN5_16G_VCO_CAL_REF1                0x06025C
+
+xpcs datasheet
+VR_XS_PMA_Gen5_12G_VCO_CAL_REF0
+VR_XS_PMA_Gen5_12G_VCO_CAL_REF1
+VR_XS_PMA_Gen5_16G_VCO_CAL_REF0
+VR_XS_PMA_Gen5_16G_VCO_CAL_REF1
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,val_clearNset(read_data, 0, 7, 34),HSIO_XPCS1);
+
+/*CONT_ADAPT_0,	Set the value of these fields in VR_XS_PMA_MP_12G_16G_25G_RX_EQ_CTRL4 Reg to 0
+bit0:	CONT_ADAPT_0
+Receiver Adaptation Continuous Operation on lane 0
+This bit can be set to enable continuous receiver adaptation in the PHY.
+This bit drives the output port 'xpcs_rx_offcan_cont_o'.
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,val_clearNset(read_data, 0, 1, 0),HSIO_XPCS1);
+
+/*Set the value of these fields for all the lanes to 3'b000 in
+VR_XS_PMA_MP_12G_16G_25G_TX_RATE_CTRL Register (txX_rate[2:0] =0 : from snpy config )
+tx0_rate[2:0] =0
+tx1_rate[6:4] =0
+tx2_rate[10:8] =0
+tx3_rate[14:12] =0
+
+3'b000 : baud
+3'b001 : baud/2
+3'b010 : baud/4
+3'b011 : baud/8
+3'b111 : baud/10
+3'b100-3'b110 : Not supported
+
+issue:tx using baud, while rx using baud/2
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 0, 3, 0);
+/*	read_data = val_clearNset(read_data, 4, 3, 0);
+	read_data = val_clearNset(read_data, 8, 3, 0);
+	read_data = val_clearNset(read_data, 12, 3, 0);
+*/
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,read_data,HSIO_XPCS1);
+
+/*Set the value of these fields for all the lanes to 2'b01 in
+VR_XS_PMA_MP_12G_16G_25G_RX_RATE_CTRL Register (rxX_rate[1:0]=1 :  from snpy config)
+rx0_rate[1:0]=1
+rx1_rate[5:4]=1
+rx2_rate[9:8]=1
+rx3_rate[13:12]=1
+
+2'b00 : baud
+2'b01 : baud/2
+2'b10 : baud/4
+2'b11 : baud/8
+
+issue:tx using baud, while rx using baud/2
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 0, 2, 1);
+/*
+	read_data = val_clearNset(read_data, 4, 2, 1);
+	read_data = val_clearNset(read_data, 8, 2, 1);
+	read_data = val_clearNset(read_data, 12, 2, 1);
+*/
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,read_data,HSIO_XPCS1);
+
+/*Set the value of these fields for all the lanes to 2'b01 in
+VR_XS_PMA_MP_12G_16G_TX_GENCTRL2 Register (tx0_width[9:8]=1 :  from snpy config)
+tx0_width[9:8]=1
+tx1_width[11:10]=1
+tx2_width[13:12]=1
+tx3_width[15:14]=1
+
+2'b00 : 8-bit
+2'b01: 10-bit
+2'b10: 16-bit
+2'b11: 20-bit
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 2, 1);
+/*
+	read_data = val_clearNset(read_data, 10, 2, 1);
+	read_data = val_clearNset(read_data, 12, 2, 1);
+	read_data = val_clearNset(read_data, 14, 2, 1);
+*/
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,read_data,HSIO_XPCS1);
+
+/*Set the value of these fields for all the lanes to 2'b01 in
+VR_XS_PMA_MP_12G_16G_RX_GENCTRL2 Register (rx0_width[9:8]=1:  from snpy config)
+rx0_width[9:8]=1
+rx1_width[11:10]=1
+rx2_width[13:12]=1
+rx3_width[15:14]=1
+
+2'b00 : 8-bit
+2'b01: 10-bit
+2'b10: 16-bit
+2'b11: 20-bit
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 2, 1);
+/*
+	read_data = val_clearNset(read_data, 10, 2, 1);
+	read_data = val_clearNset(read_data, 12, 2, 1);
+	read_data = val_clearNset(read_data, 14, 2, 1);
+*/
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,read_data,HSIO_XPCS1);
+
+/*
+MPLLB_DIV16P5_CLK_EN (not available In C10 no effect,can be removed)
+Set the value of this field in VR_XS_PMA_MP_12G_16G_MPLLB_CTRL2 Register to 0
+*/
+
+/*MPLLB_DIV10_CLK_EN 	Set the value of this field in VR_XS_PMA_MP_12G_16G_MPLLB_CTRL2 Register to 1
+MPLLB_DIV8_CLK_EN 	Set the value of this field in VR_XS_PMA_MP_12G_16G_MPLLB_CTRL2 Register to 0
+
+bit9: MPLLB_DIV10_CLK_EN
+bit8: MPLLB_DIV8_CLK_EN
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 9, 1, 1);
+	read_data = val_clearNset(read_data, 8, 1, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,read_data,HSIO_XPCS1);
+
+/*MPLLB_TX_CLK_DIV
+(PCIE3_App)	Set the value of this field to d 6 (or)  mpllb_tx_clk_div2--0 =6  from snpy config xls
+Use the PCIE_EXT_MPLLA_FRACN_CTRL [2:0] App register to d6
+
+PCIEG4_PHY_EXT_MPLLA_CTRL_4	offset=0x68
+bit16:18 phy0_mpllb_tx_clk_div
+PAIR_CM2PHY0_APP
+
+*/
+	REG32(PAIR_CM2PHY0_APP + 0x68) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x68), 16, 3, 6);
+
+/*MPLLB_DIV_CLK_EN	Set the value of this field in VR_XS_PMA_MP_12G_16G_MPLLB_CTRL2 Register to d 0
+bit 7:	MPLLB_DIV_CLK_EN
+Enable mpllb_div_clk from PHY
+When asserted, the frequency of mpllb_div_clk output from PHY is MPLLB frequency divided by 'mpllb_div_multiplier'
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 7, 1, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,read_data,HSIO_XPCS1);
+
+/*
+MPLLB_DIV_MULT	Set the value of this field in VR_XS_PMA_MP_12G_16G_MPLLB_CTRL2 Register to d 0 not used .
+Use the PCIE_EXT_MPLLA_BANDWIDTH 10--3  App register to d 0 (need to set in PCIE_EXT_MPLLA_BANDWIDTH = VR_XS_PMA_GEN5_16G_MPLLA_CTRL3)
+
+PCIE_PHY_EXT_MPLLA_CTRL_4	offset=0x68
+bit15:0	PCIE_EXT_MPLLA_BANDWIDTH
+MPLLA Bandwidth Control
+*/
+	REG32(PAIR_CM2PHY0_APP + 0x68) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x68), 3, 8, 0);
+
+/* we can do nothing here, because target value = defualt value.
+MPLLB_SSC_EN	Set the value of this field in VR_MII_MP_16G_MPLLB_CTRL1 register to d 0
+MPLLB_SSC_RANGE (PCIE3_App) Set the value of this field in PCIE_EXT_MPLLB_SSC_RANGE register to d0
+MPLLB_FRACN_CTRL	Set the value of this field in VR_MII_MP_16G_MPLLB_CTRL1 register to d 0
+
+bit0 MPLLB_SSC_EN:
+MPLLB Spread Spectrum Enable
+This field can be set to enable spread-spectrum generation onmplla_div_clk output.This bit drives the output portxpcs_mpllb_ssc_en_o.
+Value After Reset: 0x0
+Exists: Always
+
+bit15:5 MPLLB Fractional Control
+This field drives the output port 'xpcs_mpllb_fracn_ctrl_o'.Value After Reset: 0x0
+Exists: Always
+
+VR_MII_MP_16G_MPLLB_CTRL1 can't be found in html and header file.
+issue.
+
+
+(PCIE3_App)
+PAIR_CM2PHY0_APP = 			HSIO4_CB3PHY0_APP;
+#define HSIO4_CB3PHY0_APP			0xc0c40000
+
+PCIE_PHY_EXT_MPLLB_CTRL_2	offset=0x3C
+bit14:12	PCIE_EXT_MPLLB_SSC_RANGE
+*/
+	REG32(PAIR_CM2PHY0_APP + 0x3C) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x3C), 12, 3, 0);
+
+/*
+REF_RANGE	Set the value of this field in VR_XS_PMA_MP_12G_16G_25G_REF_CLK_CTRL to d 2
+REF_MPLLB_DIV2	Set the value of this field in VR_XS_PMA_MP_12G_16G_25G_REF_CLK_CTRL to 1
+REF_CLK_DIV2	Set the value of this field in VR_XS_PMA_MP_12G_16G_25G_REF_CLK_CTRL to 1
+
+bit5:3	REF_RANGE
+Input Reference Clock Range
+This field specifies the frequency range of the input reference clock (post ref_clk_div2_en division if any).
+The code mapping of REF_RANGE is as follows:
+- 3'b000: 20 - 26 MHz
+- 3'b001: 26.1 - 52 MHz
+- 3'b010: 52.1 - 78 MHz
+- 3'b011: 78.1 - 104 MHz
+- 3'b100: 104.1 - 130 MHz
+- 3'b101: 130.1 - 156 MHz
+- 3'b110: 156.1 - 182 MHz
+- 3'b111: 182.1 - 200 MHz
+This field should be set to appropriate values based on your reference clock frequency.
+
+bit7	REF_MPLLB_DIV2
+bit2	REF_CLK_DIV2
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 3, 3, 2);
+	read_data = val_clearNset(read_data, 7, 1, 1);
+	read_data = val_clearNset(read_data, 2, 1, 1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,read_data,HSIO_XPCS1);
+
+/*RX_VREF_CTRL	Set the value of this filed in VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 to d 17
+bit12:8	RX_VREF_CTRL
+Rx Biasing Current Control
+This field drives the output port 'xpcs_rx_vref_ctrl_o[4:0]'. Thisfield sets the Rx biasing current for Rx analog front end.Value After Reset: 0x11
+Exists: Always
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 5, 17);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,read_data,HSIO_XPCS1);
+
+/*IBOOST_LVL(TX0)	Set the value of this field in VR_XS_PMA_MP_12G_16G_25G_TX_BOOST_CTRL to 4d_15
+bit3:0	TX0_IBOOST
+Tx current boost level on lane 0 of the PHY
+This bit drives the output port xpcs_tx0_iboost_lvl_o[3:0].
+For details on how to set this field, refer PHY databook.
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 0, 4, 15);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,read_data,HSIO_XPCS1);
+
+/*VBOOST_EN_0 	Set the value of this field in VR_XS_PMA_MP_12G_16G_25G_TX_GENCTRL1 register
+to 1 (txX_vboost_en=1, snpy config)
+
+bit4:7	VBOOST_EN_0:3 
+Tx voltage Boost Enable on lane 0 of 12G PHY
+When this bit is set, the current mode Tx Swing boost in the PHY is enabled.
+This bit drives the output port 'xpcs_tx_vboost_en_o[0]'.
+
+care only lane0 bit4
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 4, 1, 1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,HSIO_XPCS1);
+
+/*CTLE_BOOST_0	Set the values of these fields in the following registers to 5d_7.
+VR_XS_PMA_MP_16G_25G_RX_EQ_CTRL0
+bit4:0:		CTLE_BOOST_0
+Rx Equalization CTLE Boost value on lane 0 of the PHY
+This field drives the output port xpcs_rx0_eq_ctle_boost_o[4:0].This field controls the CTLE boost level.
+
+bit6:5		CTLE_POLE_0, set to 0.
+Rx Equalization CTLE Pole Value on lane 0 of the PHY
+This field drives the output port xpcs_rx0_eq_ctle_pole_o[1:0].This field controls the continuous time linear equalizer boost pole location of the PHY.
+
+bit10:8		VGA2_GAIN_0,set to 4.
+Rx Equalization VGA2 Gain on lane 0 of the PHY
+This field drives the output port xpcs_rx0_eq_vga2_gain_o[3:0].This field controls the AFE second stage Variable Gain amplifier gain.
+
+bit14:12	VGA1_GAIN_0,set to 4.
+Rx Equalization VGA1 Gain on lane 0 of the PHY
+This field drives the output port xpcs_rx0_eq_vga1_gain_o[3:0].
+This field controls the AFE first stage Variable Gain amplifier gain.
+
+0x5547 changed to 0x4407
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,HSIO_XPCS1);
+//	read_data = val_clearNset(read_data, 0, 16,0x4407);
+	read_data = val_clearNset(read_data, 0, 5, 7);
+	read_data = val_clearNset(read_data, 5, 2, 0);
+	read_data = val_clearNset(read_data, 8, 3, 4);
+	read_data = val_clearNset(read_data, 12, 3, 4);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,read_data,HSIO_XPCS1);
+
+/*VCO_STEP_CTRL_0,	Set the values of these fields in VR_XS_PMA_MP_16G_RX_CDR_CTRL1 register to 1
+VCO_TEMP_COMP_EN_0	Set the values of these fields in VR_XS_PMA_MP_16G_RX_CDR_CTRL1 register to 1
+bit4:	VCO_STEP_CTRL_0
+RX_CDR VCO Step Control Lane 0
+This field drives the output port xpcs_vco_step_ctrl_o[0].
+
+bit0:	VCO_TEMP_COMP_EN_0
+RX_CDR VCO Temperature Compensation Enable Lane 0
+This field drives the output port xpcs_vco_temp_comp_en_o[0].
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 4, 1, 1);
+	read_data = val_clearNset(read_data, 0, 1, 1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,read_data,HSIO_XPCS1);
+
+/*RX0_MISC	Set the value of this field in VR_XS_PMA_MP_16G_25G_RX_MISC_CTRL0 register to d_7
+bit7:0	RX0_MISC
+RX Miscellaneous control for lane0.
+This field drives the output port xpcs_rx0_misc_o[7:0].
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 0, 8, 7);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,read_data,HSIO_XPCS1);
+
+/*RX_DFE_BYP_0 	Set the value of this field in VR_XS_PMA_MP_16G_25G_RX_GEN_CTRL4 register to 1
+bit8:	RX_DFE_BYP_0
+RX DFE Bypass Enable on Lane o
+This field drives the output port xpcs_rx_dfe_bypass_o[0].
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 1, 1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,read_data,HSIO_XPCS1);
+
+/*VCO_FRQBAND_0	Set the values of these fields in VR_XS_PMA_MP_16G_25G_RX_CDR_CTRL1 register to 1
+bit9:8	VCO_FRQBAND_0
+RX CDR VCO Frequency Band lane0
+This field drives the output port xpcs_vco_freqband0_o[1:0].
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 2, 1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,read_data,HSIO_XPCS1);
+
+/*RX0_DELTA_IQ	Set the value of this field in VR_XS_PMA_MP_16G_25G_RX_IQ_CTRL0 register to 0
+bit11:8	RX0_DELTA_IQ
+RX IQ Offset Value for lane0.
+This field drives the output port xpcs_rx0_delta_iq_o[3:0].
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 4, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,read_data,HSIO_XPCS1);
+
+/*RX0_ADAPT_MODE  	Set the value of this field in VR_XS_PMA_MP_16G_25G_RX_EQ_CTRL5 register to 0
+bit5:4	RX0_ADPT_MODE
+RX Adaptation for lane0
+This field drives the output port xpcs_rx0_adpt_mode_o[1:0].
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 4, 2, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,read_data,HSIO_XPCS1);
+
+/*TX_CLK_RDY_0	Set the value of this filed in VR_XS_PMA_MP_12G_16G_25G_TX_GENCTRL1 register to 0
+bit12:	TX_CLK_RDY_0
+Transmitter Input clock ready on lane 0
+This field drives the output xpcs_tx_clk_rdy_o[0]. This field should remain high, as long as PHY Tx Clock is active
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 12, 1, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,HSIO_XPCS1);
+
+/*
+MPLLB_FORCE_EN_OVRD (PCIE3_App)	Set the value of PCIE_EXT_MPLLA_BANDWIDTH [14] to d_0
+MPLLB_SSC_CLK_SEL(PCIE3_App)		Set the value of PCIE_EXT_MPLLA_BANDWIDTH [13:11] to d_0 
+CDR_VCO_LOWFREQ (PCIE3_App)		Set the value of PCIE_EXT_MPLLA_BANDWIDTH [2] to d_1
+
+PCIE_PHY_EXT_MPLLA_CTRL_4	offset=0x68
+bit15:0	PCIE_EXT_MPLLA_BANDWIDTH
+MPLLA Bandwidth Control
+*/
+	REG32(PAIR_CM2PHY0_APP + 0x68) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x68), 14, 1, 0);
+	REG32(PAIR_CM2PHY0_APP + 0x68) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x68), 11, 3, 0);
+	REG32(PAIR_CM2PHY0_APP + 0x68) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x68), 2, 1, 1);
+
+/*
+VBOOST_LVL	Set the value in VR_XS_PMA_MP_12G_16G_25G_TX_GENCTRL1 to 3d_3
+bit10:8 VBOOST_LVL
+Tx Voltage Boost Maximum Level
+This field controls the maximum achievable Tx swing in the PHY
+This field drives the output port 'xpcs_tx_vboost_lvl_o[2:0]'.
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 3, 3);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,HSIO_XPCS1);
+
+/*
+RX_TERM_ACDC_0	Set the value in VR_MII_MP_12G_16G_25G_RX_GENCTRL1 to 1 (change to reg VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1) 
+bit8:	RX_TERM_ACDC_0
+Rx Termination control on lane 0 of 12G PHY. - 0: DC
+Termination (Floating Rx) - 1: AC Termination (Grounded Rx)This field drives the output port xpcs_rx_term_acdc_o[0].Value After Reset: "RXAUI_DEFAULT ? 0x0 : 0x1"
+Exists: Always
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 1, 1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1,read_data,HSIO_XPCS1);
+
+/*
+LOS_TRSHLD_0	Set the value in VR_XS_PMA_MP_12G_16G_RX_GENCTRL3 to 3d_3 
+bit2:0 LOS_TRSHLD_0
+Loss of signal threshold on lane 0 of 12G PHY.
+This field drives the output port xpcs_rx0_los_threshold_o[2:0].
+Threshold voltages for various values are as follows :
+- 3'b000 : Reserved
+- 3'b001 : 90 mVpp
+- 3'b010 : 120 mVpp
+- 3'b011 : 150 mVpp
+- 3'b100 : 180 mVpp
+- 3'b101 : 210 mVpp
+- 3'b110 : 240 mVpp
+- 3'b111 : 270 mVpp
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 0, 3, 3);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,read_data,HSIO_XPCS1);
+
+/*
+LOS_LFPS_EN_0	Set the value in VR_XS_PMA_MP_12G_16G_RX_GENCTRL3 to 0
+bit12:	LOS_LFPS_EN_0
+Rx LOS LFPS Enable on lane 0 of the PHY
+This field drives the output port xpcs_rx_los_lfps_en_o[0] to enable the LFPS filter on lane 0 of the PHY.
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 12, 1, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,read_data,HSIO_XPCS1);
+
+/*
+PCIE_EXT_TX_TERM_CTRL, (PCIE3_App)
+PCIE_EXT_RX_TERM_CTRL, (PCIE3_App)
+Set both values to h2 in PCIe PHY Miscellaneous Control B 
+(Note: default value after reset is h2 no need to program)
+
+PCIE_PHY_EXT_MISC_CTRL_B	offset=0x74
+bit18:16	PCIE_EXT_TX_TERM_CTRL
+bit21:19	PCIE_EXT_RX_TERM_CTRL
+*/
+	REG32(PAIR_CM2PHY0_APP + 0x74) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x74), 16, 3, 2);
+	REG32(PAIR_CM2PHY0_APP + 0x74) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x74), 19, 3, 2);
+
+/*
+PCIE_EXT_MPLLB_WORD_DIV2_EN (PCIE3_App)
+Set the values to 0 in PCIe PHY MPLLB Control 3
+
+PCIE_PHY_EXT_MPLLB_CTRL_3 offset=0x6C
+bit27	PCIE_EXT_MPLLB_WORD_DIV2_EN
+*/
+	REG32(PAIR_CM2PHY0_APP + 0x6C) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x6C), 27, 1, 0);
+
+/*
+MPLLB_FORCE_EN (PCIE3_App)
+Set the values to 0 in PHY MPLLB Control
+
+PCIE_PHY_MPLLB_CTRL offset=0x14
+bit0	MPLLB_FORCE_EN
+*/
+	REG32(PAIR_CM2PHY0_APP + 0x14) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x14), 0, 1, 0);
+
+/*
+PCIE_EXT_ADAPT_AFE_EN_G1 (PCIE3_App)
+Set the values to 0 in PCIe PHY EQ Control 1a
+
+PCIE_EXT_ADAPT_DFE_EN_G1 (PCIE3_App)
+Set the values to 0 in PCIe PHY EQ Control 1a
+
+PCIE_PHY_EXT_EQ_CTRL_1A offset=0x40
+bit0	PCIE_EXT_RX_ADAPT_AFE_EN_G1
+bit1	PCIE_EXT_RX_ADAPT_DFE_EN_G1
+*/
+	REG32(PAIR_CM2PHY0_APP + 0x40) = val_clearNset(REG32(PAIR_CM2PHY0_APP + 0x40), 0, 2, 0);
+
+/*
+DFE_TAP1_0 
+Set the value to 0 in VR_XS_PMA_MP_12G_16G_25G_DFE_TAP_CTRL0
+
+VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0 
+bit7:0	DFE_TAP1_0
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 0, 8, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,read_data,HSIO_XPCS1);
+}
+
+int lgmc_sgmii_1g_speed_settings(void)
+{
+	return 0;
+}
+
+int lgmc_sgmii_2g5_speed_settings(void)
+{
+	u32 timer = 10000;
+	/**********1.  Write 4'b0001 to bits [3:0] of SR_XS_PCS_CTRL2 (to disable KR Mode).******************/
+	/*bit[3:0] PCS Type Select.This field is used to select PCS operating mode in DWC_xpcs,0001: Select 10GBASE-X PCS Type
+	This looks like to just to disable R mode and move to X mode*/
+	indirect_pcs_rd(SR_XS_PCS_CTRL2,HSIO_XPCS1);
+	indirect_pcs_wr(SR_XS_PCS_CTRL2,val_clearNset(read_data, 0, 4, 1),HSIO_XPCS1);
+
+	/********** 2. Clear bit [0] of VR_XS_PCS_XAUI_CTRL to 0 (to disable RXAUI Mode and enable XAUI mode). 
+	bit0: 0=XAUI Mode 
+			1=RXAUI Mode
+	******************/
+	indirect_pcs_rd(VR_XS_PCS_XAUI_CTRL,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PCS_XAUI_CTRL,val_clearNset(read_data, 0, 1, 0),HSIO_XPCS1);
+
+	/********** 3. Clear Bit [13] of SR_XS_PCS_CTRL1 to 0.  ******************/
+	/*Speed Selection:This bit indicates the operational mode of the PCS-X block of the DWC_xpcs.
+	0: DWC_xpcs is in the KX mode (1G speed)
+	1: DWC_xpcs is in the KX4 mode (10G speed)*/
+	indirect_pcs_rd(SR_XS_PCS_CTRL1,HSIO_XPCS1);
+	indirect_pcs_wr(SR_XS_PCS_CTRL1,val_clearNset(read_data, 13, 1, 0),HSIO_XPCS1);
+
+	/**********4. Program bit [2] (EN_2_5G_MODE) of VR_MII_DIG_CTRL1 (in 1000BASEX-Only PCS configuration) to 1.  
+	bit2:	Enable 2.5G GMII Mode.
+This bit should be set to 1 to enable 2.5G GMII Mode ofoperation.This bit drives the output port 'xpcs_2pt5g_mode_o'.This bit is shared with bit[2] of VR XS or PCS MMD DigitalControl 1 Register
+	******************/
+	indirect_pcs_rd(VR_MII_DIG_CTRL1,HSIO_XPCS1);
+	indirect_pcs_wr(VR_MII_DIG_CTRL1,val_clearNset(read_data, 2, 1, 1),HSIO_XPCS1);
+
+	/**********WARNING: SRAM_EXT_LD_DONE field of PHY SRAM Control and Status(should use direct access instead of indirect access)  must be kept to 0 . Ensure PHY Calibration does not start until the PHY configuration is properly done and PHY FW is loaded.  (FW loading is optional).
+	bit0:	SRAM_BYPASS
+	bit1:	SRAM_EXT_LD_DONE
+	bit2:	SRAM_INIT_DONE
+******************/
+	timer = 10000;
+	while((REG32(PAIR_CM2PHY0_APP + PCIE_PHY_SRAM_CSR) & 0x2) == 0x2){
+		timer--;
+		if(timer == 0){
+			printf("timeout on Polling EXT_LD_DN(bit1) of PHY SRAM Control and Status till it becomes 0 \n");
+			return -1;
+		}
+	}
+
+	/**********5. If SGMII Mode is enabled, program SS6 (bit [6]) and SS13 (bit [13]) bits of SR_MII_CTRL to set speed as 1000Mbps (which corresponds to 2.5Gbps due to higher clock-rate).  ******************/
+	/*For SGMII configurations:When SS6=1 and SS13=0, speed is 1000 Mbps*/
+	indirect_pcs_rd(SR_MII_CTRL,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 6, 1, 1);
+	read_data = val_clearNset(read_data, 13, 1, 0);
+	indirect_pcs_wr(SR_MII_CTRL,read_data,HSIO_XPCS1);
+
+	/**********
+Program MPLLB_CAL_DISABLE bit of any one of the following registers to 0. 
+VR_MII_MP_12G_16G_MPLLB_CTRL0,		VR_MII_MP_25G_MPLLB_CTRL1 Register(not care) (for 1000BaseX-Only PCS configurations)
+
+bit15:	MPLLB Calibration Disable
+This field can be programmed to 1, to disable calibration ofMPLLB by PHY firmware.
+Value After Reset: 0x1
+Exists: Always
+
+VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0
+	******************/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,val_clearNset(read_data, 15, 1, 0),HSIO_XPCS1);
+
+	/**********
+Program MPLLB_SEL_0 bit of any one of the following registers to 1. 
+VR_MII_MP_12G_16G_25G_MPLL_CMN_CTRL Register (for 1000BaseX-Only PCS configurations) 
+VR_XS_PMA_MP_12G_16G_25G_MPLL_CMN_CTRL Register 
+bit4:	MPLLB_SEL_0
+Tx MPLLB Select-lane 0
+When this bit is set, PHY selects MPLLB to generate Tx analog clocks on lane 0
+	*************************************/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,HSIO_XPCS1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,val_clearNset(read_data, 4, 1, 1),HSIO_XPCS1);
+
+	config_c10_phy_SGMII2G5_through_xpcs();
+
+/*7. Initiate a Vendor-specific Software Reset by writing 1 to bit [15] of VR_XS_PCS_DIG_CTRL1. 
+NOTE: If FW loading is required, SRAM_EXT_LD_DONE field of PHY SRAM Control and Status must be 0 before VR_RST is triggered. This is applicable whenever VR_RST is triggered. 
+bit15:	VR_RST
+Vendor-Specific Soft Reset (RW,SC Type)
+When the host sets this bit, the CSR block triggers the software reset process in which all internal blocks are reset, except the Management Interface block and CSR block.
+When this bit is set, it also resets the PHY. This bit is self cleared under the following conditions:
+For Synopsys PHY, this bit is self cleared when Bits[4:2] in VR XS or PCS MMD Digital Status Register is equal to 3'b100, that is, Tx/Rx clocks are stable and in Power_Good state.
+For Non-Synopsys PHY, this bit is self cleared after the following:
+- 32 clk_csr_i clocks for the MCI interface
+- 1 MDC clock period for the MDIO interface
+Note: For information about the read or write access for any register during the reset process, see 'Special Case Register Access' section in databook.
+*/
+
+	/**********WARNING: SRAM_EXT_LD_DONE field of PHY SRAM Control and Status(PAIR_CM2PHY0_APP + PCIE_PHY_SRAM_CSR) must be kept to 0 . Ensure PHY Calibration does not start until the PHY configuration is properly done and PHY FW is loaded.  (FW loading is optional).  
+	bit0:	SRAM_BYPASS
+	bit1:	SRAM_EXT_LD_DONE
+	bit2:	SRAM_INIT_DONE
+	******************/
+	timer = 10000;
+	while((REG32(PAIR_CM2PHY0_APP + PCIE_PHY_SRAM_CSR) & 0x2) == 0x2){
+		timer--;
+		if(timer == 0){
+			printf("timeout on Polling EXT_LD_DN(bit1) of PHY SRAM Control and Status till it becomes 0 \n");
+			return -1;
+		}
+	}
+
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 15, 1, 1);
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,read_data,HSIO_XPCS1);
+
+/*8.1 Poll SRAM_INIT_DONE of PHY SRAM Control and Status till it becomes 1.
+	bit0:	SRAM_BYPASS
+	bit1:	SRAM_EXT_LD_DONE
+	bit2:	SRAM_INIT_DONE
+*/
+	timer = 10000;
+	while((REG32(PAIR_CM2PHY0_APP + PCIE_PHY_SRAM_CSR) & 0x4) == 0){
+		timer--;
+		if(timer == 0){
+			printf("timeout on Polling SRAM_INIT_DONE of PHY SRAM Control and Status till it becomes 1 \n");
+			return -1;
+		}
+	}
+
+/*8.2 (Optional step only: can be skipped if no PHY FW update is required) After waiting for a duration of at least 10 clock cycles (128 ns) of cr_para_clk, software can optionally write to CR registers inside DWC_xpcs to modify the contents of SRAM connected to the PHY*/
+
+/*8.3 Program SRAM_EXT_LD_DONE field of PHY SRAM Control and Status to 1 
+	bit0:	SRAM_BYPASS
+	bit1:	SRAM_EXT_LD_DONE
+	bit2:	SRAM_INIT_DONE
+*/
+	REG32(PAIR_CM2PHY0_APP + PCIE_PHY_SRAM_CSR) |= 0x2;
+
+/*9. Wait for VR_RST bit [15] of VR_XS_PCS_DIG_CTRL1 to get cleared. */
+	timer = 10000;
+	while((indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,HSIO_XPCS1) & 0x8000) == 0x8000){
+		timer--;
+		if(timer == 0){
+			printf("timeout on Polling VR_RST bit [15] of VR_XS_PCS_DIG_CTRL1 to get cleared \n");
+			return -1;
+		}
+	}
+
+/*10. Wait for power good state : VR_XS_PCS_DIG_STS.PSEQ_STATE : 3b_100: Tx/Rx stable (Power_Good state)
+bit4:2	PSEQ_STATE
+For Synopsys Enterprise Gen5 12G/16G PHY
+3b_000: Wait for ACK High 0
+3b_001: Wait for ACK Low 0
+3b_010: Wait for ACK High 1
+3b_011: Wait for ACK Low 1
+3b_100: Tx/Rx stable (Power_Good state)
+3b_101: Power Save state
+3b_110: Power Down state
+*/
+	timer = 10000;
+	while((indirect_pcs_rd(VR_XS_PCS_DIG_STS,HSIO_XPCS1) & 0x1c) != 0x10){
+		timer--;
+		if(timer == 0){
+			printf("timeout on Polling Wait for power good state : VR_XS_PCS_DIG_STS.PSEQ_STATE : 3b_100: Tx/Rx stable (Power_Good state)\n");
+			return -1;
+		}
+	}
+
+/*11 . XPCS1: Enable xgmii clk towards MAC, set to 1 HSIO_TOP.XPCS1_XGMII_CLK_CTR.XGMII_CLK_EN =1.
+bit0	XGMII_CLK_EN
+*/
+	REG32(HSIO_TOP_BASE + XPCS1_XGMII_CLK_CTR) |= 0x1;
+
+/*12. Program TX_CLK_RDY{lane} field of VR_XS_PMA_MP_12G_16G_25G_TX_GENCTRL1 register to 1 
+bit12:	TX_CLK_RDY_0
+Transmitter Input clock ready on lane 0
+This field drives the output xpcs_tx_clk_rdy_o[0]. This field should remain high, as long as PHY Tx Clock is active
+*/
+mdelay(50);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 12, 1, 1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,HSIO_XPCS1);
+
+/*13. Program TX_EQ_PRE field of VR_XS_PMA_MP_12G_16G_25G_TX_EQ_CTRL0 register to 0 
+bit5:0	TX_EQ_PRE
+Tx Pre-Emphasis level adjustment Control
+This field controls the transmitter driver output pre-emphasis (pre-shoot coefficient).
+This field drives the output port 'rpcs_ktx_pre_o' in the following conditions:
+- When CL72_EN=Enabled : if 'TX_EQ_OVR_RIDE' bit of VR XS or PMA Synopsys Enterprise Gen5 12G/16G PHY Transmit Equalization Control 1 Register is set
+- When CL72_EN=Disabled : always
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 0, 6, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,read_data,HSIO_XPCS1);
+
+/*14. Program TX_EQ_MAIN field of VR_XS_PMA_MP_12G_16G_25G_TX_EQ_CTRL0 register to 6d_24 
+bit13:8	TX_EQ_MAIN
+Control for setting Tx driver output amplitude
+This field drives the output port 'rpcs_ktx_main_o' in the following conditions:
+- When CL72_EN=Enabled : if 'TX_EQ_OVR_RIDE' bit of 'VR XS or PMA Synopsys Enterprise Gen5 12G/16G PHY Transmit Equalization Control 1 Register' is set
+- When CL72_EN=Disabled : always
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 8, 6, 24);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,read_data,HSIO_XPCS1);
+
+/*15. Program TX_EQ_POST field of VR_XS_PMA_MP_12G_16G_25G_TX_EQ_CTRL1 register to 0 
+bit5:0	TX_EQ_POST
+Tx Post-Emphasis level adjustment Control
+This field controls the transmitter driver output pre-emphasis (pre-shoot coefficient).
+This field drives the output port 'rpcs_ktx_post_o' in the following conditions:
+- When CL72_EN=Enabled : if 'TX_EQ_OVR_RIDE' bit is set
+- When CL72_EN=Disabled : always
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,HSIO_XPCS1);
+	read_data = val_clearNset(read_data, 0, 6, 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,read_data,HSIO_XPCS1);
+
+/*16. Program TX_EQ_OVR_RIDE field of VR_XS_PMA_MP_12G_16G_25G_TX_EQ_CTRL1 register to 1 (only for configurations with CL72 support) */
+
+	return 0;
+}
+
+int lgmc_sgmii_init(LGMC_SGMII_CONNECTION_SEL_t SGMII_CONNECTION, LGMC_SGMII_SPEED_SEL_t SGMII_SPEED)
+{
+	u32 timer = 10000;
+
+	if (SGMII_CONNECTION == HSIO2_XPCS1_HSIO4_PHY0_C10) {
+		/*printf("HSIOR, HSIO2_XPCS1_HSIO4_PHY0_C10\n");*/
+		HSIO_TOP_BASE = 		HSIOR_TOP_BASE;
+		HSIO_RCU_RST_REQ = 	RCU_RST_REQ_HSIOR;
+		PAIR_CM1PHY0_CR = 	HSIO2_CB2PHY0_CR;
+		PAIR_CM1PHY0_APP = 	HSIO2_CB2PHY0_APP;
+		PAIR_CM1PHY1_CR = 	HSIO2_CB2PHY1_CR;
+		PAIR_CM1PHY1_APP = 	HSIO2_CB2PHY1_APP;
+		PAIR_CM2PHY0_CR = 	HSIO4_CB3PHY0_CR;
+		PAIR_CM2PHY0_APP = 	HSIO4_CB3PHY0_APP;
+		PAIR_CM2PHY1_CR = 	HSIO4_CB3PHY1_CR;
+		PAIR_CM2PHY1_APP = 	HSIO4_CB3PHY1_APP;
+
+		HSIO_XPCS1 = 			XPCS3;
+		}
+	else {
+		/*printf("HSIOL, HSIO1_XPCS1_HSIO3_PHY0_C10\n");*/
+		HSIO_TOP_BASE = 		HSIOL_TOP_BASE;
+		HSIO_RCU_RST_REQ = 	RCU_RST_REQ_HSIOL;
+		PAIR_CM1PHY0_CR = 	HSIO1_CB0PHY0_CR;
+		PAIR_CM1PHY0_APP = 	HSIO1_CB0PHY0_APP;
+		PAIR_CM1PHY1_CR = 	HSIO1_CB0PHY1_CR;
+		PAIR_CM1PHY1_APP = 	HSIO1_CB0PHY1_APP;
+		PAIR_CM2PHY0_CR = 	HSIO3_CB1PHY0_CR;
+		PAIR_CM2PHY0_APP = 	HSIO3_CB1PHY0_APP;
+		PAIR_CM2PHY1_CR = 	HSIO3_CB1PHY1_CR;
+		PAIR_CM2PHY1_APP = 	HSIO3_CB1PHY1_APP;
+	
+		HSIO_XPCS1 = 			XPCS1;
+		}
+
+	indirect_pcs_wr(0x04001c ,0xd ,HSIO_XPCS1);
+	indirect_pcs_wr(0x7e0000 ,0x4 ,HSIO_XPCS1);
+	indirect_pcs_wr(0x060244 ,0x94 ,HSIO_XPCS1);
+	indirect_pcs_wr(0x06026c ,0x1 ,HSIO_XPCS1);
+	indirect_pcs_wr(0x0e0000 ,0x4 ,HSIO_XPCS1);
+	indirect_pcs_wr(0x0e0014 ,0x0 ,HSIO_XPCS1);
+	indirect_pcs_wr(0x780010 ,0x0 ,HSIO_XPCS1);
+	indirect_pcs_wr(0x780014 ,0x0 ,HSIO_XPCS1);
+	indirect_pcs_wr(0x780020 ,0x0 ,HSIO_XPCS1);
+	indirect_pcs_wr(0x780024 ,0x0 ,HSIO_XPCS1);
+
+	/*addr,pos,width,val*/
+	/***************************set combophy mode for GEN4(combo1) and GEN3(combo2) combo*******/
+	/*GEN4,Combo1=XFI = 3*/
+	reg_field_clearNset(HSIO_TOP_BASE + ETHSATA_COMBOPHY_MODE, ETHSATA_COMBOPHY_MODE_POS, ETHSATA_COMBOPHY_MODE_WIDTH, 3);
+	/*GEN3,Combo2=SGMII = 2*/
+	reg_field_clearNset(HSIO_TOP_BASE + GEN3_COMBOPHY_MODE, GEN3_COMBOPHY_MODE_POS, GEN3_COMBOPHY_MODE_WIDTH, 2);
+
+	/****************************isolate GEN4(combo1) xcps1 with others to pretend potential issues, by force xpcs0 connect to phys of GEN4(combo1)***************/
+	/*with pair,choose xpcs0 to control phy0/1 of E16 phy, this is to isolate xpcs1 from E16 phy.
+	REGISTER NAME:  XPCS_CTRL   -  LOCAL OFFSET : 130H*/
+	/*bit0:XPCS_MASTER_EN, Enable Software to control the XPCS0 and XPCS1 connection to the PHY for shared PHY signals between PHY lane 0 and PHY lane1 when set to 1.*/
+	reg_field_clearNset(PAIR_CM1PHY0_APP + APP_XPCS_CTRL, 0, 1, 1);
+	/*bit1:XPCS_MASTER_SEL, This bit is only effective when XPCS master enable bit is set to 1.
+	0 : Program of shared PHY signals must be done via XPCS0 PHY registers
+	1: Program of shared PHY signals must be done via XPCS1 PHY registers*/
+	reg_field_clearNset(PAIR_CM1PHY0_APP + APP_XPCS_CTRL, 1, 1, 0);
+
+	/*************************set clocks****************************************************/
+	/*enable all HSIO/COMBO CLK from CGU*/
+	REG32(CGU_CGU_CLKGCR2_A) = 0xffffffff;
+	
+	/*0:enable clk, 1:disable clk*/
+	/*GEN4,bit0-5:pcie0,pcie1,xpcs0,xpcs1,sata0,sata1*/
+	/*enable GEN4 xpcs1 clk,disable others*/
+	REG32(HSIO_TOP_BASE + ETHSATA_CLK_DIS_REG) = 0x37;
+
+	/*0:enable clk, 1:disable clk*/
+	/*GEN3,bit0-1:pcie0,pcie1*/
+	/*enable GEN3 pcie0 clk,disable others*/
+	REG32(HSIO_TOP_BASE + GEN3_CLK_DIS_REG) = 0x2;
+
+	/*disable XPCS0 XGMII interface clock,bit0: 0=disable,1=enable */
+	REG32(HSIO_TOP_BASE + XPCS0_XGMII_CLK_CTR) = 0x0;
+
+	/*enable XPCS1 XGMII interface clock ,bit0: 0=disable,1=enable*/
+	REG32(HSIO_TOP_BASE + XPCS1_XGMII_CLK_CTR) = 0x1;
+
+	/*************Combo2 rcu settings***************************************/
+	/*Combo2 Cphy_rst_n and phy_rstn de-asserted . Combo2 PCIe reset remain asserted.*/
+	/*for HSIOL:
+	bit18:PCIE3X_CPHY,
+	bit8:PCIE30_PHY,
+	bit3:PCIE31_PCIE1,
+	bit2:PCIE30_PCIE0*/
+	/*for HSIOR:
+	bit18:PCIE4X_CPHY,
+	bit8:PCIE40_PHY,
+	bit3:PCIE41_PCIE1,
+	bit2:PCIE40_PCIE0*/
+	reg_field_clearNset(HSIO_RCU_RST_REQ, 18, 1, 0);
+	reg_field_clearNset(HSIO_RCU_RST_REQ, 8, 1, 0);
+	reg_field_clearNset(HSIO_RCU_RST_REQ, 3, 1, 1);
+	reg_field_clearNset(HSIO_RCU_RST_REQ, 2, 1, 1);
+
+	/*************Combo1 rcu settings***************************************/
+	/*Combo1 Cphy_rst_n and xpcs1_rstn de-asserted */
+	/*for HSIOL:
+	bit17:PCIE1X_CPHY,
+	bit13:PCIE11_PCS*/
+	/*for HSIOR:
+	bit17:PCIE2X_CPHY,
+	bit13:PCIE21_PCS*/
+	reg_field_clearNset(HSIO_RCU_RST_REQ, 17, 1, 0);
+	reg_field_clearNset(HSIO_RCU_RST_REQ, 13, 1, 0);
+
+	/**********5.Program the XPCS register BYP_PWRUP to 1.******************/
+	/*bit1:BYP_PWRUP*/
+	indirect_pcs_rd(VR_PMA_DIG_CTRL1,HSIO_XPCS1);
+	indirect_pcs_wr(VR_PMA_DIG_CTRL1,(read_data | 0x2),HSIO_XPCS1);
+
+	/*********6.Polling SR_XS_PCS_CTRL1 Register bit15 until it is clear to 0.
+	Verification Time out in 200 APB,HSIO NOC clock cycles for error condition  
+	bit15:	soft reset
+	***************/
+	timer = 10000;
+	do{
+		timer--;
+	}while((timer>0) && (indirect_pcs_rd(SR_XS_PCS_CTRL1,HSIO_XPCS1) & 0x8000));
+
+	if (timer == 0){
+		printf("timeout on Polling SR_XS_PCS_CTRL1 Register bit15 until it is clear to 0 \n");
+		return -1;
+	}
+
+	/*********7.Program the XPCS register BYP_PWRUP to 0*********************************************/
+	/*bit1:BYP_PWRUP*/
+	indirect_pcs_rd(VR_PMA_DIG_CTRL1,HSIO_XPCS1);
+	indirect_pcs_wr(VR_PMA_DIG_CTRL1,(read_data & (~(0x2))),HSIO_XPCS1);
+
+	if (SGMII_SPEED == LGMC_SGMII_2G5){
+			/*printf("LGMC_SGMII_2G5\n");*/
+			lgmc_sgmii_2g5_speed_settings();
+		}
+	else{
+			/*printf("LGMC_SGMII_1G\n");*/
+			lgmc_sgmii_1g_speed_settings();
+		}
+	mdelay(150);
+	return 0;
+}
+#endif
+
+u32 combo_phy_cr_base(struct combo_port *paddr, int port)
+{
+	return paddr[port].port_to_addr.phy_cr_base;
+}
+
+int gswipo_rst_assert(void)
+{
+	udelay(1);
+	set_reset(RST_REQ_ETHNOC, REQ_GSWIPO);
+	LGM_NET_DBG("ETHNOC_REQ GSWIPO Reset BIT8 Asserted\n");
+	return 0;
+}
+
+int gswipo_rst_deassert(void)
+{
+	udelay(1);
+	clear_reset(RST_REQ_ETHNOC, REQ_GSWIPO);
+	LGM_NET_DBG("ETHNOC_REQ GSWIPO Reset BIT8 Deasserted\n");
+	return 0;
+}
+
+int gswipo_rst_stat(void)
+{
+	int stat = 0;
+	udelay(1);
+	stat = get_reset_bit_status(RST_STAT_ETHNOC, REQ_GSWIPO);
+	stat = get_reset_bit_status(RST_STAT_ETHNOC, REQ_GSWIPO);
+	return stat;
+}
+
+void set_reset(u32 regoff, u32 bitn)
+{
+	REG32(RCU_MODULE_BASE + regoff) |= BIT(bitn);
+	LGM_NET_DBG("Bit %d reset assert addr 0x%08x val 0x%08x\n",
+		bitn, RCU_MODULE_BASE + regoff, REG32(RCU_MODULE_BASE + regoff));
+}
+
+void clear_reset(u32 regoff, u32 bitn)
+{
+	REG32(RCU_MODULE_BASE + regoff) &= ~BIT(bitn);
+	LGM_NET_DBG("Bit %d reset deassert addr 0x%08x val 0x%08x\n",
+		bitn, RCU_MODULE_BASE + regoff, REG32(RCU_MODULE_BASE + regoff));
+}
+
+u32 get_reset_status(u32 regoff)
+{
+	return REG32(RCU_MODULE_BASE + regoff);
+}
+
+u32 SET_DATA_BITS(u32 data, int startb, int width, u32 set_bits){
+
+	data &= ~(((0x1 << (width)) - 1) << (startb));
+	data |= (((set_bits) & ((0x1 << (width)) - 1)) << (startb));
+	return data;
+}
+
+u32 indirect_pcs_wr(u32 address, u32 wr_data, int xpcs_prt)
+{
+	u32 shift_addr;
+	u32 my_addr;
+	u32 address_local = 0x0;
+
+	shift_addr = address ;
+	shift_addr = shift_addr >> 2 ;
+	my_addr = 0x0;
+
+	if (xpcs_prt == XPCS0) {
+		my_addr = my_addr | XPCS0_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(XPCS0_BASE_ADD) = shift_addr;
+		REG32(my_addr) =  wr_data;
+
+		if (dprint_enable == 1) {
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", XPCS0_BASE_ADD, shift_addr);
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", my_addr, wr_data);
+		}
+	} else if (xpcs_prt == XPCS1) {
+		my_addr = my_addr | XPCS1_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(XPCS1_BASE_ADD) = shift_addr;
+		REG32(my_addr) = wr_data;
+
+		if (dprint_enable == 1) {
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", XPCS1_BASE_ADD, shift_addr);
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", my_addr, wr_data);
+		}
+	} else if (xpcs_prt == XPCS2) {
+		my_addr = my_addr | XPCS2_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(XPCS2_BASE_ADD) =  shift_addr;
+		REG32(my_addr) =  wr_data;
+
+		if(dprint_enable == 1) {
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", XPCS2_BASE_ADD, shift_addr);
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", my_addr, wr_data);
+		}
+	} else if (xpcs_prt == XPCS3) {
+		my_addr = my_addr | XPCS3_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(XPCS3_BASE_ADD) = shift_addr;
+		REG32(my_addr) = wr_data;
+
+		if(dprint_enable == 1) {
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", XPCS3_BASE_ADD, shift_addr);
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", my_addr, wr_data);
+		}
+	} else if (xpcs_prt == WAN_XPCS4) {
+		my_addr = my_addr | WAN_XPCS4_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(WAN_XCPS4_BASE_ADD) = shift_addr;
+		REG32(my_addr) =  wr_data;
+
+		if(dprint_enable == 1) {
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", WAN_XCPS4_BASE_ADD, shift_addr);
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", my_addr, wr_data);
+		}
+	} else if (xpcs_prt == XPCS5) {
+		my_addr = my_addr | XPCS5_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(XPCS5_BASE_ADD) = shift_addr;
+		REG32(my_addr) = wr_data;
+
+		if(dprint_enable == 1) {
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", XPCS5_BASE_ADD, shift_addr);
+			printf("\n[WR]REG32(0x%08x) = 0x%08x\n", my_addr, wr_data);
+		}
+	}
+
+	udelay(10);
+	return 0;
+}
+
+u32 indirect_pcs_rd(u32 address, int xpcs_prt)
+{
+	u32 shift_addr;
+	u32 my_addr;
+	u32 address_local;
+	u32 rd_data;
+
+	shift_addr = address ;
+	shift_addr = shift_addr >> 2 ;
+	my_addr = 0x0;
+
+	if (xpcs_prt == XPCS0) {
+		my_addr = my_addr | XPCS0_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr   = shift_addr >> 8; /*shift addr [20:8] at slb */
+
+		REG32(XPCS0_BASE_ADD) = shift_addr;
+		read_data = REG32(my_addr);
+
+		if (dprint_enable == 1) {
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", XPCS0_BASE_ADD, shift_addr);
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", my_addr, read_data);
+		}
+	} else if (xpcs_prt == XPCS1) {
+		my_addr = my_addr | XPCS1_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+
+		REG32(XPCS1_BASE_ADD) =  shift_addr;
+		read_data = REG32(my_addr);
+
+		if (dprint_enable == 1) {
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", XPCS1_BASE_ADD, shift_addr);
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", my_addr, read_data);
+		}
+	} else if (xpcs_prt == XPCS2) {
+		my_addr = my_addr | XPCS2_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(XPCS2_BASE_ADD)  =  shift_addr;
+		read_data = REG32(my_addr);
+
+		if (dprint_enable == 1) {
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", XPCS2_BASE_ADD, shift_addr);
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", my_addr, read_data);
+		}
+	} else if (xpcs_prt == XPCS3) {
+		my_addr = my_addr | XPCS3_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(XPCS3_BASE_ADD) =  shift_addr;
+		read_data = REG32(my_addr);
+
+		if (dprint_enable == 1) {
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", XPCS3_BASE_ADD, shift_addr);
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", my_addr, read_data);
+		}
+	} else if (xpcs_prt == WAN_XPCS4) {
+		my_addr = my_addr | WAN_XPCS4_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(WAN_XCPS4_BASE_ADD) =  shift_addr;
+		read_data = REG32(my_addr);
+
+		if (dprint_enable == 1) {
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", WAN_XCPS4_BASE_ADD, shift_addr);
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", my_addr, read_data);
+		}
+	} else if (xpcs_prt == XPCS5) {
+		my_addr = my_addr | XPCS5_BASE_DAT;
+		address_local = address & 0x000003ff;/*taking add[9:0] */
+		my_addr = my_addr | address_local;
+		shift_addr = shift_addr &  0x001FFF00;/*shift addr [20:8] */
+		shift_addr = shift_addr >> 8; /*shift addr [20:8] at slb */
+		REG32(XPCS5_BASE_ADD) =  shift_addr;
+		read_data = REG32(my_addr);
+
+		if(dprint_enable == 1) {
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", XPCS5_BASE_ADD, shift_addr);
+			printf("\n[RD]REG32(0x%08x) = 0x%08x\n", my_addr, read_data);
+		}
+	}
+
+	rd_data = read_data & 0x0000FFFF; /*Take only BIT15:0 */
+	udelay(10);
+	return rd_data;
+
+}
+
+void cl72_73_an_en(int port)
+{
+	int i;
+
+	/*Configuration of Auto-negotiation Settings. */
+	printf("\nConfiguration of CL73 and CL73 Auto-negotiation Settings.\n");
+
+	/*Enable C73 Auto-negotiation */
+	/*SR_AN_CTRL BIT12 AN_EN */
+	printf("\nSet SR_AN_CTRL Setting BIT12 AN_EN = 1'b1 to enable C73 autoneg\n");
+	indirect_pcs_rd(SR_AN_CTRL,port);
+	indirect_pcs_wr(SR_AN_CTRL,(read_data | 0x1000),port);
+	indirect_pcs_rd(SR_AN_CTRL,port);
+	printf("[WR]Set SR_AN_CTRL Setting BIT12 AN_EN = 0x%08x\n", read_data);
+
+	/*Configuring VR_AN_TIMER_CTRL1 to higher value */
+	printf("\nConfiguring VR_AN_TIMER_CTRL1 to higher value\n");
+	indirect_pcs_rd(VR_AN_TIMER_CTRL1,port);
+	read_data = read_data | 0x00000001; /*setting bit [0] to 1 */
+	/*read_data = read_data | 0x0000000F;*/ /*setting to F */
+	indirect_pcs_wr(VR_AN_TIMER_CTRL1,read_data,port);
+
+	/*Configuring VR_AN_DIG_CTRL to override CL73_TMR_OVR_RIDE BIT[3] */
+	printf("\nConfiguring VR_AN_DIG_CTRL to higher value\n");
+	indirect_pcs_rd(VR_AN_DIG_CTRL1,port);
+	read_data = read_data | 0x00000008; /*setting bit [3] to 1 */
+	indirect_pcs_wr(VR_AN_DIG_CTRL1,read_data,port);
+
+	/*Enable Autonegotiation interrupts */
+	printf("\nEnable Autonegotiation Interrupt. \n");
+	indirect_pcs_rd(VR_AN_INTR_MSK,port);
+	indirect_pcs_wr(VR_AN_INTR_MSK,(read_data | 0x0007),port);
+
+	/*Restart autonegotiation */
+	printf("\nRestart Clause 73 autonegotiation\n");
+	indirect_pcs_rd(SR_AN_CTRL,port);
+	indirect_pcs_wr(SR_AN_CTRL,(read_data | 0x0200),port);
+
+	/***Clause 72 Start-Up Protocol Setup***/
+	/*SR_PMA_KR_PMD_CTRL BIT1 TR_EN set to 1 to Enable the 10GBASE-KR start-up protocol. */
+	/*If BIT1 is set before or during Clause 73 auto-negotiation, the training starts after all pages have been exchanged during Clause 73 auto-negotiation. */
+	printf("\nEnable Clause 72 start-up protocol for 10GBASE-KR Backplane\n");
+	indirect_pcs_rd(SR_PMA_KR_PMD_CTRL,port);
+	indirect_pcs_wr(SR_PMA_KR_PMD_CTRL,(read_data | 0x0002),port);
+
+	/***Restart Clause 72 start-up protocol for 10GBASE-KR Backplane***/
+	/*SR_PMA_KR_PMD_CTRL BIT0 RS_TR set to 1 to Restart the 10GBASE-KR start-up protocol. */
+	/*If BIT0 is self-cleared to 0 after restarting 10GBASE_KR startup protocol. */
+	printf("\nRestart Clause 72 start-up protocol for 10GBASE-KR Backplane\n");
+	indirect_pcs_rd(SR_PMA_KR_PMD_CTRL,port);
+	indirect_pcs_wr(SR_PMA_KR_PMD_CTRL,(read_data | 0x0002),port);
+
+	/***Check status of Clause 72 start-up protocol and coefficient update/status of local device or link partner****/
+
+	for (i = 0; i < CL72_CHECK_LOOP; i++) {
+		/*SR_PMA_KR_PMD_STS 10GBASE-KR Status Register
+		BIT0 RCV_STS
+		BIT1 FRM_LCK
+		BIT2 SU_PR_DTD
+		BIT3 TR_FAIL */
+		indirect_pcs_rd(SR_PMA_KR_PMD_STS, port);
+		printf("\n*****Check Clause 72 status [Count %d]*****\n", i);
+		printf("\nSR_PMA_KR_PMD_STS RCV_STS 0x%08x: Rx %s\n",
+		read_data, (read_data & SR_PMA_KR_PMD_STS_RCV_STS)? "Received trained and ready to receive data": "Receiver training");
+		printf("\nSR_PMA_KR_PMD_STS FRM_LCK 0x%08x: Rx %s\n",
+		read_data, (read_data & SR_PMA_KR_PMD_STS_FRM_LCK)? "Training frame delineation successfully detected": "Training frame delineation not detected");
+		printf("\nSR_PMA_KR_PMD_STS SU_PR_DTD 0x%08x: Rx %s\n",
+		read_data, (read_data & SR_PMA_KR_PMD_STS_SU_PR_DTD)? "Start-up protocol in progress": "Start-up protocol complete");
+		printf("\nSR_PMA_KR_PMD_STS TR_FAIL 0x%08x: Rx %s\n",
+		read_data, (read_data & SR_PMA_KR_PMD_STS_TR_FAIL)? "Training is completed with failure": "Training is not yet complete");
+
+		/*SR_PMA_KR_LP_CEU SR PMA MMD 10GBASE-KR LP Coefficient Update Register. Link Partner requests to Local Device.
+		BIT1:0 LP_CFF_UPDTM1 Co-efficient Update (-1)
+		BIT3:2 LP_CFF_UPDT0 Co-efficient Update (0)
+		BIT5:4 LP_CFF_UPDT1 Co-efficient Update (+1)
+		BIT12  LP_INIT Initialize Coefficient. Link partner requested the transmitter filter coefficients of local device to be initialized.
+		BIT13 PRST	Preset Coefficient. When this bit is set to 1, it indicated that the link partner requested the transmitter filter coefficients
+					of the local device to be set to a state where transmit equalization is turned off.
+		*/
+		indirect_pcs_rd(SR_PMA_KR_LP_CEU,port);
+		printf("\n*****Check 10GBASE-KR LP Coefficient Update [Count %d]*****\n", i);
+		printf("\nSR_PMA_KR_LP_CEU: 0x%08x\n", read_data);
+		printf("\nSR_PMA_KR_LP_CEU LP_INIT 0x%08x: %s\n",
+		read_data, (read_data & SR_PMA_KR_LP_CEU_LP_INIT)? "Initialize the local device transmit filter coefficient": "Normal operation");
+		printf("\nSR_PMA_KR_LP_CEU PRST 0x%08x: %s\n",
+		read_data, (read_data & SR_PMA_KR_LP_CEU_LP_PRST)? "LD Pre-initialize coefficients": "Normal operation");
+
+		/*SR_PMA_KR_LP_CESTS SR PMA MMD 10GBASE-KR LP Coefficient Status Register.
+		BIT1:0 LP_CFF_STSM0 Coefficient Status (-1)
+		BIT3:2 LP_CFF_STS0 Co-efficient Status (0)
+		BIT5:4 LP_CFF_STS1 Co-efficient Status (+1)
+		BIT15  LP_RR Link Partner Receiver Ready.
+		*/
+		indirect_pcs_rd(SR_PMA_KR_LP_CESTS,port);
+		printf("\n*****Check 10GBASE-KR LP Coefficient Status [Count %d]*****\n", i);
+		printf("\nSR_PMA_KR_LP_CESTS: 0x%08x\n", read_data);
+		printf("\nSR_PMA_KR_LP_CESTS LP_RR 0x%08x: %s\n",
+		read_data, (read_data & SR_PMA_KR_LP_CESTS_LP_RR)? "The LP receiver has determined that the training is complete, and it is ready to receive data.": "The LP receiver is requesting that the training should be continued.");
+
+		/*SR_PMA_KR_LD_CEU SR PMA MMD 10GBASE-KR LD Coefficient Update Register. Local Device requests to Link Partner.
+		BIT1:0 LD_CFF_UPDTM1 Co-efficient Update (-1)
+		BIT3:2 LD_CFF_UPDT0 Co-efficient Update (0)
+		BIT5:4 LD_CFF_UPDT1 Co-efficient Update (+1)
+		BIT12  LD_INIT Initialize Coefficient. Local device requested the transmitter filter coefficients of link partner to be initialized.
+		BIT13 PRST	Preset Coefficient. When this bit is set to 1, it indicated that the local device requested the transmitter filter coefficients
+					of the link partner to be set to a state where transmit equalization is turned off.
+		*/
+		indirect_pcs_rd(SR_PMA_KR_LD_CEU,port);
+		printf("\n*****Check 10GBASE-KR LD Coefficient Update [Count %d]*****\n", i);
+		printf("\nSR_PMA_KR_LD_CEU: 0x%08x\n", read_data);
+		printf("\nSR_PMA_KR_LD_CEU LD_INIT 0x%08x: %s\n",
+		read_data, (read_data & SR_PMA_KR_LD_CEU_LD_INIT)? "Initialize the link partner transmit filter coefficient": "Normal operation");
+		printf("\nSR_PMA_KR_LD_CEU PRST 0x%08x: %s\n",
+		read_data, (read_data & SR_PMA_KR_LD_CEU_LD_PRST)? "LP Pre-initialize coefficients": "Normal operation");
+
+		/*SR_PMA_KR_LD_CESTS SR PMA MMD 10GBASE-KR LP Coefficient Status Register.
+		BIT1:0 LD_CFF_STSM0 Coefficient Status (-1)
+		BIT3:2 LD_CFF_STS0 Co-efficient Status (0)
+		BIT5:4 LD_CFF_STS1 Co-efficient Status (+1)
+		BIT15  LD_RR Link Partner Receiver Ready.
+		*/
+		indirect_pcs_rd(SR_PMA_KR_LD_CESTS,port);
+		printf("\n*****Check 10GBASE-KR LD Coefficient Status [Count %d]*****\n", i);
+		printf("\nSR_PMA_KR_LD_CESTS: 0x%08x\n", read_data);
+		printf("\nSR_PMA_KR_LD_CESTS LP_RR 0x%08x: %s\n",
+		read_data, (read_data & SR_PMA_KR_LD_CESTS_LD_RR)
+			? "The LD receiver has determined that the training is complete, and it is ready to receive data."
+			:"The LD receiver is requesting that the training should be continued.");
+
+		udelay(10);
+	}
+
+	/*Check Clause 73 auto-negotiation status */
+	/*VR_AN_INTR VR AN MMD Interrupt Register
+	BIT0 AN_INT_CMPLT AN Complete Interrupt (SS,WC Type)
+	The DWC_xpcs sets this bit after the auto-negotiation is complete (as defined in IEEE Std 802.3, Clause 73).
+	Note: The host must clear this bit, by writing 0 to this bit, after recognizing the interrupt.
+	BIT1 AN_INC_LINK AN Incompatible Link (SS,WC Type)
+	BIT2 AN_PG_RCV AN Page Received (SS,WC Type)
+		The DWC_xpcs sets this bit when it receives a new auto-negotiation page (as defined in IEEE Std 802.3, Clause 73).
+		Note: The host must clear this bit, by writing 0 to this bit, after recognizing the interrupt.
+	*/
+	indirect_pcs_rd(VR_AN_INTR,port);
+	printf("\nCheck Clause 73 AN Interrupt register\n");
+	printf("\nVR_AN_INTR: 0x%08x\n", read_data);
+	printf("\nVR_AN_INTR INT_CMPLT 0x%08x: %s\n",
+			read_data, (read_data & VR_AN_INTR_AN_INT_CMPLT)? "Clause 73 auto-negotiation complete": "CL73 AN Complete interrupt not set");
+	printf("\nVR_AN_INTR AN_INC_LINK 0x%08x: %s\n",
+			read_data, (read_data & VR_AN_INTR_AN_INC_LINK)? "Incompatible link": "No incompatibility detected");
+	printf("\nVR_AN_INTR AN_PG_RCV 0x%08x: %s\n",
+	read_data, (read_data & VR_AN_INTR_AN_PG_RCV)? "New auto-negotiation page received": "No new auto-negotiation page");
+
+		/*Clear BIT0 of VR_AN_INTR */
+	if ((read_data & VR_AN_INTR_AN_INT_CMPLT) == 1) {
+		read_data = read_data & 0xFFFE;
+		indirect_pcs_wr(VR_AN_INTR,read_data,port);
+		printf("\nClear BIT0 of VR_AN_INTR\n");
+		indirect_pcs_rd(VR_AN_INTR,port);
+		printf("VR_AN_INTR: 0x%08x\n", read_data);
+	}
+
+	/*Clear BIT2 of VR_AN_INTR */
+	/* TODO: Check this */
+	if ((read_data & VR_AN_INTR_AN_PG_RCV)) {
+		read_data = read_data & 0xFFFB;
+		indirect_pcs_wr(VR_AN_INTR,read_data,port);
+		printf("\nClear BIT2 of VR_AN_INTR\n");
+		indirect_pcs_rd(VR_AN_INTR,port);
+		printf("VR_AN_INTR: 0x%08x\n", read_data);
+	}
+
+	/*SR_AN_STS SR AN MMD Status Register
+		BIT0 LP_AN_ABL	LP Auto-Negotiation Ability
+		BIT2 AN_LS	Auto-negotiation Link Status
+		BIT3 AN_ABL LD Auto-Negotiation Ability
+		BIT4 AN_RF	Auto-Negotiation Remote Fault
+		BIT5 ANC	Auto-Negotiation COmplete
+		BIT6 PR 	Page Received
+		BIT7 EXT_NP_STS Extended Next Page Status
+		BIT9 PDF	Parallel Detection Fault is detected in teh CL73 Auto-Negotiation
+	*/
+	indirect_pcs_rd(SR_AN_STS,port);
+	printf("\n*****Check Clause 73 AN Status register*****\n");
+	printf("\nSR_AN_STS: 0x%08x\n", read_data);
+	printf("\nSR_AN_STS LP_AN_ABL 0x%08x: %s\n",
+		read_data, (read_data & SR_AN_STS_LP_AN_ABL)? "LP able to participate in AN": "LP unable to participate in AN");
+	printf("\nSR_AN_STS AN_LS 0x%08x: %s\n",
+		read_data, (read_data & SR_AN_STS_LP_AN_LS)? "CL73 AN complete and determined a valid link": "CL73 not complete and not able to determine a valid link");
+	printf("\nSR_AN_STS AN_ABL 0x%08x: %s\n",
+		read_data, (read_data & SR_AN_STS_LD_AN_ABL)? "LD supports CL73 AN": "LD does not support CL73 AN");
+	printf("\nSR_AN_STS AN_RF 0x%08x: %s\n",
+		read_data, (read_data & SR_AN_STS_LD_AN_RF)? "Auto-negotiation process detected a remote fault": "No fault detected");
+	printf("\nSR_AN_STS ANC 0x%08x: %s\n",
+		read_data, (read_data & SR_AN_STS_LD_ANC)? "Auto-negotiation completes": "Auto-negotiation not complete");
+	printf("\nSR_AN_STS PR 0x%08x: %s\n",
+		read_data, (read_data & SR_AN_STS_LD_PR)? "Page is received and the corresponding Link Code Word is stored ": "No page received");
+	printf("\nSR_AN_STS PDF 0x%08x: %s\n",
+		read_data, (read_data & SR_AN_STS_LD_PDF)? "Parallel detection fault detected ": "No fault detected");
+
+	/*enable PCS ERR CNT */
+	printf("\nEnable PCS Errcnt\n");
+	indirect_pcs_rd(VR_XS_PCS_DIG_ERRCNT_SEL ,port);
+	indirect_pcs_wr(VR_XS_PCS_DIG_ERRCNT_SEL,(read_data | 0x0070),port);
+}
+
+void linkup_status(int port)
+{
+#ifdef LGM_NET_VERBOSE
+	unsigned int SR_XS_PCS_KR_STS2_LAT_BL = 15;
+	unsigned int SR_XS_PCS_KR_STS2_LAT_HBER	= 14;
+	unsigned int SR_XS_PCS_KR_STS2_BER_CNT = 8;
+	unsigned int SR_XS_PCS_KR_STS2_ERR_BLK = 0;
+#endif /* LGM_NET_VERBOSE */
+
+	/*Transmitter Status */
+	LGM_NET_DBG("\n************ TX status ************\n");
+	/*VR_XS_PMA_GEN5_12G_TX_STS
+	BIT0 TX_ACK_0
+	BIT4 DETRX_RSLT_0
+	Receiver Detection Result on lane 0 of 12G PHY
+	This field captures the value of the input port 'xpcs_tx_detrx_result_o[0]'.
+	The value of this field is valid when 'TX_ACK_0' is high.
+	- 1'b0: Receiver not detected
+	- 1'b1: Receiver detected */
+
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_STS, port);
+	LGM_NET_DBG("\nVR_XS_PMA_GEN5_12G_TX_STS TX_ACK_0  \t 0x%08x \t: %s",
+		read_data, (read_data & VR_XS_PMA_GEN5_12G_TX_STS_TX_ACK_0)? "Tx Acknowledge on Lane 0": "Tx NOT Acknowledge on Lane 0");
+	LGM_NET_DBG("\nVR_XS_PMA_GEN5_12G_TX_STS DETRX_RSLT_0  \t 0x%08x \t: Rx %s",
+		read_data, (read_data & VR_XS_PMA_GEN5_12G_TX_STS_DETRX_RSLT_0)? "Receiver Detected on Lane 0": "Receiver NOT Detected on Lane 0");
+
+	/*VR_XS_PMA_GEN5_12G_TX_POWER_STATE_CTRL
+	BIT1:0 TX0_PSTATE
+	Tx power state control for lane 0 of 12G PHY
+	Power state encoding is as follows:
+	- 2'b00: P0
+	- 2'b01: P0s
+	- 2'b10: P1
+	- 2'b11: P2
+	*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_POWER_STATE_CTRL, port);
+	LGM_NET_DBG("\nVR_XS_PMA_GEN5_12G_16G_TX_POWER_STATE_CTRL TX0_PSTATE BIT1:0 \t: 0x%08x", read_data);
+
+	/*Receiver Status */
+	LGM_NET_DBG("\n\n************ RX status ************\n");
+
+	/*SR_PMA_STATUS1 BIT2 RLU Rx Link Up (RO,LL Type)
+	For Synopsys Enterprise Gen5 10G PHY configurations:
+	* 0: This bit goes low when PHY is powered down (when PSEQ_STATE is not in POWER_GOOD state)
+	* 1: This bit goes high when PHY is powered up (when PSEQ_STATE is in POWER_GOOD state).
+	For all other configurations:
+	* 0: This bit goes low when the CDR status of the PHY goes low (indicated by xgxs_rx_valid_i{lane}).
+	* 1: This bit is set when the CDR status of the PHY goes high (indicated by xgxs_rx_valid_i{lane}). 	*/
+
+	indirect_pcs_rd(SR_PMA_STATUS1, port);
+	LGM_NET_DBG("\nSR_PMA_STATUS1 RLU  \t 0x%08x:  \t Rx %s",
+		read_data, (read_data & SR_PMA_STATUS1_RLU)? "LINK UP": "LINK DOWN");
+
+	/*SR_PMA_STATUS2 */
+
+	indirect_pcs_rd(SR_PMA_STATUS2, port);
+	LGM_NET_DBG("\nSR_PMA_STATUS2 Receiver Fault (RF)  \t 0x%08x:  \t Rx %s",
+		read_data, (read_data & SR_PMA_STATUS2_RF)? "Receiver Fault": "Rx No Fault");
+
+
+	/*SR_PMA_KR_PMD_STS
+	BIT0 RCV_STS
+	BIT1 FRM_LCK
+	BIT2 SU_PR_DTD
+	BIT3 TR_FAIL */
+
+	indirect_pcs_rd(SR_PMA_KR_PMD_STS, port);
+	LGM_NET_DBG("\nSR_PMA_KR_PMD_STS RCV_STS \t 0x%08x: \t Rx %s",
+		read_data, (read_data & SR_PMA_KR_PMD_STS_RCV_STS)? "Received trained and ready to receive data": "Receiver training");
+	LGM_NET_DBG("\nSR_PMA_KR_PMD_STS FRM_LCK \t 0x%08x: \t Rx %s",
+		read_data, (read_data & SR_PMA_KR_PMD_STS_FRM_LCK)? "Training frame delineation successfully detected": "Training frame delineation not detected");
+	LGM_NET_DBG("\nSR_PMA_KR_PMD_STS SU_PR_DTD \t 0x%08x: \t Rx %s",
+		read_data, (read_data & SR_PMA_KR_PMD_STS_SU_PR_DTD)? "Start-up protocol in progress": "Start-up protocol complete");
+	LGM_NET_DBG("\nSR_PMA_KR_PMD_STS TR_FAIL \t 0x%08x: \t Rx %s",
+		read_data, (read_data & SR_PMA_KR_PMD_STS_TR_FAIL)? "Training is completed with failure": "Training is not yet complete");
+
+	/*SR_PMA_KR_LP_CEU SR PMA MMD 10GBASE-KR LP Coefficient Update Register. Link Partner requests to Local Device.
+	  BIT1:0 LP_CFF_UPDTM1 Co-efficient Update (-1)
+	  BIT3:2 LP_CFF_UPDT0 Co-efficient Update (0)
+	  BIT5:4 LP_CFF_UPDT1 Co-efficient Update (+1)
+	  BIT12  LP_INIT Initialize Coefficient. Link partner requested the transmitter filter coefficients of local device to be initialized.
+	  BIT13 PRST  Preset Coefficient. When this bit is set to 1, it indicated that the link partner requested the transmitter filter coefficients
+				  of the local device to be set to a state where transmit equalization is turned off.
+	*/
+
+	indirect_pcs_rd(SR_PMA_KR_LP_CEU,port);
+	LGM_NET_DBG("\n\n***** Check 10GBASE-KR LP Coefficient Update *****\n");
+	LGM_NET_DBG("\nSR_PMA_KR_LP_CEU: \t 0x%08x", read_data);
+	LGM_NET_DBG("\nSR_PMA_KR_LP_CEU LP_INIT \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_PMA_KR_LP_CEU_LP_INIT)? "Initialize the local device transmit filter coefficient": "Normal operation");
+	LGM_NET_DBG("\nSR_PMA_KR_LP_CEU PRST \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_PMA_KR_LP_CEU_LP_PRST)? "LD Pre-initialize coefficients": "Normal operation");
+
+	/*SR_PMA_KR_LP_CESTS SR PMA MMD 10GBASE-KR LP Coefficient Status Register.
+	  BIT1:0 LP_CFF_STSM0 Coefficient Status (-1)
+	  BIT3:2 LP_CFF_STS0 Co-efficient Status (0)
+	  BIT5:4 LP_CFF_STS1 Co-efficient Status (+1)
+	  BIT15  LP_RR Link Partner Receiver Ready.
+	*/
+
+	indirect_pcs_rd(SR_PMA_KR_LP_CESTS,port);
+	LGM_NET_DBG("\n\n***** Check 10GBASE-KR LP Coefficient Status *****\n");
+	LGM_NET_DBG("\nSR_PMA_KR_LP_CESTS: \t 0x%08x", read_data);
+	LGM_NET_DBG("\nSR_PMA_KR_LP_CESTS LP_RR \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_PMA_KR_LP_CESTS_LP_RR)? "The LP receiver has determined that the training is complete, and it is ready to receive data.": "The LP receiver is requesting that the training should be continued.");
+
+	/*SR_PMA_KR_LD_CEU SR PMA MMD 10GBASE-KR LD Coefficient Update Register. Local Device requests to Link Partner.
+	  BIT1:0 LD_CFF_UPDTM1 Co-efficient Update (-1)
+	  BIT3:2 LD_CFF_UPDT0 Co-efficient Update (0)
+	  BIT5:4 LD_CFF_UPDT1 Co-efficient Update (+1)
+	  BIT12  LD_INIT Initialize Coefficient. Local device requested the transmitter filter coefficients of link partner to be initialized.
+	  BIT13 PRST  Preset Coefficient. When this bit is set to 1, it indicated that the local device requested the transmitter filter coefficients
+				  of the link partner to be set to a state where transmit equalization is turned off.
+	*/
+
+	indirect_pcs_rd(SR_PMA_KR_LD_CEU,port);
+	LGM_NET_DBG("\n\n***** Check 10GBASE-KR LD Coefficient Update *****\n");
+	LGM_NET_DBG("\nSR_PMA_KR_LD_CEU: \t 0x%08x", read_data);
+	LGM_NET_DBG("\nSR_PMA_KR_LD_CEU LD_INIT \t 0x%08x: \t %s",
+		read_data, (read_data & SR_PMA_KR_LD_CEU_LD_INIT)
+		? "Initialize the link partner transmit filter coefficient"
+		: "Normal operation");
+	LGM_NET_DBG("\nSR_PMA_KR_LD_CEU PRST \t 0x%08x: \t %s",
+		read_data,
+		(read_data & SR_PMA_KR_LD_CEU_LD_PRST)
+		? "LP Pre-initialize coefficients": "Normal operation");
+
+	/*SR_PMA_KR_LD_CESTS SR PMA MMD 10GBASE-KR LP Coefficient Status Register.
+	  BIT1:0 LD_CFF_STSM0 Coefficient Status (-1)
+	  BIT3:2 LD_CFF_STS0 Co-efficient Status (0)
+	  BIT5:4 LD_CFF_STS1 Co-efficient Status (+1)
+	  BIT15  LD_RR Link Partner Receiver Ready.
+	*/
+
+	indirect_pcs_rd(SR_PMA_KR_LD_CESTS,port);
+	LGM_NET_DBG("\n\n***** Check 10GBASE-KR LD Coefficient Status *****\n");
+	LGM_NET_DBG("\nSR_PMA_KR_LD_CESTS: \t 0x%08x", read_data);
+	LGM_NET_DBG("\nSR_PMA_KR_LD_CESTS LP_RR \t 0x%08x: \t %s",
+		read_data,
+		(read_data & SR_PMA_KR_LD_CESTS_LD_RR)
+		? "The LD receiver has determined that the training is complete, and it is ready to receive data."
+		: "The LD receiver is requesting that the training should be continued.");
+
+	/*SR_AN_STS SR AN MMD Status Register
+	  BIT0 LP_AN_ABL  LP Auto-Negotiation Ability
+	  BIT2 AN_LS  Auto-negotiation Link Status
+	  BIT3 AN_ABL LD Auto-Negotiation Ability
+	  BIT4 AN_RF  Auto-Negotiation Remote Fault
+	  BIT5 ANC	  Auto-Negotiation COmplete
+	  BIT6 PR	  Page Received
+	  BIT7 EXT_NP_STS Extended Next Page Status
+	  BIT9 PDF	  Parallel Detection Fault is detected in teh CL73 Auto-Negotiation
+	*/
+
+	indirect_pcs_rd(SR_AN_STS,port);
+	LGM_NET_DBG("\n\n***** Check Clause 73 AN Status register *****\n");
+	LGM_NET_DBG("\nSR_AN_STS: \t 0x%08x", read_data);
+	LGM_NET_DBG("\nSR_AN_STS LP_AN_ABL \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_AN_STS_LP_AN_ABL)? "LP able to participate in AN": "LP unable to participate in AN");
+	LGM_NET_DBG("\nSR_AN_STS AN_LS \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_AN_STS_LP_AN_LS)? "CL73 AN complete and determined a valid link": "CL73 not complete and not able to determine a valid link");
+	LGM_NET_DBG("\nSR_AN_STS AN_ABL \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_AN_STS_LD_AN_ABL)? "LD supports CL73 AN": "LD does not support CL73 AN");
+	LGM_NET_DBG("\nSR_AN_STS AN_RF \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_AN_STS_LD_AN_RF)? "Auto-negotiation process detected a remote fault": "No fault detected");
+	LGM_NET_DBG("\nSR_AN_STS ANC \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_AN_STS_LD_ANC)? "Auto-negotiation completes": "Auto-negotiation not complete");
+	LGM_NET_DBG("\nSR_AN_STS PR \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_AN_STS_LD_PR)? "Page is received and the corresponding Link Code Word is stored ": "No page received");
+	LGM_NET_DBG("\nSR_AN_STS PDF \t 0x%08x: \t %s",
+	  read_data, (read_data & SR_AN_STS_LD_PDF)? "Parallel detection fault detected ": "No fault detected");
+
+	/*SR_XS_PCS_STS1 BIT2 RLU
+	Rx Link Up (RO,LL Type)
+	XS MMD and PCS MMD in 10G mode:
+	- 0: When code group alignment and block lock are not successful.
+	- 1: When code group alignment and block lock are successful.
+	PCS MMD in 1G mode:
+	- 0: When code group alignment on Lane 0 is not successful.
+	- 1: When code group alignment on Lane 0 is successful. */
+
+	LGM_NET_DBG("\n\n***** Check on PCS Status register *****\n");
+	indirect_pcs_rd(SR_XS_PCS_STS1, port);
+	LGM_NET_DBG("\nSR_XS_PCS_STS1 RLU 0x%08x: Code group alignment and block(10G)/Lane 0(1G) lock %s",
+		read_data, (read_data & SR_XS_PCS_STS1_RLU)? "Successful": "Unsuccessful");
+
+	/*SR_XS_PCS_STS2
+	BIT10 RF Receiver Fault
+	BIT11 TF Transmitter Fault	*/
+
+	indirect_pcs_rd(SR_XS_PCS_STS2, port);
+	LGM_NET_DBG("\nSR_XS_PCS_STS2 RF 0x%08x: Device encountered a fault condition on the Rx path %s",
+		read_data, (read_data & SR_XS_PCS_STS2_RF)? "True": "False");
+	LGM_NET_DBG("\nSR_XS_PCS_STS2 TF 0x%08x: DWC_xpcs encountered a remote fault condition being transmitted on the Tx path %s",
+		read_data, (read_data & SR_XS_PCS_STS2_TF)? "True": "False");
+
+	/*SR_XS_PCS_KR_STS1 BIT12 PLU
+	RPCS Link Up
+	When this bit is high, it indicates that the PCS-R 66-bit code group alignment is successful and
+	the high bit rate condition is not encountered. If FEC is enabled, this bit also indicates that the FEC block lock is successful.
+	- 1: 10GBASE-R or 10GBASE-KR PCS receive link is up
+	- 0: 10GBASE-R or 10GBASE-KR PCS receive link is down */
+
+	indirect_pcs_rd(SR_XS_PCS_KR_STS1, port);
+	LGM_NET_DBG("\nSR_XS_PCS_KR_STS1 RLU 0x%08x: 10GBASE-R/KR PCS Receive %s",
+		read_data, (read_data & SR_XS_PCS_KR_STS1_RLU)? "LINK UP": "LINK DOWN");
+
+	/*SR_XS_PCS_KR_STS2
+	BIT7:0 ERR_BLK
+	BIT13:8 BER_CNT
+	BIT14 LAT_HBER
+	BIT15 LAT_BL */
+	indirect_pcs_rd(SR_XS_PCS_KR_STS2, port);
+	LGM_NET_DBG("\nSR_XS_PCS_KR_STS2 10GBASE-R Status2 Register 0x%08x: \n BIT7:0 ERR_BLK = 0x%08x \n BIT13:8 BER_CNT = 0x%08x \n BIT14 LAT_HBER = 0x%08x \n BIT15 LAT_BL = 0x%08x",
+		read_data, (read_data & 0x00FF) >> SR_XS_PCS_KR_STS2_ERR_BLK, (read_data & 0x3F00)
+			>> SR_XS_PCS_KR_STS2_BER_CNT, (read_data & 0x4000) >> SR_XS_PCS_KR_STS2_LAT_HBER,
+			(read_data & 0x8000) >> SR_XS_PCS_KR_STS2_LAT_BL);
+
+	/*SR_MII_STS BIT2 LINK_STS
+	The host uses this register to know the features supported by the DWC_xpcs in the 1000BASE-X mode.
+	Note:This register is present if the selected configuration has 1G/KX support.
+	Link Status (RO,LL Type)
+	When the DWC_xpcs sets this bit to 1, it indicates that the Rx link is up. If the link goes down, it is latched until the host perform the read operation to this register.
+	- 1: Link Up
+	- 0: Link Down */
+
+	LGM_NET_DBG("\n\n***** Check 1G Status *****\n");
+	indirect_pcs_rd(SR_MII_STS, port);
+	LGM_NET_DBG("\nSR_MII_STS RLU \t 0x%08x: \t 1000BASE-X mode Rx %s",
+		read_data, (read_data & SR_MII_STS_LINK_STS	)? "LINK UP": "LINK DOWN");
+
+	/*VR_MII_AN_CTRL BIT4 SGMII_LINK_STS
+	When SGMII_EN=Enabled or QSGMII_EN=Enabled or USXGMII Link Status:
+	SGMII Link Status/ USXGMII Link Status /QSGMII Port0 Link Status
+	This bit is used in Bit 15 of the Config_Reg during Clause 37 auto-negotiation when the TX_CONFIG bit of this register is
+	set to 1 in the SGMII/QSGMII/USXGMII mode and when PHY_MODE_CTRL bit of VR MII MMD Digital Control 1 Register is 0 .
+	- 0: Link Down
+	- 1: Link Up
+	For other configurations:
+	This is a read-only reserved field and returns 0. */
+
+	indirect_pcs_rd(VR_MII_AN_CTRL, port);
+	LGM_NET_DBG("\nVR_MII_AN_CTRL RLU \t 0x%08x: \t SGMII/QSGMII/USXGMII mode Port0 Rx %s",
+		read_data, (read_data & VR_MII_AN_CTRL_STS	)? "LINK UP": "LINK DOWN");
+
+	/*VR_MII_1_AN_CTRL BIT4 SGMII_LINK_STS
+	SGMII Link Status (port 1)
+	This bit is used in Bit 15 of the Tx_Config_Reg during Clause 37 auto-negotiation (along port 1)
+	when XPCS is programmed as QSGMII-PHY and when QSG_PHY_CTL bit of VR MII_1 MMD Digital Control 1 Register is 0 .
+	- 0: Link Down
+	- 1: Link Up */
+
+	indirect_pcs_rd(VR_MII_1_AN_CTRL, port);
+	LGM_NET_DBG("\nVR_MII_1_AN_CTRL Port0 RLU \t 0x%08x: \t SGMII mode Port1 Rx %s",
+		read_data, (read_data & VR_MII_1_AN_CTRL_SGMII_LINK_STS	)? "LINK UP": "LINK DOWN");
+
+
+	/*VR_MII_2_AN_CTRL BIT4 SGMII_LINK_STS
+	SGMII Link Status (port 2)
+	This bit is used in Bit 15 of the Tx_Config_Reg during Clause 37 auto-negotiation (along port 2)
+	when XPCS is programmed as QSGMII-PHY and when QSG_PHY_CTL bit of VR MII_2 MMD Digital Control 1 Register is 0 .
+	- 0: Link Down
+	- 1: Link Up  */
+
+	indirect_pcs_rd(VR_MII_2_AN_CTRL, port);
+	LGM_NET_DBG("\nVR_MII_2_AN_CTRL Port0 RLU \t 0x%08x: \t SGMII mode Port2 Rx %s",
+		read_data, (read_data & VR_MII_2_AN_CTRL_SGMII_LINK_STS	)? "LINK UP": "LINK DOWN");
+
+
+	/*SR_XS_PCS_CTRL2 PCS_TYPE_SEL BIT1:0
+	- 11: Reserved
+	- 10: Select 10GBASE-W PCS Type
+	- 01: Select 10GBASE-X PCS Type
+	- 00: Select 10GBASE-R PCS Type
+	*/
+	LGM_NET_DBG("\n\n***** Check 10G PCS Type, Status, SYNC, ERR COUNT *****\n");
+	indirect_pcs_rd(SR_XS_PCS_CTRL2, port);
+	LGM_NET_DBG("\nSR_XS_PCS_CTRL2 PCS_TYPE_SEL BIT1:0 \t = 0x%08x", read_data);
+
+	/*SR_XS_PCS_STS2 PCS_TYPE_SEL BIT1:0
+	CAP_EN BIT0 10GBASE-R Capable
+	CAP_10_1GC BIT1 CAP_10_1GC
+	CAP_10GBW BIT2 10GBASE-W Capable
+	CAP_10GBT BIT3 10GBASE-T Capable
+	RF BIT10 Receiver Fault (LH Type)
+	TF BIT11 Transmitter Fault (LH Type)
+	DS BIT15:14 Device Present Status. 2'b10 indicated that the MMD is present and responding to this register address.
+	*/
+	indirect_pcs_rd(SR_XS_PCS_STS2, port);
+	LGM_NET_DBG("\nSR_XS_PCS_STS2 \t = 0x%08x", read_data);
+
+	/*SR_PCS_TIME_SYNC_RX_MAX_DLY_LWR */
+	indirect_pcs_rd(SR_PCS_TIME_SYNC_RX_MAX_DLY_LWR, port);
+	LGM_NET_DBG("\nSR_PCS_TIME_SYNC_RX_MAX_DLY_LWR \t = 0x%08x", read_data);
+	/*SR_PCS_TIME_SYNC_RX_MIN_DLY_LWR */
+	indirect_pcs_rd(SR_PCS_TIME_SYNC_RX_MIN_DLY_LWR, port);
+	LGM_NET_DBG("\nSR_PCS_TIME_SYNC_RX_MIN_DLY_LWR \t = 0x%08x", read_data);
+
+	/*XPCS Error Counters */
+	indirect_pcs_rd(VR_XS_PCS_ICG_ERRCNT1, port);
+	LGM_NET_DBG("\nVR_XS_PCS_ICG_ERRCNT1 \t = 0x%08x", read_data);
+	indirect_pcs_rd(VR_XS_PCS_ICG_ERRCNT2, port);
+	LGM_NET_DBG("\nVR_XS_PCS_ICG_ERRCNT2 \t = 0x%08x\n", read_data);
+
+
+	/* add error counter here?*/
+}
+
+ /*Dump XPCS TX Register */
+static void dump_xpcs_tx_reg(int port)
+{
+	/*  //Read TX_RATE
+	printf("\nRead TX_RATE\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_TX_RATE_CTRL,0);
+	printf("VR_XS_PMA_GEN5_12G_TX_RATE_CTRL = 0x%08x\n", read_data); */
+
+	/*Read VR_XS_PMA_GEN5_12G_TX_GENCTRL0 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_GENCTRL0 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL0,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_GENCTRL0 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_TX_GENCTRL1 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_GENCTRL1 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_GENCTRL1 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_TX_GENCTRL2 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_GENCTRL2 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_GENCTRL2 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_TX_BOOST_CTRL */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_BOOST_CTRL \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL ,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_BOOST_CTRL = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_TX_RATE_CTRL */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_RATE_CTRL \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL ,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_RATE_CTRL = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_TX_STS */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_STS \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_STS ,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_STS = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_MPLLA_CTRL0 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_MPLLA_CTRL0 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0 ,port);
+	printf("VR_XS_PMA_GEN5_12G_MPLLA_CTRL0 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_MPLLA_CTRL1 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_MPLLA_CTRL1 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL1 ,port);
+	printf("VR_XS_PMA_GEN5_12G_MPLLA_CTRL1 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_MPLLA_CTRL2 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_MPLLA_CTRL2 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2 ,port);
+	printf("VR_XS_PMA_GEN5_12G_MPLLA_CTRL2 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_MPLLA_CTRL3 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_MPLLA_CTR3 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3 ,port);
+	printf("VR_XS_PMA_GEN5_12G_MPLLA_CTRL3 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_TX_POWER_STATE_CTRL */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_POWER_STATE_CTRL \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_POWER_STATE_CTRL ,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_POWER_STATE_CTRL = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_Gen5_12G_TX_EQ_CTRL0 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_EQ_CTRL0 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 ,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_EQ_CTRL0 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_Gen5_12G_TX_EQ_CTRL1 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_EQ_CTRL1 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 ,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_EQ_CTRL1 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_Gen5_12G_TX_EQ_CTRL2 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_EQ_CTRL2 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL2 ,port);
+	printf("VR_XS_PMA_GEN5_12G_TX_EQ_CTRL2 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_Gen5_12G_TX_EQ_CTRL3 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_TX_EQ_CTRL3 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL3 ,port);
+	printf("VR_XS_PMA_Gen5_12G_TX_EQ_CTRL3 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_EQ_INIT_CTRL0 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_EQ_INIT_CTRL0 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_EQ_INIT_CTRL0 ,port);
+	printf("VR_XS_PMA_GEN5_12G_EQ_INIT_CTRL0 = 0x%08x\n", read_data);
+
+	/*Read VR_XS_PMA_GEN5_12G_EQ_INIT_CTRL1 */
+	printf("\nRead VR_XS_PMA_GEN5_12G_EQ_INIT_CTRL1 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_EQ_INIT_CTRL1 ,port);
+	printf("VR_XS_PMA_GEN5_12G_EQ_INIT_CTRL1 = 0x%08x\n", read_data);
+
+}
+
+u32 get_reset_bit_status(u32 regoff, u32 bitn)
+{
+	int rst_bit;
+	rst_bit = GET_N_BITS(REG32(RCU_MODULE_BASE + regoff), bitn, 1);
+	return rst_bit;
+}
+
+void serdes_cal_ovrd(int port)
+{
+	int i;
+	u32 val;
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_cr_base = combo_phy_cr_base(paddr, port);
+
+	/* val = REG32(phy_cr_base + (0x0a << 2));
+	val &= ~BIT(3);
+	REG32(phy_cr_base + (0x0a << 2)) = val;
+	udelay(100); */
+
+	for (i = 0; i < 5000; i++) {
+		val = REG32(phy_cr_base + (0x0e << 2));
+
+		val &= ~BIT(2);
+		val |= BIT(3) | BIT(4);
+		REG32(phy_cr_base + (0x0e << 2)) = val;
+		val = REG32(phy_cr_base + (0x0e << 2));
+		/* TODO: fix this */
+		if (((val & 0x18) == 0x18) &&
+			!!(REG32(phy_cr_base + (0x2014 << 2)) & BIT(0)))
+			break;
+		udelay(10);
+	}
+
+	if (i >= PCIE_PHY_POLL_CNT) {
+		LGM_NET_DBG(" SUP_DIG_SUP_OVRD_IN_0 0x%08x\n", REG32(phy_cr_base + (0x0e << 2))); /* SUP_DIG_SUP_OVRD_IN_0 0x0e << 2 = 0x38 */
+		LGM_NET_DBG(" SUP_DIG_SUP_OVRD_IN_0 cnt %d\n", i);
+	}
+	/* RAWLANEN_DIG_AON_INIT_PWRUP_DOWN */
+	val = REG32(phy_cr_base + (0x2014 << 2)); /* RAWCMN_DIG_FW_PWRUP_DONE 0x2014 << 2 = 0x8050 */
+	/* TODO: fix this */
+	LGM_NET_DBG("RAWLANEN_DIG_AON_INIT_PWRUP_DOWN PWR_DONE %d\n", !!(val & BIT(0)));
+
+	for (i = 0; i < PCIE_PHY_POLL_CNT; i++) {
+		/* TODO: fix this */
+		if (!!(REG32(phy_cr_base + (0x203b << 2)) & BIT(1))) /* RAWCMN_DIG_AON_CMNCAL_STATUS 0x203b <<2 - 0x80ec */
+			break;
+		udelay(5);
+	}
+	if (i >= PCIE_PHY_POLL_CNT) {
+		LGM_NET_DBG("[PHY Workaround] COMBO PHY%d calibration failed\n", port);
+	} else {
+		LGM_NET_DBG("[PHY Workaround] COMBO calibration cnt %d\n", i);
+		LGM_NET_DBG("[PHY Workaround] COMBO PHY%d calibration succeed\n", port);
+	}
+	return;
+}
+
+void serdes_dig_ovrd(int port)
+{
+	int i;
+	u32 val;
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	u32 phy_cr_base = combo_phy_cr_base(paddr, port);
+
+/* 	val = REG32(phy_cr_base + (0x0a << 2));
+	val &= ~BIT(3);
+	REG32(phy_cr_base + (0x0a << 2)) = val;
+	udelay(100); */
+
+	for (i = 0; i < PCIE_PHY_POLL_CNT; i++) {
+		val = REG32(phy_cr_base + (0x0e << 2));
+
+		val &= ~BIT(2);
+		val |= BIT(3) | BIT(4);
+		REG32(phy_cr_base + (0x0e << 2)) = val;
+		val = REG32(phy_cr_base + (0x0e << 2));
+		if (((val & 0x18) == 0x18) &&
+			!!(REG32(phy_cr_base + (0x2014 << 2)) & BIT(0)))
+			break;
+		udelay(10);
+	}
+	if (i >= PCIE_PHY_POLL_CNT)
+		LGM_NET_DBG(" SUP_DIG_SUP_OVRD_IN_0 0x%08x\n", REG32(phy_cr_base + (0x0e << 2)));
+	LGM_NET_DBG(" SUP_DIG_SUP_OVRD_IN_0 cnt %d\n", i);
+	/* RAWLANEN_DIG_AON_INIT_PWRUP_DOWN */
+	val = REG32(phy_cr_base + (0x2014 << 2));
+		/* TODO: fix this */
+	LGM_NET_DBG("RAWLANEN_DIG_AON_INIT_PWRUP_DOWN PWR_DONE %d\n",
+		!!(val & BIT(0)));
+
+	for (i = 0; i < PCIE_PHY_POLL_CNT; i++) {
+		/* TODO: fix this */
+		if (!!(REG32(phy_cr_base + (0x203b << 2)) & BIT(1)))
+			break;
+		udelay(5);
+	}
+	if (i >= PCIE_PHY_POLL_CNT)
+		printf("COMBO PHY%d calibration failed\n", port);
+	else {
+		LGM_NET_DBG("COMBO calibration cnt %d\n", i);
+		LGM_NET_DBG("COMBO PHY%d calibration succeed\n", port);
+	}
+	return;
+}
+
+void vr_reset_poll(int port)
+{
+	unsigned int timeout = 2000;
+	int i;
+	u32 val;
+
+	val = indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, port);
+	for (i = 0; i < timeout; i++) {
+		if (!(val & VR_RESET)) {
+			LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 0x%08x BIT15 VR_RST %s\n",
+				val, (val & VR_RESET)? "set": "clr");
+			break;
+		}
+		val = indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, port);
+		udelay(10);
+	}
+
+	if (i >= timeout)
+		printf("XPCS%d VR RESET Failed\n", port);
+	else
+		LGM_NET_DBG("XPCS%d VR RESET succeed\n", port);
+}
+
+
+void vr_reset(int port, int base1000x)
+{
+	int i;
+	u32 val;
+
+	LGM_NET_DBG("\ntriggering VR reset\n");
+		indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	LGM_NET_DBG("VR_RST BIT15 = 0x%08x\n", read_data);
+	read_data   = read_data | 0x8000; /*triggering VR reset */
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,read_data,port);
+
+	sram_init_chk(port, base1000x);
+
+	/*Re-calibate workaround for Resistor Tuning Calibration. */
+	if(port == WAN_XPCS4){
+		serdes_dig_ovrd(port);
+		mdelay(100);
+	}
+
+	val = indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, port);
+	for (i = 0; i < VR_RESET_CNT; i++) {
+		if (!(val & VR_RESET)) {
+			LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 0x%08x BIT15 VR_RST %s\n",
+				val, (val & VR_RESET)? "set": "clr");
+			break;
+		}
+		udelay(10);
+		val = indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, port);
+	}
+
+	if (i >= VR_RESET_CNT)
+		printf("XPCS VR RESET Failed\n");
+	else {
+		LGM_NET_DBG("XPCS VR RESET succeed\n");
+	}
+
+	LGM_NET_DBG("\nChecking rx tx stable\n");
+	indirect_pcs_rd(VR_XS_PCS_DIG_STS,port); /*passing xpcs port num */
+
+	LGM_NET_DBG("PSEQ_STATE BIT4:2 = 0x%08x\n", read_data);
+	LGM_NET_DBG("\n[WHILE] check for tx, rx are stable\n");
+	check_rxtx_stable(port);
+}
+
+void KR_workaround(int port)
+{
+	/*Workaround set TX_CLK_RDY_0 BIT12 to 0x1 */
+	LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 register for TX_CLK_RDY_0 BIT12 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 Set TX_CLK_RDY_0[12] = 0x%08x\n", read_data);
+	/* read_data &= 0xFFFFEFFF; TX_CLK_RDY_0 BIT12 = 0 */
+	read_data |= 0x1 <<12; /*TX_CLK_RDY_0 BIT12 = 1 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 Set TX_CLK_RDY_0[12] = 0x%08x\n", read_data);
+
+	/*Workaround set SUPPRESS_LOS_DET BIT4 and RX_DT_EN_CTL BIT6 to 0x1. */
+	LGM_NET_DBG("\nWriting to VR_XS_PCS_DEBUG_CTRL register for SUPPRESS_LOS_DET BIT4 and RX_DT_EN_CTL BIT6 \n");
+	indirect_pcs_rd(VR_XS_PCS_DEBUG_CTRL,port);
+	LGM_NET_DBG("[RD]VR_XS_PCS_DEBUG_CTRL Set SUPPRESS_LOS_DET BIT[4] and RX_DT_EN_CTL BIT[6] = 0x%08x\n", read_data);
+	read_data |= 0x1 <<4; /*SUPPRESS_LOS_DET	 BIT4 = 1 */
+	read_data |= 0x1 <<6; /*RX_DT_EN_CTL		 BIT6 = 1 */
+	indirect_pcs_wr(VR_XS_PCS_DEBUG_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PCS_DEBUG_CTRL,port);
+	LGM_NET_DBG("[WR]VR_XS_PCS_DEBUG_CTRL Set SUPPRESS_LOS_DET BIT[4] and RX_DT_EN_CTL BIT[6] = 0x%08x\n", read_data);
+
+}
+
+void cl37_autoneg(int port)
+{
+	/*Clause 37 Auto-negotiation Setup*/
+	/*Configuration of Auto-negotiation Settings. */
+	printf("\nConfiguration of CL37 Auto-negotiation Settings.\n");
+
+	/*Clause37 Auto-negotiation Setup */
+
+	/*Disable C73 Auto-negotiation */
+	/*SR_AN_CTRL BIT12 AN_EN */
+	printf("\nSet SR_AN_CTRL Setting BIT12 AN_EN = 1'b0 to disable C73 autoneg\n");
+	indirect_pcs_rd(SR_AN_CTRL,port);
+	indirect_pcs_wr(SR_AN_CTRL,(read_data &0xFFFFEFFF),port);
+	indirect_pcs_rd(SR_AN_CTRL,port);
+	printf("[WR]Set SR_AN_CTRL Setting BIT12 AN_EN = 0x%08x\n", read_data);
+
+	/*Enable Backplane CL37 autoneg */
+	/*VR_XS_PCS_DIG_CTRL1 Setting AN_ENABLE BIT12 = 1 */
+	printf("\nSet VR_XS_PCS_DIG_CTRL1 Setting AN_ENABLE BIT12 = 1 to enable BP CL37 Autoneg\n");
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,(read_data | 0x1000),port);
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	printf("[WR]VR_XS_PCS_DIG_CTRL1 Setting AN_ENABLE BIT12 = 0x%08x\n", read_data);
+
+	/*Disable CL37 autoneg first SR_MII_CTRL Setting AN_ENABLE BIT12 = 0 */
+	printf("\nSet SR_MII_CTRL Setting AN_ENABLE BIT12 = 0 to enable CL37 Autoneg\n");
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	/*indirect_pcs_wr(SR_MII_CTRL,(read_data & 0xFFFFEFFF),port); */
+	indirect_pcs_wr(SR_MII_CTRL,(read_data & 0xEFFF),port);
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	printf("[WR]SR_MII_CTRL Setting AN_ENABLE BIT12 = 0x%08x\n", read_data);
+
+	/*Program Various field of VR_MII_AN_CTRL register */
+	/*Set SGMII Mode for 1G */
+	/*VR_MII_AN_CTRL
+	BIT0	 MII_AN_INTR_EN = 1b to enable Complete Interrupt Enable.
+	BIT2:1  PCS_MODE = 10b for SGMII mode
+	BIT3	 TX_CONFIG = 1b; 0b for DWC_xpcs as MAC side, 1b for PHY side
+	BIT4	SGMII_LINK_STS = 0b Link Down; 1b Link Up
+	BIT8	 MII_CTRL = 1b for 8-BIT MII*/
+	printf("\nSet VR_MII_AN_CTRL Setting MII_AN_INTR_EN BIT0 = 1'b1 PCS_MODE BIT2:1 = 2'b10, TX_CONFIG BIT3 = 1'b1\n");
+	indirect_pcs_rd(VR_MII_AN_CTRL,port);
+	read_data = read_data & 0xFFFFFF70;
+	/*indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x010d),port); //For PHY. try 0x0105 for MAC side. */
+	indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x0105),port); /*For MAC. try 0x010d for PHY side. */
+	indirect_pcs_rd(VR_MII_AN_CTRL,port);
+	printf("[WR] Enabling PCS mode VR_MII_AN_CTRL = 0x%08x\n", read_data);
+
+
+	/*Enable if TX_CONFIG is 1 (PHY SIDE) */
+	/*Configure VR_MII_DIG_CTRL1 BIT0 to 1. DWC_xpcs adveritses the values of input ports xpcs_sgmii_link_sts_i, xpcs_sgmii_link_speed_i and
+	xpcs_sgmii_full_duplex_i during SGMII/(Port0)QSGMII autonegotiation.*/
+	printf("\nSet VR_MII_DIG_CTRL1 MAC_AUTO_SW BIT0 = 1 for DWC_xpcs adveritses the values of input ports \n");
+	indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+	indirect_pcs_wr(VR_MII_DIG_CTRL1,(read_data | 0x0001),port);
+	indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+	printf("[WR]VR_MII_DIG_CTRL1 Setting MAC_AUTO_SW BIT9 = 0x%08x\n", read_data);
+
+
+	/*Configure SR_MII_AN_ADV BIT5 FD to 1 for Full duplex */
+	printf("\nConfigure SR_MII_AN_ADV BIT5 FD to 1 for Full duplex\n");
+	indirect_pcs_rd(SR_MII_AN_ADV,port);
+	indirect_pcs_wr(SR_MII_AN_ADV,(read_data | 0x0200),port);
+	indirect_pcs_rd(SR_MII_AN_ADV,port);
+	printf("[WR]VR_MII_DIG_CTRL1 Setting MAC_AUTO_SW BIT9 = 0x%08x\n", read_data);
+
+   /* (Optional step) Duration of link timer can be changed (default setting corresponds to 1.6ms) by
+	  programming VR_MII_LINK_TIMER_CTRL Register suitably and by setting bit [3] of
+	  VR_MII_DIG_CTRL1 Register to 1.
+
+	  For configurations without USXGMII:This field forms the upper
+	  16-bit of the 24-bit value that gets loaded to the link timer.The lower
+	  8-bits are hardcoded as 8'h7D. For example, if CL37_LINK_TIME =
+	  1, the value that is loaded to the timer is 24'h17D, which
+	  corresponds to a duration of 3048 ns (381*8ns).
+
+   */
+	/*SR_MII_CTRL Setting AN_ENABLE BIT12 = 1 */
+	printf("\nSet SR_MII_CTRL Setting AN_ENABLE BIT12 = 1 to enable CL37 Autoneg\n");
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	/*indirect_pcs_wr(SR_MII_CTRL,(read_data & 0xFFFFEFFF),port); */
+	indirect_pcs_wr(SR_MII_CTRL,(read_data | 0x1000),port);
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	printf("[WR]SR_MII_CTRL Setting AN_ENABLE BIT12 = 0x%08x\n", read_data);
+
+}
+
+
+/*TX EQ Override in XPCS */
+void tx_eq_config(int port, struct tx_eq *txeq)
+{
+	/*Setting TX EQ_MAIN, EQ_PRE, EQ_POST */
+
+	/*Set VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 TX_EQ_PRE BIT5:0, TX_EQ_MAIN BIT13:8 */
+	LGM_NET_DBG("\nSet VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 EQ_PRE BIT5:0, EQ_MAIN BIT13:8 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 ,port);
+	/*Clear BITS */
+	read_data &= ~(0x3F << 0); /*Clear BIT5:0 EQ_PRE */
+	read_data &= ~(0x3F << 8); /*Clear BIT13:8 EQ_MAIN */
+
+	/*Set TX EQ Values */
+	read_data |= (txeq->tx_pre_cursor) << 0; /*Set BIT5:0 EQ_PRE */
+	read_data |= (txeq->tx_main_cursor) << 8; /*SetBIT13:8 EQ_MAIN */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 ,port);
+	LGM_NET_DBG("VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 = 0x%08x\n", read_data);
+
+	/*Set VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 TX_EQ_POST BIT5:0, TX_EQ_OVR_RIDE BIT6 */
+	LGM_NET_DBG("\nRead VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 TX_EQ_POST BIT5:0, TX_EQ_OVR_RIDE BIT6 \n");
+	/*Clear BITS */
+	read_data &= ~(0x3F << 0); /*Clear BIT5:0 EQ_PRE */
+	read_data &= ~(0x1 << 6); /*Clear BIT6 EQ_MAIN */
+
+	/*Set TX EQ Values */
+	read_data |= (txeq->tx_post_cursor) << 0; /*Set BIT5:0 TX_EQ_POST */
+	read_data |= (0x1) << 6; /*Set BIT6 TX_EQ_OVR_RIDE */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,read_data,port);
+
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 ,port);
+	LGM_NET_DBG("VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 = 0x%08x\n", read_data);
+
+	/*Change TX IBOOST_LVL to higher from 0x5 to 0xF */
+	LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL register for TX0_IBOOST[3:0] = 0xF \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL ,port);
+	/*Clear BITS */
+	read_data &= ~(0xF << 0); /*Clear BIT3:0 TX0_IBOOST */
+
+	/*Set TX IBOOST Values */
+	read_data |= (txeq->tx_iboost_lvl) << 0; /*Set BIT3:0 TX0_IBOOST */
+
+	/*read_data = read_data & 0xFFFFFFF0; */
+	/*read_data |= 0xF << 0; Setting TX0_IBOOST[3:0] = 0xF  */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL ,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL TX0_IBOOST[3:0]  = 0x%08x\n", read_data);
+
+}
+
+
+/*Check RX/TX stable function */
+void check_rxtx_stable(int port)
+{
+	int i;
+	u32 vr_rst_data, stable_data;
+
+	LGM_NET_DBG("\nCheck PMA Power Up Sequence STATE Stable\n");
+	for (i = 0; i < CHECK_TIMEOUT; i++) {
+		indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, port);
+		vr_rst_data = read_data;
+
+		/*Check VR_RST BIT15 is = 0 where VR_RST is de-assert. */
+		if ((vr_rst_data & 0x8000) == 0x0000) {
+			/*printf("\nVR_RST de-asserted.\n"); */
+			indirect_pcs_rd(VR_XS_PCS_DIG_STS,port);
+			stable_data = read_data;
+			/*printf("PSEQ_STATE BIT4:2 = 0x%08x\n", stable_data); */
+			if ((stable_data & 0x1c) == 0x10) {
+				/*dprint_enable = 1; */
+				indirect_pcs_rd(VR_XS_PCS_DIG_STS,port);
+				LGM_NET_DBG("PSEQ_STATE BIT4:2 = 0x%08x\n", read_data);
+				break;
+			}
+		}
+		udelay(10);
+	}
+
+	if (i >= CHECK_TIMEOUT) {
+		pass_flag = 0;
+		LGM_NET_DBG("PHY port %d TX/RX Stable TIMEOUT\n", port);
+		indirect_pcs_rd(VR_XS_PCS_DIG_STS,port);
+		LGM_NET_DBG("PSEQ_STATE BIT4:2 = 0x%08x\n", read_data);
+	} else {
+		pass_flag = 1;
+		LGM_NET_DBG("PHY TX/RX Stable cnt %d\n", i);
+		LGM_NET_DBG("PHY port %d TX/RX Stable\n", port);
+	}
+}
+
+u32 serdes_cr_write(int port, u32 addr, u32 data)
+{
+	int i;
+	u32 read_data;
+
+	/*Wait for BIT0 START_BUSY to becomes 0 = not busy */
+	for (i = 0; i < CR_PORT_BUSY_TIMEOUT; i++) {
+		if (indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port) && ~BIT(0))
+			break;
+		udelay(10);
+	}
+
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_ADDR, addr, port); /*Set CR Address to access */
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_DATA, data, port); /*Set CR Data to write */
+
+	/*Start Write Process */
+	read_data = indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port);
+	read_data = SET_DATA_BITS(read_data, 1, 1, 0x1); /*Set BIT1 to enable write access */
+	read_data = SET_DATA_BITS(read_data, 0, 1, 0x1); /*Set BIT0 to start port access */
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_CTRL, read_data, port);
+
+	for (i = 0; i < CR_PORT_BUSY_TIMEOUT; i++) {
+		if (indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port) && ~BIT(0))
+			break;
+		udelay(10);
+	}
+
+	return 0;
+}
+
+
+u32 serdes_cr_read(int port, u32 addr)
+{
+	int i;
+	u32 read_data;
+
+	/*Wait for BIT0 START_BUSY to becomes 0 = not busy */
+	for (i = 0; i < CR_PORT_BUSY_TIMEOUT; i++) {
+		if (indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port) && ~BIT(0))
+			break;
+		udelay(10);
+	}
+
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_ADDR, addr, port); /*Set CR Address to access */
+
+	/*Start Read Process */
+	read_data = indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port);
+	read_data = SET_DATA_BITS(read_data, 1, 1, 0x0); /*Set BIT1 to enable read access */
+	read_data = SET_DATA_BITS(read_data, 0, 1, 0x1); /*Set BIT0 to start port access */
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_CTRL, read_data, port);
+
+	for (i = 0; i < CR_PORT_BUSY_TIMEOUT; i++) {
+		if (indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port) && ~BIT(0))
+			break;
+		udelay(10);
+	}
+
+	read_data = indirect_pcs_rd(VR_XS_PMA_SNPS_CR_DATA, port); /*Read Data from CR */
+
+	return read_data;
+}
+
+int xpcs_rst_stat(int port)
+{
+	int stat = 0;
+
+	udelay(1);
+	if (port == COMBO_PORT10) {
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE10_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE10_PCS);
+		/*printf("HSIOL_STAT STAT_PCIE10_PCS Reset BIT12 = %d\n", stat); */
+	} else if(port == COMBO_PORT11) {
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE11_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE11_PCS);
+		/*printf("HSIOL_STAT STAT_PCIE11_PCS Reset BIT13 = %d\n", stat); */
+	} else if(port == COMBO_PORT20) {
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE20_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE20_PCS);
+		/*printf("HSIOR_STAT STAT_PCIE20_PCS Reset BIT12 = %d\n", stat); */
+	} else if(port == COMBO_PORT21) {
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE21_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE21_PCS);
+		/*printf("HSIOR_STAT STAT_PCIE21_PCS Reset BIT13 = %d\n", stat); */
+	} else if(port == P34X_PORT5) {
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_PCS0);
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_PCS0);
+		/*printf("ETHNOC_STAT STAT_XPCS5_PCS0 Reset BIT15 = %d\n", stat); */
+	}
+	return stat;
+}
+
+int xpcs_rst_assert(int port)
+{
+	if (port == COMBO_PORT10) {
+		set_reset(RST_REQ_HSIOL, REQ_PCIE10_PCS);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE10_PCS Reset BIT12 Asserted\n");
+	} else if (port == COMBO_PORT11) {
+		set_reset(RST_REQ_HSIOL, REQ_PCIE11_PCS);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE11_PCS Reset BIT13 Asserted\n");
+	} else if (port == COMBO_PORT20) {
+		set_reset(RST_REQ_HSIOR, REQ_PCIE20_PCS);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE20_PCS Reset BIT12 Asserted\n");
+	} else if (port == COMBO_PORT21) {
+		set_reset(RST_REQ_HSIOR, REQ_PCIE21_PCS);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE21_PCS Reset BIT13 Asserted\n");
+	} else if (port == P34X_PORT5) {
+		set_reset(RST_REQ_ETHNOC, REQ_XPCS5_PCS0);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_PCS0 Reset BIT15 Asserted\n");
+	}
+	return 0;
+}
+
+int xpcs_rst_deassert(int port)
+{
+	if (port == COMBO_PORT10) {
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE10_PCS);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE10_PCS Reset BIT12 Deasserted\n");
+	} else if (port == COMBO_PORT11) {
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE11_PCS);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE11_PCS Reset BIT13 Deasserted\n");
+	} else if (port == COMBO_PORT20) {
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE20_PCS);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE20_PCS Reset BIT12 Deaserted\n");
+	} else if (port == COMBO_PORT21) {
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE21_PCS);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE21_PCS Reset BIT13 Deasserted\n");
+	} else if (port == P34X_PORT5) {
+		clear_reset(RST_REQ_ETHNOC, REQ_XPCS5_PCS0);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_PCS0 Reset BIT15 Deasserted\n");
+	}
+
+	return 0;
+}
+
+//10g serdes bring up
+static void xfi_10g5g2p5g_kr_serdes_bringup(int port, int speed)
+{
+	u32 value;
+	int mpll_cfg_x2_xpcs_port, tx_preset_id = 0, rx_preset_id = 0;
+	struct tx_eq *txeq;
+	struct rx_eq *rxeq;
+
+	if(speed == KR_10G){
+		tx_preset_id = TX_PRST_7;
+		rx_preset_id = RX_10G;
+		if (port == XPCS5){
+			tx_preset_id = TX_PRST_4;
+			rx_preset_id = RX_10G_SHORT;
+		}
+	} else if(speed == KR_5G) {
+		tx_preset_id = TX_PRST_5;
+		rx_preset_id = RX_5G;
+	} else if(speed == KR_2P5G) {
+		tx_preset_id = TX_2P5G_CUSTOM;
+		rx_preset_id = RX_2P5G;
+	} else if(speed == BASER_10G) {
+		if (port == XPCS5) {
+			tx_preset_id = TX_10G_SHORT;
+			rx_preset_id = RX_10G_SHORT;
+		}
+	}
+
+	txeq = &tx_presets[tx_preset_id];
+	rxeq = &rx_presets[rx_preset_id];
+
+	//SERDES Bringup sequence starts
+	LGM_NET_DBG("\nPort%d SERDES Bringup sequence starts\n", port);
+
+	LGM_NET_DBG("TX PRESET\t:%d\nRX PRESET\t:%d \n", tx_preset_id, rx_preset_id);
+
+	//Set PCS type to 01 -10GBASE-R PCS Type
+	//SR_XS_PCS_CTRL2
+	LGM_NET_DBG("\nSet SR_XS_PCS_CTRL2 Bit 1:0 PCS Type = 0\n");
+	indirect_pcs_rd(SR_XS_PCS_CTRL2,port);
+	if (speed == KR_10G) {
+		read_data = read_data & 0xFFFFFFF0; //Clear Bit3:0 equals to zero.
+	} else if (speed == KR_5G) {
+		read_data = read_data & 0xFFFFFFF0; //Clear Bit3:0 equals to 0xF.
+		read_data |= 0x000F; //Set to 4'b1111.
+	} else if (speed == BASER_10G) {
+		read_data = read_data & 0xFFFFFFF0; //Clear Bit3:0 equals to 0xF.
+		read_data |= 0x0001; //Set to 4'b0001. to BASE-R mode
+	}
+
+	indirect_pcs_wr(SR_XS_PCS_CTRL2,(read_data),port);
+	indirect_pcs_rd(SR_XS_PCS_CTRL2,port);
+	LGM_NET_DBG("[WR]SR_XS_PCS_CTRL2 (0x%08x) Bit 1:0 PCS Type = 0x%08x\n", SR_XS_PCS_CTRL2, read_data);
+
+	// ##### PMA MPLLA Configuration ######
+	LGM_NET_DBG("########### PMA MPLLA Configuration ############ \n");
+	if (port == XPCS1)
+		mpll_cfg_x2_xpcs_port = XPCS0;
+	else if (port == XPCS3)
+		mpll_cfg_x2_xpcs_port = XPCS2;
+	else
+		mpll_cfg_x2_xpcs_port = port;
+
+	LGM_NET_DBG("mpll_cfg_x2_xpcs_port\t: %d\n", mpll_cfg_x2_xpcs_port);
+
+	//writing to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT 5:3, REF_MPLLA_DIV2 BIT6
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT and REF_MPLLA_DIV2\n");
+	value = 0x0;
+	value |= 0x1 << 0; //REF_CLK_EN BIT0 = 1h
+	if(ref_use_pad == 0)
+		value &= ~(0x1 << 1); //REF_USE_PAD BIT1 = 0h
+	else if(ref_use_pad == 1)
+		value |= 0x1 << 1; //REF_USE_PAD BIT1 = 1h use external pad for clock. Only applicable for serdes HSIOL_1
+	value &= ~(0x1 << 2); //REF_CLK_DIV2 = 0h
+
+	if (port == PON_WAN_PORT4 && pon_eth_sel == PON_MODE)
+		value |= 0x5 << 3; //REF_RANGE BIT5:3 = 3'b101: 130.1 - 156 MHz PON CLOCK
+	else
+		value |= 0x6 << 3; //REF_RANGE BIT5:3 = 3'b110: 156.1 - 182 MHz ETH CLOCK
+
+	value |= 0x1 << 6; //REF_MPLLA_DIV2 BIT6
+	//value &= ~(0x1 << 7); //REF_MPLLB_DIV2 BIT7
+	value &= ~(0x1 << 8); //REF_RPT_CLK_EN BIT8 //Disable now as Verification team did not enable this. It was enable in FLM.
+	//value |= 0x1 << 8; //REF_RPT_CLK_EN BIT8 //Disable now as Verification team did not enable this. It was enable in FLM.
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,value,mpll_cfg_x2_xpcs_port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL for BIT5:3 REF_RANGE BIT and BIT6 REF_MPLLA_DIV2= 0x%08x\n", read_data);
+
+	//Set MPLLA_MULTIPLIER
+	LGM_NET_DBG("\nWriting MPLLA_MULTIPLIER register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,mpll_cfg_x2_xpcs_port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,0x0021,mpll_cfg_x2_xpcs_port); //Setting BIT7:0 = 8'd33 = 2'h21
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0 Setting MPLLA_MULTIPLIER bit7:0 = 0x%08x\n", read_data);
+
+	//Set MPLLA_BANDWIDTH
+	LGM_NET_DBG("\nWriting MPLLA_BANDWIDTH register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,mpll_cfg_x2_xpcs_port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,0xA016,mpll_cfg_x2_xpcs_port); //Setting BIT15:0 = 16'd40982(databook 41022) = 4'hA016 (A03E)
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_MPLLA_CTRL3 Setting MPLLA_BANDWIDTH bit15:0 = 0x%08x\n", read_data);
+
+	//writing to MPLLA_CTRL2 register for MPLLA_DIV_MULT BIT6:0, MPLLA_DIV_CLK_EN BIT7
+	LGM_NET_DBG("\nwriting to MPLLA_CTRL2 register for MPLLA_DIV_MULT\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,mpll_cfg_x2_xpcs_port);
+	read_data |= 0x1 << 8; 		// BIT8 MPLLA_DIV8_CLK_EN 		= 1h
+	read_data &= ~(0x1 << 9); 	// BIT9 MPLLA_DIV10_CLK_EN		= 0h
+	read_data |= 0x1 << 10; 	// BIT10 MPLLA_DIV16P5_CLK_EN 	= 1h
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,read_data,mpll_cfg_x2_xpcs_port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2 Setting MPLLA DIV8/DIV10/DIV16P5 bits10:8 = 0x%08x\n", read_data);
+
+	//Change TX VBOOST_LVL to 0x5
+	LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1  register for TX VBOOST_LVL[10:8] \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_LVL[10:8] = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFF8FF;
+	read_data |= (txeq->tx_vboost_lvl) << 8; //Setting VBOOST_LVL BIT[10:8] = Default 0x5 after reset. VBOOST_EN_0 = 0x1 set later in lane specific
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,mpll_cfg_x2_xpcs_port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_LVL[10:8] = 0x%08x\n", read_data);
+
+	// ##### PMA LANE Configuration ######
+	LGM_NET_DBG("########### PMA LANE Configuration ############ \n");
+	//Writing to VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL
+	//BIT0 		MPLL_EN_0		= Set only if XPCS0, XPCS2, XPCS4, XPCS5
+	//BIT3:1 	MPLL_EN_3_1		= Set LANE1 BIT1 only if XPCS1, XPCS3, RXAUI on
+	//BIT4 		MPLLB_SEL_0 	= Set only if 1G of XPCS0, XPCS2
+	//BIT7:5 	MPLLB_SEL_3_1	= Set LANE1 BIT1 only if 1G of XPCS1, XPCS3.
+	LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+	//read_data &= ~(0xFF<<0); //Clear BIT7:0
+	read_data |= 0x1 << 0; 	 // BIT0 MPLL_EN_0			= 1h
+	//read_data |= 0x0 << 4; 	 // BIT4 MPLLB_SEL_0		= 1h
+
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL Setting BIT0 MPLL_EN_0, BIT4 MPLLB_SEL0, BIT1 MPLL_EN_1, BIT5 MPLLB_SEL_1 = 0x%08x\n", read_data);
+
+
+	//RX VCO configuration
+	//writing to VR_XS_PMA_GEN5_12G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0
+	LGM_NET_DBG("\nwriting to PHY LANE0 VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0\n");
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,0x0549,port); //13'd1353 = 3'h549
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0= 0x%08x\n", read_data);
+
+	//writing to VR_XS_PMA_GEN5_12G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT6:0 and VCO_REF_LD_0 BIT14:8
+	LGM_NET_DBG("\nwriting to PHY LANE0 VR_XS_PMA_GEN5_16G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT5:0 and VCO_REF_LD_0 BIT13:8\n");
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,0x0029,port); //6'd41 = 2'h29
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT5:0 and VCO_REF_LD_0 BIT13:8= 0x%08x\n", read_data);
+
+	//configuring RX_EQ_CTRL4 register for CONT_ADAPT_0 = 1
+	LGM_NET_DBG("\nconfiguring RX_EQ_CTRL4 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,(read_data | 0x0001),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port);
+	LGM_NET_DBG("[WR]EQ_CTRL4 register CONT_ADAPT_0 BIT0= 0x%08x\n", read_data);
+
+	//Writing TX Rate
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_TX_RATE_CTRL register for TX0_RATE BIT2:0\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL TX0_RATE BIT2:0 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFFFF8; //bit[2:0] = 3'b000 : baud
+	if (speed == KR_10G)
+		read_data |= 0x0 << 0; //10G
+	else if (speed == KR_5G)
+		read_data |= 0x1 << 0; //5G
+	else if (speed == KR_2P5G)
+		read_data |= 0x2 << 0; //2.5G
+	//LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL TX0_RATE BIT2:0 = 0x%08x\n", read_data);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL TX0_RATE BIT2:0= 0x%08x\n", read_data);
+
+	//Change to RX Rate
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL register for RX0_RATE BIT2:0\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL RX0_RATE BIT1:0 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFFFFC; //bit[2:0] = 0 //2'b00 : baud
+	if (speed == KR_10G)
+		read_data |= 0x0 << 0; //10G
+	else if (speed == KR_5G)
+		read_data |= 0x1 << 0; //5G
+	else if (speed == KR_2P5G)
+		read_data |= 0x2 << 0; //2.5G
+	//LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL RX0_RATE BIT1:0 = 0x%08x\n", read_data);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL RX0_RATE BIT1:0 = 0x%08x\n", read_data);
+
+	//Change TX Width
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 register for TX0_WIDTH BIT9:8\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 TX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFFCFF; //bit[9:8] = 10 //2'b10: 16-bit; 2'b11: 20-bit
+	read_data |= 0x2 << 8; //bit[9] = 1;bit[8] = 0 //2'b10: 16-bit; 2'b11: 20-bit
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 TX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+
+	//Change RX Width
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2 register for RX0_WIDTH BIT9:8\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2 RX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFFCFF; //bit[9:8] = 10 //2'b10: 16-bit; 2'b11: 20-bit
+	read_data |= 0x2 << 8; //bit[9] = 1;bit[8] = 0 //2'b10: 16-bit; 2'b11: 20-bit
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2  RX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+
+	//Change Enable TX VBOOST_EN here as it is per lane configuration
+	LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1	register for VBOOST_EN_0 BIT4 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 ,port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_EN_0 BIT4 = 0x%08x\n", read_data);
+	read_data |= (txeq->tx_vboost_en) << 4; //Setting VBOOST_EN_0 = 0x1.
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 ,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 VBOOST_EN_0 BIT4	= 0x%08x\n", read_data);
+
+	//writing to PHY att_lvl register
+	LGM_NET_DBG("\nwriting to PHY RX attenuation Level register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL BIT2:0 RX0_EQ_ATT_LVL = 0x%08x\n", read_data);
+	//read_data &= 0x000088E0;
+	read_data &= 0x0000FFF8;
+	read_data |= rxeq->rx_att_lvl << 0; //BIT2:0 RX0_EQ_ATT_LVL
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL BIT2:0 RX0_EQ_ATT_LVL = 0x%08x\n", read_data);
+
+	//writing to PHY ctle_pole and boost and gain register
+	LGM_NET_DBG("\nwriting to PHY ctle_pole and boost and gain register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,port);
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0 BIT14:12 VGA1_GAIN_0 BIT10:8 VGA2_GAIN_0	BIT6:5 CTLE_POLE_0 BIT4:0 CTLE_BOOST_0 = 0x%08x\n", read_data);
+	//read_data &= 0x000088E0;
+	read_data &= 0x00008880;
+	read_data |= rxeq->rx_ctle_boost << 0; //BIT4:0 CTLE_BOOST_0		= 16
+	read_data |= rxeq->rx_ctle_pole  << 5; //BIT6:5 CTLE_POLE_0 		= 2
+	read_data |= rxeq->rx_vga2_gain  << 8; //BIT10:8 VGA2_GAIN_0		= 5
+	read_data |= rxeq->rx_vga1_gain  << 12; //BIT14:12 VGA1_GAIN_0		= 5
+	LGM_NET_DBG("[DEBUG] read_data: 0x%08x\n rx_ctle_boost:%d\n rx_ctle_pole:%d\n rx_vga2_gain:%d\n rx_vga1_gain:%d\n",read_data, rxeq->rx_ctle_boost, rxeq->rx_ctle_pole, rxeq->rx_vga2_gain, rxeq->rx_vga1_gain);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0 BIT14:12 VGA1_GAIN_0 BIT10:8 VGA2_GAIN_0	BIT6:5 CTLE_POLE_0 BIT4:0 CTLE_BOOST_0 = 0x%08x\n", read_data);
+
+	//writing to RX PPM CTRL0 register VR_XS_PMA_Gen5_16G_RX_PPM_CTRL0
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port);
+	read_data &= ~(0x1F1F<<0); //Clear BIT12:8 RX1_CDR_PPM_MAX and BIT4:0 RX0_CDR_PPM_MAX
+	read_data |= 18 	<< 0; //BIT4:0 RX0_CDR_PPM_MAX = 18
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0 BIT4:0 RX0_CDR_PPM_MAX= 0x%08x\n", read_data);
+
+	//writing to RX CDR CTRL1 register
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	read_data |= rxeq->rx_vco_temp_comp_en 	<< 0; //BIT0 VCO_TEMP_COMP_EN_0	= 1
+	read_data |= rxeq->rx_vco_step_ctrl 	<< 4; //BIT4 VCO_STEP_CTRL0		= 1
+	read_data |= rxeq->rx_vco_frqband 		<< 8; //BIT9:8 VCO_FRQBAND_0	= 1
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1 BIT9:8 VCO_FRQBAND_0 BIT4 VCO_STEP_CTRL0, BIT0 VCO_TEMP_COMP_EN_0 = 0x%08x\n", read_data);
+
+	//writing to RX_MISC_CTRL0 register
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port);
+	read_data &= 0xFFFFFF00;
+	read_data |= rxeq->rx_misc << 0; //BIT7:0 RX0_MISC	= 2'h12 8'd18
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0 BIT7:0 RX0_MISC = 0x%08x\n", read_data);
+
+	//writing to VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 register
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port);
+	read_data &= ~(0x1F<<8); //Clear BIT12:8 RX_VREF_CTRL
+	read_data |= 17 << 8; //BIT12:8 RX_VREF_CTRL = 8'd17
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 BIT12:8 RX_VREF_CTRL = 0x%08x\n", read_data);
+
+	//writing to VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 register
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 register to clear RX DFE BYPASS\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port);
+	read_data &= ~(1 << 8); //Clear BIT8 RX_DFE_BYP_0
+	read_data |= rxeq->rx_dfe_bypass << 8; //BIT8 RX_DFE_BYP_0	= 0
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT8 RX_DFE_BYP_0 = 0x%08x\n", read_data);
+
+	//writing to VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0 register
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0 register to set RX0_DELTA_IQ\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+	read_data &= 0xFFFFF0FF; //BIT11:8 RX0_DELTA_IQ	= 0
+	read_data |= rxeq->rx_delta_iq << 8; //BIT8 RX0_DELTA_IQ	= 0
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT11:8 RX0_DELTA_IQ = 0x%08x\n", read_data);
+
+	//writing to VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 register
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 register to set RX_ADPT_SEL_0 and RX0_ADPT_MODE\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+	read_data &= ~(0x1 << 0); // Clear BIT0 RX_ADPT_SEL_0
+	read_data &= ~(0x3 << 4); // Clear BIT5:4 RX0_ADPT_MODE
+	read_data |= rxeq->rx_adapt_sel << 0; //BIT0 RX_ADPT_SEL_0	= 0 To Select Bank0 for Adapt
+	read_data |= rxeq->rx_adapt_mode << 4; //BIT5:4 RX0_ADPT_MODE = 3
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 BIT5:4 RX0_ADPT_MODE BIT0 RX_ADPT_SEL_0 = 0x%08x\n", read_data);
+
+	//**Not mentioned in XPCS datasheet but in PHY datasheet.
+	//writing to PHY LOS threshold register
+	LGM_NET_DBG("\nwriting to PHY LOS threshold register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port);
+	read_data &= ~(0x7 << 0); //Clear LOS_TRSHLD_0 BIT2:0
+	read_data |= rxeq->rx_los_threshold << 0; // Set LOS_TRSHLD_0 BIT2:0 = 7
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,0x0007,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3 LOS_TRSHLD_0 BIT2:0	= 0x%08x\n", read_data);
+
+	//writing to VR_XS_PMA_GEN5_16G_MISC_CTRL2 register
+	LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_MISC_CTRL2 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port);
+	read_data &= ~(0xFF<<0); //Clear BIT7:0 SUP_MISC[7:0]
+	read_data |= 0x1 << 0; //BIT7:0 SUP_MISC[7:0] = 1
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MISC_CTRL2,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port);
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_MISC_CTRL2 BIT7:0 SUP_MISC[7:0] = 0x%08x\n", read_data);
+
+	if(port == XPCS0 || port == XPCS2 || port == WAN_XPCS4 || port == XPCS5){
+		//Need to do VR reset before override TX EQ setting
+		vr_reset(port, 0);
+
+		//Setting TX EQ_MAIN, EQ_PRE, EQ_POST
+
+		LGM_NET_DBG("\nConfiguration TX EQ after VR Reset for XPCS%d", port);
+		tx_eq_config(port, txeq);
+
+		LGM_NET_DBG("\nConfiguration 10G KR Workaround for XPCS%d", port);
+		KR_workaround(port);
+
+		if(port == XPCS0 || port == XPCS2){
+			LGM_NET_DBG("\nConfiguration TX EQ after VR Reset for XPCS%d", port+1);
+			tx_eq_config(port+1, txeq);
+
+			LGM_NET_DBG("\nConfiguration 10G KR Workaround for XPCS%d", port);
+			KR_workaround(port+1);
+		}
+	}
+}
+
+static void base_1g_serdes_bringup(int port)
+{
+	u32 value;
+	int mpll_cfg_x2_xpcs_port, tx_preset_id, rx_preset_id;
+
+	tx_preset_id = TX_1G_CUSTOM;
+	rx_preset_id = RX_1G;
+
+	struct tx_eq *txeq = &tx_presets[tx_preset_id];
+	struct rx_eq *rxeq = &rx_presets[rx_preset_id];
+
+	/* SERDES Bringup sequence starts */
+	printf("\n[WHILE] SERDES Bringup sequence starts\n");
+
+	printf("TX PRESET\t:%d\nRX PRESET\t:%d \n", tx_preset_id, rx_preset_id);
+
+	/* Set to XAUI mode. */
+	/* VR_XS_PCS_XAUI_CTRL */
+	printf("\nSet VR_XS_PCS_XAUI_CTRL Bit 0 to XAUI mode = 0\n");
+	indirect_pcs_rd(VR_XS_PCS_XAUI_CTRL,port);
+	indirect_pcs_wr(VR_XS_PCS_XAUI_CTRL,(read_data & 0xFFFFFFFE),port);
+	indirect_pcs_rd(VR_XS_PCS_XAUI_CTRL,port);
+	printf("[WR]VR_XS_PCS_XAUI_CTRL Bit 0 to XAUI mode = 0x%08x\n", read_data);
+
+	/* Set PCS type to 01 -10GBASE-X PCS Type */
+	/* SR_XS_PCS_CTRL2 */
+	printf("\nSet SR_XS_PCS_CTRL2 Bit 1:0 PCS Type = 1\n");
+	indirect_pcs_rd(SR_XS_PCS_CTRL2,port);
+	read_data = read_data & 0xFFFFFFFC; /* Clear Bit1:0 equals to zero. */
+	indirect_pcs_wr(SR_XS_PCS_CTRL2,(read_data | 0x0001),port);
+	indirect_pcs_rd(SR_XS_PCS_CTRL2,port);
+	printf("[WR]SR_XS_PCS_CTRL2 Bit 1:0 PCS Type = 0x%08x\n", read_data);
+
+	/* Setting SS13 bit PMA side */
+	/* pma_type_config(port); */
+	/* SR_PMA_CTRL1 */
+	printf("\nSet SR_PMA_CTRL1 Bit 13 SS13 to  = 0\n");
+	indirect_pcs_rd(SR_PMA_CTRL1,port);
+	indirect_pcs_wr(SR_PMA_CTRL1,(read_data & 0xDFFF),port);
+	indirect_pcs_rd(SR_PMA_CTRL1,port);
+	printf("[WR]SR_PMA_CTRL1 Bit 13 SS13 to 0 = 0x%08x\n", read_data);
+
+	/* Setting SS13 bit of PCS side */
+	/* SR_XS_PCS_CTRL1 */
+	printf("\nSet SR_XS_PCS_CTRL1 Setting SS13 bit = 0\n");
+	indirect_pcs_rd(SR_XS_PCS_CTRL1,port);
+	indirect_pcs_wr(SR_XS_PCS_CTRL1,(read_data & 0xFFFFDFFF),port);
+	indirect_pcs_rd(SR_XS_PCS_CTRL1,port);
+	printf("[WR]SR_XS_PCS_CTRL1 Setting SS13 bit = 0x%08x\n", read_data);
+
+	/* SR_MII_CTRL
+	 * BIT6		SS5
+	 * BIT13	SS13
+	 * For SGMII configurations:
+	 * When SS6=1 and SS13=0, speed is 1000 Mbps
+	 * When SS6=0 and SS13=1, speed is 100 Mbps
+	 * When SS6=0 and SS13=0, speed is 10 Mbps
+	 */
+	printf("\nSet SR_MII_CTRL Setting SS6 BIT6 = 1 and SS13 BIT13 = 0\n");
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	read_data = read_data & 0xFFFFDFBF; /* Clear bit6 and bit13 */
+	read_data |= (1 << 6);
+	read_data &= ~(1 << 13);
+	indirect_pcs_wr(SR_MII_CTRL,read_data,port); /* Set bit6 */
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	printf("[WR]SR_MII_CTRL Setting SS6 BIT6 = 1 and SS13 BIT13 = 0 for 1000Mbps: SR_MII_CTRL = 0x%08x\n", read_data);
+
+/* Disable this as will be configured at the base_1g_bringup function. */
+	/*Set SGMII Mode for 1G */
+	/* VR_MII_AN_CTRL
+	 * BIT0		MII_AN_INTR_EN = 1b to enable Complete Interrupt Enable.
+	 * BIT2:1 	PCS_MODE = 10b for SGMII mode
+	 * BIT3	T	X_CONFIG = 1b
+	 */
+	printf("\nSet VR_MII_AN_CTRL Setting MII_AN_INTR_EN BIT0 = 1'b1 PCS_MODE BIT2:1 = 2'b10, TX_CONFIG BIT3 = 1'b1\n");
+	indirect_pcs_rd(VR_MII_AN_CTRL,port);
+	read_data = read_data & 0xFFFFFFF1;
+	indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x000d),port);
+	indirect_pcs_rd(VR_MII_AN_CTRL,port);
+	printf("[WR]VR_MII_AN_CTRL Setting SS6 bit & SS13 bit = 0x%08x\n", read_data);
+
+	/* ##### PMA MPLLA or MPLLB Configuration ###### */
+	/* Referring to 10G XAUI Mode Gen5 16G PHY Configuration */
+	printf("########### PMA MPLLB Configuration ############ \n");
+	if (port == XPCS1)
+		mpll_cfg_x2_xpcs_port = XPCS0;
+	else if (port == XPCS3)
+		mpll_cfg_x2_xpcs_port = XPCS2;
+	else
+		mpll_cfg_x2_xpcs_port = port;
+
+	printf("mpll_cfg_x2_xpcs_port\t: %d\n", mpll_cfg_x2_xpcs_port);
+
+	if (port < WAN_XPCS4) {
+		/* MPLLB Configuration */
+
+		/* writing to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT 5:3, REF_MPLLB_DIV2 BIT6 */
+		printf("\nwriting to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT and REF_MPLLB_DIV2\n");
+		value = 0x0;
+		value |= 0x1 << 0; /* REF_CLK_EN BIT0 = 1h */
+		if(ref_use_pad == 0)
+			value &= ~(0x1 << 1); /* REF_USE_PAD BIT1 = 0h */
+		else if (ref_use_pad == 1)
+			value |= 0x1 << 1; /* REF_USE_PAD BIT1 = 1h use external pad for clock. Only applicable for serdes HSIOL_1 */
+		value &= ~(0x1 << 2); /* REF_CLK_DIV2 = 0h */
+		if (port == PON_WAN_PORT4 && pon_eth_sel == PON_MODE)
+			value |= 0x5 << 3; /* REF_RANGE BIT5:3 = 3'b101: 130.1 - 156 MHz PON CLOCK */
+		else
+			value |= 0x6 << 3; /* REF_RANGE BIT5:3 = 3'b110: 156.1 - 182 MHz ETH CLOCK */
+		/* value &= ~(0x1 << 6); */ /* REF_MPLLA_DIV2 BIT6 */
+		value |= (0x1 << 7); /* REF_MPLLB_DIV2 BIT7 */
+		value &= ~(0x1 << 8); /* REF_RPT_CLK_EN BIT8*/ /*Disable now as Verification team did not enable this. It was enable in FLM.*/
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,value,mpll_cfg_x2_xpcs_port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,mpll_cfg_x2_xpcs_port);
+		printf("[WR]VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL for BIT5:3 REF_RANGE BIT and BIT6 REF_MPLLA_DIV2= 0x%08x\n", read_data);
+
+		/* Set MPLLB_MULTIPLIER */
+		printf("\nWriting MPLLB_MULTIPLIER register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,mpll_cfg_x2_xpcs_port);
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,0x0030,mpll_cfg_x2_xpcs_port); /* Setting BIT7:0 = 8'd48 = 2'h30 */
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,mpll_cfg_x2_xpcs_port);
+		printf("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0 Setting MPLLB_MULTIPLIER bit7:0 = 0x%08x\n", read_data);
+
+		/* Set MPLLB_BANDWIDTH */
+		printf("\nWriting MPLLB_BANDWIDTH register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLB_CTRL3,mpll_cfg_x2_xpcs_port);
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLB_CTRL3,0xA017,mpll_cfg_x2_xpcs_port); /* Setting BIT15:0 = 16'd40983(databook 41022) = 4'hA017 (A03E) */
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLB_CTRL3,mpll_cfg_x2_xpcs_port);
+		printf("[WR]VR_XS_PMA_GEN5_16G_MPLLB_CTRL3 Setting MPLLB_MULTIPLIER bit7:0 = 0x%08x\n", read_data);
+
+		/* writing to MPLLB_CTRL2 register for MPLLB_DIV_MULT BIT6:0, MPLLB_DIV_CLK_EN BIT7 */
+		printf("\nwriting to MPLLB_CTRL2 register for MPLLB_DIV_MULT\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,mpll_cfg_x2_xpcs_port);
+		read_data &= ~(0x3FF << 0);		/* Clear BIT9:0 */
+		read_data |=  (30 << 0);		/* BIT6:0 MPLLB_DIV_MULT	= 30d */
+		read_data |=  (0x1 << 7);		/* BIT7 MPLLB_DIV_CLK_EN	= 1h */
+		read_data &= ~(0x1 << 8);		/* BIT8 MPLLB_DIV8_CLK_EN	= 0h */
+		read_data |=  (0x1 << 9);		/* BIT9 MPLLB_DIV10_CLK_EN 	= 1h */
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,read_data,mpll_cfg_x2_xpcs_port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,mpll_cfg_x2_xpcs_port);
+		printf("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2 Setting MPLLB DIV8/DIV10/DIV16P5 bits = 0x%08x\n", read_data);
+	} else {
+		/* MPLLA Configuration */
+
+		/* writing to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT 5:3, REF_MPLLA_DIV2 BIT6 */
+		printf("\nwriting to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT and REF_MPLLA_DIV2\n");
+		value = 0x0;
+		value |= 0x1 << 0; /*REF_CLK_EN BIT0 = 1h */
+		if (ref_use_pad == 0)
+			value &= ~(0x1 << 1); /*REF_USE_PAD BIT1 = 0h */
+		else if (ref_use_pad == 1)
+			value |= 0x1 << 1; /*REF_USE_PAD BIT1 = 1h use external pad for clock. Only applicable for serdes HSIOL_1 */
+		value &= ~(0x1 << 2); /*REF_CLK_DIV2 = 0h */
+		if (port == PON_WAN_PORT4 && pon_eth_sel == PON_MODE)
+			value |= 0x5 << 3; /*REF_RANGE BIT5:3 = 3'b101: 130.1 - 156 MHz PON CLOCK */
+		else
+			value |= 0x6 << 3; /*REF_RANGE BIT5:3 = 3'b110: 156.1 - 182 MHz ETH CLOCK */
+		value |= 0x1 << 6; /*REF_MPLLA_DIV2 BIT6 */
+		/*value &= ~(0x1 << 7); //REF_MPLLB_DIV2 BIT7 */
+		value &= ~(0x1 << 8); /*REF_RPT_CLK_EN BIT8 //Disable now as Verification team did not enable this. It was enable in FLM. */
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,value,mpll_cfg_x2_xpcs_port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,mpll_cfg_x2_xpcs_port);
+		printf("[WR]VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL for BIT5:3 REF_RANGE BIT and BIT6 REF_MPLLA_DIV2= 0x%08x\n", read_data);
+
+		/*Set MPLLA_MULTIPLIER */
+		printf("\nWriting MPLLA_MULTIPLIER register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,mpll_cfg_x2_xpcs_port);
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,0x0020,mpll_cfg_x2_xpcs_port); /*Setting BIT7:0 = 8'd32 = 2'h20 */
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,mpll_cfg_x2_xpcs_port);
+		printf("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0 Setting MPLLA_MULTIPLIER bit7:0 = 0x%08x\n", read_data);
+
+		/*Set MPLLA_BANDWIDTH */
+		printf("\nWriting MPLLA_BANDWIDTH register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,mpll_cfg_x2_xpcs_port);
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,0xA035,mpll_cfg_x2_xpcs_port); /*Setting BIT15:0 = 16'd41013(databook 41022) = 4'hA035 (A03E) */
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,mpll_cfg_x2_xpcs_port);
+		printf("[WR]VR_XS_PMA_GEN5_16G_MPLLA_CTRL3 Setting MPLLA_BANDWIDTH bit15:0 = 0x%08x\n", read_data);
+
+		/*writing to MPLLA_CTRL2 register for MPLLA_DIV_MULT BIT6:0, MPLLA_DIV_CLK_EN BIT7 */
+		printf("\nwriting to MPLLA_CTRL2 register for MPLLA_DIV_MULT\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,mpll_cfg_x2_xpcs_port);
+		read_data &= ~(0x1 << 8); 	 /* BIT8 MPLLA_DIV8_CLK_EN			= 0h */
+		read_data |= (0x1 << 9);	 /* BIT9 MPLLA_DIV10_CLK_EN 		= 1h */
+		read_data &= ~(0x1 << 10);	 /* BIT10 MPLLA_DIV16P5_CLK_EN	 	= 0h */
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,read_data,mpll_cfg_x2_xpcs_port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,mpll_cfg_x2_xpcs_port);
+		printf("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2 Setting MPLLA DIV8/DIV10/DIV16P5 bits = 0x%08x\n", read_data);
+	}
+
+	/*Change TX VBOOST_LVL to 0x5 */
+	printf("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1  register for TX VBOOST_LVL[10:8] \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,mpll_cfg_x2_xpcs_port);
+	printf("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_LVL[10:8] = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFF8EF;
+	read_data |= (txeq->tx_vboost_lvl) << 8; /*Setting VBOOST_LVL BIT[10:8] = Default 0x5 after reset. VBOOST_EN_0 = 0x1 set later in lane specific */
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_LVL[10:8] = 0x%08x\n", read_data);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,mpll_cfg_x2_xpcs_port);
+
+	/* ##### PMA LANE Configuration ###### */
+	printf("########### PMA LANE Configuration ############ \n");
+
+	/*Writing to VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL */
+	/*BIT0 		MPLL_EN_0		= Set only if XPCS0, XPCS2, XPCS4, XPCS5 */
+	/*BIT3:1 	MPLL_EN_3_1		= Set LANE1 BIT1 only if XPCS1, XPCS3, RXAUI on */
+	/*BIT4 		MPLLB_SEL_0 	= Set only if 1G of XPCS0, XPCS2 */
+	/*BIT7:5 	MPLLB_SEL_3_1	= Set LANE1 BIT1 only if 1G of XPCS1, XPCS3. */
+	printf("\nWriting to VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+
+	if (port < WAN_XPCS4){
+		/*enabling MPLLB */
+		/*read_data &= ~(0xFF<<0); //Clear BIT7:0 */
+		/* need to set this bit to 1? */
+		/*read_data |= 0x0 << 0; 	 // BIT0 MPLL_EN_0		= 0h */
+		read_data |= 0x1 << 0; 	 /* BIT0 MPLL_EN_0		= 0h */
+		read_data |= 0x1 << 4; 	 /* BIT4 MPLLB_SEL_0		= 1h */
+	} else {
+		/*enabling MPLLA */
+		/*read_data &= ~(0xFF<<0); //Clear BIT7:0 */
+		read_data |= 0x1 << 0;	 /* BIT0 MPLL_EN_0			= 1h */
+		/*read_data |= 0x0 << 4;	 // BIT4 MPLLB_SEL_0	= 0h */
+	}
+
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL Setting BIT0 MPLL_EN_0, BIT4 MPLLB_SEL0, BIT1 MPLL_EN_1, BIT5 MPLLB_SEL_1 = 0x%08x\n", read_data);
+
+	/*RX VCO configuration */
+	/*writing to VR_XS_PMA_GEN5_12G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0 */
+	printf("\nwriting to PHY LANE0 VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0\n");
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,0x0540,port); /*13'd1344 = 3'h540 */
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0= 0x%08x\n", read_data);
+
+	/*writing to VR_XS_PMA_GEN5_12G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT6:0 and VCO_REF_LD_1 BIT14:8 */
+	printf("\nwriting to PHY LANE0 & 1 VR_XS_PMA_GEN5_16G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT6:0 and VCO_REF_LD_1 BIT14:8\n");
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,0x002A,port); /*6'd42 = 2'h2A */
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT5:0 and VCO_REF_LD_0 BIT13:8= 0x%08x\n", read_data);
+
+	/*configuring RX_EQ_CTRL4 register for CONT_ADAPT_0 = 0 */
+	printf("\nconfiguring RX_EQ_CTRL4 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port);
+	read_data = read_data & 0xFFFFFFF0; /*bit[0] = CONT_ADAPT_0, bit[3:1] CONT_ADAPT_3_1 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,(read_data),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT8 RX_DFE_BYP_0 = 0x%08x\n", read_data);
+
+	/*Writing TX Rate */
+	printf("\nwriting to VR_XS_PMA_GEN5_12G_TX_RATE_CTRL register for TX0_RATE BIT2:0\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port);
+	printf("[RD]VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL TX0_RATE BIT2:0 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFFFF8; /*bit[2:0] = 3'b000 : baud */
+	if (port < WAN_XPCS4) {
+		read_data |= 0x6 << 0; /*MPLL VCO 7.5G - 1G bit[2:0] = 3'b110 : baud/? */
+	} else {
+		read_data |= 0x3 << 0; /*MPLL VCO 5G - 1G bit[2:0] = 3'b011 : baud/8 */
+	}
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL TX0_RATE BIT2:0 = 0x%08x\n", read_data);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL TX0_RATE BIT2:0 = 0x%08x\n", read_data);
+
+	/*Change to RX Rate */
+	printf("\nwriting to VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL register for RX0_RATE BIT2:0\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port);
+	printf("[RD]VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL RX0_RATE BIT1:0 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFFFFC; /*bit[2:0] = 0 //2'b00 : baud */
+	read_data |= 0x3 << 0; /*1G  3'b011 : baud/8 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL RX0_RATE BIT1:0 = 0x%08x\n", read_data);
+
+	/*Change TX Width */
+	printf("\nwriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 register for TX0_WIDTH BIT9:8\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port);
+	printf("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 TX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFFCFF; /*bit[9:8] = 10 //2'b10: 16-bit; 2'b11: 20-bit */
+	read_data |= 0x1 << 8; /*bit[8] = 1;bit[9] = 0 //2'b01: 10-bit; 2'b11: 20-bit */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 TX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+
+	/*Change RX Width */
+	printf("\nwriting to VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2 register for RX0_WIDTH BIT9:8\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port);
+	printf("[RD]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2 RX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFFCFF; /*bit[9:8] = 10 //2'b10: 16-bit; 2'b11: 20-bit */
+	read_data |= 0x01 << 8; /*bit[8] = 1;bit[9] = 0 //2'b01: 10-bit; 2'b11: 20-bit */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2	RX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+
+	/*Change Enable TX VBOOST_EN here as it is per lane configuration */
+	printf("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1	register for VBOOST_EN_0 BIT4 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 ,port);
+	printf("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_EN_0 BIT4 = 0x%08x\n", read_data);
+	read_data |= (txeq->tx_vboost_en) << 4; /*Setting VBOOST_EN_0 = 0x1. */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 ,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 VBOOST_EN_0 BIT4	= 0x%08x\n", read_data);
+
+	/*writing to PHY att_lvl register */
+	printf("\nwriting to PHY RX attenuation Level register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port);
+	printf("[RD]VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL BIT2:0 RX0_EQ_ATT_LVL = 0x%08x\n", read_data);
+	read_data &= 0x000088E0;
+	read_data |= rxeq->rx_att_lvl << 0; /*BIT2:0 RX0_EQ_ATT_LVL */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL BIT2:0 RX0_EQ_ATT_LVL = 0x%08x\n", read_data);
+
+	/*writing to PHY ctle_pole and boost and gain register */
+	printf("\nwriting to PHY ctle_pole and boost and gain register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,port);
+	read_data &= 0xFFFF88E0;
+	read_data |= rxeq->rx_ctle_boost << 0; /*BIT4:0 CTLE_BOOST_0		= 18 */
+	read_data |= rxeq->rx_ctle_pole  << 5; /*BIT6:5 CTLE_POLE_0 		= 0 */
+	read_data |= rxeq->rx_vga2_gain  << 8; /*BIT10:8 VGA2_GAIN_0		= 4 */
+	read_data |= rxeq->rx_vga1_gain  << 12; /*BIT14:12 VGA1_GAIN_0		= 4 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3 LOS_TRSHLD_0 BIT2:0	= 0x%08x\n", read_data);
+
+	/*writing to RX PPM CTRL0 register VR_XS_PMA_Gen5_16G_RX_PPM_CTRL0 */
+	printf("\nwriting to VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port);
+	read_data &= ~(0x0F0F<<0); /*Clear BIT12:8 RX1_CDR_PPM_MAX and BIT4:0 RX0_CDR_PPM_MAX */
+	read_data |= 18 << 0; /*BIT4:0 RX0_CDR_PPM_MAX = 18 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0 BIT4:0 RX0_CDR_PPM_MAX= 0x%08x\n", read_data);
+
+	/*writing to RX CDR CTRL1 register */
+	printf("\nwriting to VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	read_data |= rxeq->rx_vco_temp_comp_en 	<< 0; /*BIT0 VCO_TEMP_COMP_EN_0		= 1 */
+	read_data |= rxeq->rx_vco_step_ctrl 	<< 4; /*BIT4 VCO_STEP_CTRL0			= 1 */
+	read_data |= rxeq->rx_vco_frqband 		<< 8; /*BIT9:8 VCO_FRQBAND_0		= 1 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1 BIT9:8 VCO_FRQBAND_0 BIT4 VCO_STEP_CTRL0, BIT0 VCO_TEMP_COMP_EN_0 = 0x%08x\n", read_data);
+
+	/*writing to VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 register */
+	printf("\nwriting to VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port);
+	read_data &= ~(0x1F<<8); /*Clear BIT12:8 RX_VREF_CTRL */
+	read_data |= 17 << 8; /*BIT12:8 RX_VREF_CTRL = 8'd17 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 BIT12:8 RX_VREF_CTRL = 0x%08x\n", read_data);
+
+	/*writing to RX_MISC_CTRL0 register */
+	printf("\nwriting to VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port);
+	read_data &= 0xFFFFFF00;
+	read_data |= rxeq->rx_misc << 0; /*BIT7:0 RX0_MISC	= 2'h12 8'd18 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0 BIT7:0 RX0_MISC = 0x%08x\n", read_data);
+
+	/*writing to VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 register */
+	printf("\nwriting to VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 register to clear RX DFE BYPASS\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port);
+	read_data &= ~(1 << 8); /*Clear BIT8 RX_DFE_BYP_0 */
+	read_data |= rxeq->rx_dfe_bypass << 8; /*BIT8 RX_DFE_BYP_0	= 0 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT8 RX_DFE_BYP_0 = 0x%08x\n", read_data);
+
+	/*writing to VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0 register */
+	printf("\nwriting to VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0 register to set RX0_DELTA_IQ\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+	read_data &= 0xFFFFF0FF; /*BIT11:8 RX0_DELTA_IQ	= 0 */
+	read_data |= rxeq->rx_delta_iq << 8; /*BIT8 RX_DFE_BYP_0	= 0 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT11:8 RX0_DELTA_IQ = 0x%08x\n", read_data);
+
+	/*writing to VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 register */
+	printf("\nwriting to VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 register to set RX_ADPT_SEL_0 and RX0_ADPT_MODE\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+	read_data &= ~(0x1 << 0); /* Clear BIT0 RX_ADPT_SEL_0 */
+	read_data &= ~(0x3 << 4); /* Clear BIT5:4 RX0_ADPT_MODE */
+	read_data |= rxeq->rx_adapt_sel << 0; /*BIT0 RX_ADPT_SEL_0	= 0 To Select Bank0 for Adapt */
+	read_data |= rxeq->rx_adapt_mode << 4; /*BIT5:4 RX0_ADPT_MODE = 3 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 BIT5:4 RX0_ADPT_MODE BIT0 RX_ADPT_SEL_0 = 0x%08x\n", read_data);
+
+	/***Not mentioned in XPCS datasheet but in PHY datasheet. */
+	/*writing to PHY LOS threshold register */
+	printf("\nwriting to PHY LOS threshold register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port);
+	read_data &= ~(0x7 << 0); /*Clear LOS_TRSHLD_0 BIT2:0 */
+	read_data |= rxeq->rx_los_threshold << 0; /* Set LOS_TRSHLD_0 BIT2:0 = 7 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,0x0007,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port);
+	printf("[WR]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3 LOS_TRSHLD_0 BIT2:0	= 0x%08x\n", read_data);
+
+	/*writing to VR_XS_PMA_GEN5_16G_MISC_CTRL2 register */
+	printf("\nwriting to VR_XS_PMA_GEN5_16G_MISC_CTRL2 register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port);
+	read_data &= ~(0xFF<<0); /*Clear BIT7:0 SUP_MISC[7:0] */
+	read_data |= 0x1 << 0; /*BIT7:0 SUP_MISC[7:0] = 1 */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MISC_CTRL2,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port);
+	printf("[WR]VR_XS_PMA_GEN5_16G_MISC_CTRL2 BIT7:0 SUP_MISC[7:0] = 0x%08x\n", read_data);
+
+	if(port == XPCS0 || port == XPCS2 || port == WAN_XPCS4 || port == XPCS5){
+		/*Need to do VR reset before override TX EQ setting */
+		vr_reset(port, 0);
+
+		/*Setting TX EQ_MAIN, EQ_PRE, EQ_POST */
+
+		printf("Configuration TX EQ after VR Reset for XPCS%d", port);
+		tx_eq_config(port, txeq);
+
+		if(port == XPCS0 || port == XPCS2){
+			printf("Configuration TX EQ after VR Reset for XPCS%d", port+1);
+			tx_eq_config(port+1, txeq);
+		}
+	}
+}
+
+int sram_init_chk(int port, int base1000x_en)
+{
+	int i;
+	u32 base_addr;
+	char baseaddr_name[50];
+
+	LGM_NET_DBG("SRAM INIT Check\n");
+	if (base1000x_en == 1) {
+		base_addr = VR_MII_GEN5_12G_16G_SRAM;
+		sprintf(baseaddr_name, "VR_MII_GEN5_12G_16G_SRAM");
+		LGM_NET_DBG("For BASE1000X\n");
+	} else {
+		base_addr = VR_XS_PMA_GEN5_12G_16G_SRAM;
+		sprintf(baseaddr_name, "VR_XS_PMA_GEN5_12G_16G_SRAM");
+		LGM_NET_DBG("Setting BaseAddress to VR_XS_PMA_GEN5_12G_16G_SRAM\n");
+	}
+
+	indirect_pcs_rd(base_addr,port);
+	LGM_NET_DBG("%s = 0x%08x\n", baseaddr_name, read_data);
+
+	for (i = 0; i < SRAM_INIT_CHK_TIMEOUT; i++) {
+		if (indirect_pcs_rd(base_addr,port) & BIT(0))
+			break;
+		udelay(10);
+	}
+
+	if (i >= SRAM_INIT_CHK_TIMEOUT) {
+		printf("SRAM_INIT failed\n");
+		return -1;
+	} else {
+		LGM_NET_DBG("SRAM_INIT succeed\n");
+		indirect_pcs_rd(base_addr,port);
+		read_data |= 0x1 << 1;
+		indirect_pcs_wr(base_addr,read_data,port);
+		indirect_pcs_rd(base_addr,port);
+		LGM_NET_DBG("Write EXT_LD_DN BIT1 of %s to indicate SRAM External Loading Done = 0x%08x\n", baseaddr_name, read_data);
+	}
+	return 0;
+}
+
+void usx_rate_adapt_rst(int port, int mode){
+	int port_num, max_port = 1, USRA_RST_BIT, i;
+	u32 BASE_ADDR;
+	char BASE_ADDR_STR[128];
+
+	if(mode == USX_SINGLE)
+		max_port = 1;
+	else if(mode == USX_QUAD)
+		max_port = 4;
+
+	for (port_num = 0; port_num < max_port; port_num++) {
+		if (port_num == 0){
+			BASE_ADDR = VR_XS_PCS_DIG_CTRL1;
+			sprintf(BASE_ADDR_STR, "VR_XS_PCS_DIG_CTRL1");
+			USRA_RST_BIT = 10;
+		} else if (port_num == 1){
+			BASE_ADDR = VR_MII_1_DIG_CTRL1;
+			sprintf(BASE_ADDR_STR, "VR_MII_1_DIG_CTRL1");
+			USRA_RST_BIT = 5;
+		} else if (port_num == 2){
+			BASE_ADDR = VR_MII_2_DIG_CTRL1;
+			sprintf(BASE_ADDR_STR, "VR_MII_2_DIG_CTRL1");
+			USRA_RST_BIT = 5;
+		} else if (port_num == 3){
+			BASE_ADDR = VR_MII_3_DIG_CTRL1;
+			sprintf(BASE_ADDR_STR, "VR_MII_3_DIG_CTRL1");
+			USRA_RST_BIT = 5;
+		}
+
+		LGM_NET_DBG("\nProgram 'USRA_RST' bit (bit [10]) of VR_XS_PCS_DIG_CTRL1 Register to 1 and wait for it to get selfcleared.\n");
+		indirect_pcs_rd(BASE_ADDR,port);
+		LGM_NET_DBG("[RD] Port%d %s = 0x%08x\n", port_num, BASE_ADDR_STR, read_data);
+		read_data |= 0x1 << USRA_RST_BIT; //Port0: BIT10 USRA_RST, Port1-3: BIT5 USRA_RST
+		indirect_pcs_wr(BASE_ADDR,read_data,port); //Set bit10=1
+		LGM_NET_DBG("[WR] Port%d %s = 0x%08x\n", port_num, BASE_ADDR_STR, read_data);
+		indirect_pcs_rd(BASE_ADDR,port);
+		LGM_NET_DBG("[RD] Port%d %s = 0x%08x\n", port_num, BASE_ADDR_STR, read_data);
+
+		for (i = 0; i < CHECK_TIMEOUT; i++) {
+			indirect_pcs_rd(BASE_ADDR,port);
+			if ((read_data & BIT(USRA_RST_BIT)) == 0x0000)  {
+				indirect_pcs_rd(BASE_ADDR,port);
+				LGM_NET_DBG("Port%d %s: BIT%d USRA_RST Self-Cleared= 0x%08x\n", port_num, BASE_ADDR_STR, USRA_RST_BIT, read_data);
+				break;
+			}
+			udelay(10);
+		}
+
+		indirect_pcs_rd(BASE_ADDR,port);
+		LGM_NET_DBG("After USRA_RST BIT%d Self-clear \n[RD] Port%d %s = 0x%08x\n", USRA_RST_BIT, port_num, BASE_ADDR_STR, read_data);
+		if (i >= CHECK_TIMEOUT){
+			LGM_NET_DBG("\nXPCS%d Port%d is NOT ready to operate in the desired USXGMII speed mode\n", port, port_num);
+		} else {
+			LGM_NET_DBG("\nXPCS%d Port%d is NOW ready to operate in the desired USXGMII speed mode\n", port, port_num);
+		}
+	}
+}
+
+/*14. Read the auto-negotiation status register (VR_MII_AN_INTR_STS Register). Bit [0] is set to indicate
+that auto-negotiation is complete. Bits [14:8] indicate the link-speed, duplex mode, EEE capability
+and EEE clock-stop capability indicated by the link partner (PHY chip).*/
+int usxgmii_stat_chk(int port, int mode, struct usxspd *usx_speed)
+{
+	int i, port_num, max_port = 1, cl37_an_completed = 0;
+	u32 usxg_an_sts_data, usxgmii_speed;
+	u32 STAT_BASE_ADDR;
+	char STAT_BASE_ADDR_STR[128];
+
+	if(mode == USX_SINGLE)
+		max_port = 1;
+	else if(mode == USX_QUAD)
+		max_port = 4;
+
+	for (port_num = 0; port_num < max_port; port_num++){
+		if (port_num == 0) {
+			STAT_BASE_ADDR = VR_MII_AN_INTR_STS;
+			sprintf(STAT_BASE_ADDR_STR, "VR_MII_AN_INTR_STS");
+		} else if (port_num == 1) {
+			STAT_BASE_ADDR 	= VR_MII_1_AN_INTR_STS;
+			sprintf(STAT_BASE_ADDR_STR, "VR_MII_1_AN_INTR_STS");
+		} else if(port_num == 2) {
+			STAT_BASE_ADDR 	= VR_MII_2_AN_INTR_STS;
+			sprintf(STAT_BASE_ADDR_STR, "VR_MII_2_AN_INTR_STS");
+		} else if(port_num == 3) {
+			STAT_BASE_ADDR = VR_MII_3_AN_INTR_STS;
+			sprintf(STAT_BASE_ADDR_STR, "VR_MII_3_AN_INTR_STS");
+		}
+
+		for (i = 0; i < 10*CHECK_TIMEOUT; i++) {
+			indirect_pcs_rd(STAT_BASE_ADDR,port);
+			usxg_an_sts_data = read_data;
+			if ((usxg_an_sts_data & 0x0001) == 0x0001) {
+				indirect_pcs_rd(STAT_BASE_ADDR,port);
+		#ifdef LGM_NET_VERBOSE
+				u32 stable_data;
+
+				stable_data = read_data;
+				LGM_NET_DBG("%s: BIT0 CL37_ANCMPLT_INTR= 0x%08x\n",
+					STAT_BASE_ADDR_STR, stable_data);
+		#endif /* LGM_NET_VERBOSE */
+				cl37_an_completed = 1;
+				break;
+			}
+			udelay(10);
+		}
+
+		if (i >= 10*CHECK_TIMEOUT) {
+			LGM_NET_DBG("PHY CL37 Auto-negotiation not completed\n");
+			indirect_pcs_rd(STAT_BASE_ADDR,port);
+			LGM_NET_DBG("%s = 0x%08x\n", STAT_BASE_ADDR_STR, read_data);
+			udelay(100);
+			//check BIT14 (USXG_AN_STS[6])
+			if (read_data && BIT(14))
+				LGM_NET_DBG("USXGMII Link \t\t\t : UP\n");
+			else
+				LGM_NET_DBG("USXGMII Link \t\t\t : DOWN\n");
+
+			//check BIT13 (USXG_AN_STS[5])
+			if (read_data && BIT(13))
+				LGM_NET_DBG("USXGMII DUPLEX \t\t\t : FULL DUPLEX\n");
+			else
+				LGM_NET_DBG("USXGMII DUPLEX \t\t\t : HALF DUPLEX\n");
+
+			//check BIT12:10 (USXG_AN_STS[4:2])
+			if ((read_data & 0x0C00) == 0x0C00) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 10Gbps\n");
+				usxgmii_speed = 3;
+			}
+			else if ((read_data & 0x1400) == 0x1400) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 5Gbps\n");
+				usxgmii_speed = 5;
+			}
+			else if ((read_data & 0x1000) == 0x1000) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 2.5Gbps\n");
+				usxgmii_speed = 4;
+			}
+			else if ((read_data & 0x0800) == 0x0800) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 1Gbps\n");
+				usxgmii_speed = 2;
+			}
+			else if ((read_data & 0x0400) == 0x0400) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 100Mbps\n");
+				usxgmii_speed = 1;
+			}
+			else if ((read_data & 0x0000) == 0x0000) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 10Mbps\n");
+				usxgmii_speed = 0;
+			}
+
+			//check BIT9 (USXG_AN_STS[1])
+			if (read_data & BIT(9))
+				LGM_NET_DBG("USXGMII EEE \t\t\t : supported\n");
+			else
+				LGM_NET_DBG("USXGMII EEE \t\t\t : not supported\n");
+
+			//check BIT8 (USXG_AN_STS[0])
+			if (read_data & BIT(8))
+				LGM_NET_DBG("USXGMII EEE clock-stop \t\t : supported\n");
+			else
+				LGM_NET_DBG("USXGMII EEE clock-stop \t\t : not supported\n");
+
+			//check BIT4 CL37 AN Link
+			if (read_data & BIT(4))
+				LGM_NET_DBG("USXGMII CL_ANSGM_STS[3] \t\t : Link Up\n");
+			else
+				LGM_NET_DBG("USXGMII CL_ANSGM_STS[3] \t\t : Link Down\n");
+
+			//check BIT1 CL37 Duplex
+			if (read_data & BIT(1))
+				LGM_NET_DBG("USXGMII CL_ANSGM_STS[0] \t\t : Full Duplex\n");
+			else
+				LGM_NET_DBG("USXGMII CL_ANSGM_STS[0] \t\t : Half Duplex\n");
+		} else {
+			LGM_NET_DBG("PHY CL37 Auto-negotiation completed\n");
+			indirect_pcs_rd(STAT_BASE_ADDR,port);
+			LGM_NET_DBG("%s = 0x%08x\n", STAT_BASE_ADDR_STR, read_data);
+
+			//check BIT14 (USXG_AN_STS[6])
+			if (read_data && BIT(14))
+				LGM_NET_DBG("USXGMII Link \t\t\t : UP\n");
+			else
+				LGM_NET_DBG("USXGMII Link \t\t\t : DOWN\n");
+
+			//check BIT13 (USXG_AN_STS[5])
+			if (read_data && BIT(13))
+				LGM_NET_DBG("USXGMII DUPLEX \t\t\t : FULL DUPLEX\n");
+			else
+				LGM_NET_DBG("USXGMII DUPLEX \t\t\t : HALF DUPLEX\n");
+
+			//check BIT12:10 (USXG_AN_STS[4:2])
+			if ((read_data & 0x0C00) == 0x0C00) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 10Gbps\n");
+				usxgmii_speed = 3;
+			}
+			else if ((read_data & 0x1400) == 0x1400) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 5Gbps\n");
+				usxgmii_speed = 5;
+			}
+			else if ((read_data & 0x1000) == 0x1000) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 2.5Gbps\n");
+				usxgmii_speed = 4;
+			}
+			else if ((read_data & 0x0800) == 0x0800) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 1Gbps\n");
+				usxgmii_speed = 2;
+			}
+			else if ((read_data & 0x0400) == 0x0400) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 100Mbps\n");
+				usxgmii_speed = 1;
+			}
+			else if ((read_data & 0x0000) == 0x0000) {
+				LGM_NET_DBG("USXGMII Speed \t\t\t : 10Mbps\n");
+				usxgmii_speed = 0;
+			}
+
+			//check BIT9 (USXG_AN_STS[1])
+			if (read_data & BIT(9))
+				LGM_NET_DBG("USXGMII EEE \t\t\t : supported\n");
+			else
+				LGM_NET_DBG("USXGMII EEE \t\t\t : not supported\n");
+
+			//check BIT8 (USXG_AN_STS[0])
+			if (read_data & BIT(8))
+				LGM_NET_DBG("USXGMII EEE clock-stop \t\t : supported\n");
+			else
+				LGM_NET_DBG("USXGMII EEE clock-stop \t\t : not supported\n");
+		}
+
+		/*15. Clear the Interrupt by writing 0 to bit [0] of VR_MII_AN_INTR_STS Register.*/
+		if (cl37_an_completed == 1){
+			//Clear BIT0 CL37_ANCMPLT_INTR of VR_MII_AN_INTR_STS
+			LGM_NET_DBG("\nClear BIT0 CL37_ANCMPLT_INTR\n");
+			indirect_pcs_rd(STAT_BASE_ADDR,port);
+			read_data = read_data & 0xFFFFFFFE;
+			indirect_pcs_wr(STAT_BASE_ADDR,read_data,port); //Clear BIT0 of CL37_ANCMPLT_INTR
+			indirect_pcs_rd(STAT_BASE_ADDR,port);
+			LGM_NET_DBG("%s = 0x%08x\n", STAT_BASE_ADDR_STR, read_data);
+		}
+
+		if (port_num == 0)
+			usx_speed->usx_p0_spd = usxgmii_speed;
+		else if (port_num == 1)
+			usx_speed->usx_p1_spd = usxgmii_speed;
+		else if (port_num == 2)
+			usx_speed->usx_p2_spd = usxgmii_speed;
+		else if (port_num == 3)
+			usx_speed->usx_p3_spd = usxgmii_speed;
+
+		if (usxgmii_speed == 0){
+			printf("USXGMII autoneg failed!!!!\n");
+			return -1;
+
+		}
+	}
+	return 0;
+}
+
+/* Program SS13, SS6 and SS5 bits of SR_MII_CTRL Register to configure DWC_xpcs to the USXGMII
+ * speed mode indicated by PHY in step 6. The values programmed to these bits will reflect in the
+ * output port 'xpcs_usxg_speed_o'. This step is required only if DWC_xpcs is configured as MAC-side
+ * USXGMII.
+ */
+void usx_mac_mii_spd_config(int port, int mode,
+			int usx_p0_spd, int usx_p1_spd,
+			int usx_p2_spd, int usx_p3_spd)
+{
+	int port_num, max_port = 1;
+	int usxgmii_speed;
+	u32 BASE_ADDR;
+	char BASE_ADDR_STR[128];
+
+	if(mode == USX_SINGLE)
+		max_port = 1;
+	else if(mode == USX_QUAD)
+		max_port = 4;
+
+	for (port_num = 0; port_num < max_port; port_num++) {
+		if (port_num == 0) {
+			BASE_ADDR = SR_MII_CTRL;
+			sprintf(BASE_ADDR_STR, "SR_MII_CTRL");
+			usxgmii_speed = usx_p0_spd;
+		} else if(port_num == 1) {
+			BASE_ADDR = SR_MII_1_CTRL;
+			sprintf(BASE_ADDR_STR, "SR_MII_1_CTRL");
+			usxgmii_speed = usx_p1_spd;
+		} else if(port_num == 2) {
+			BASE_ADDR = SR_MII_2_CTRL;
+			sprintf(BASE_ADDR_STR, "SR_MII_2_CTRL");
+			usxgmii_speed = usx_p2_spd;
+		} else if(port_num == 3) {
+			BASE_ADDR = SR_MII_3_CTRL;
+			sprintf(BASE_ADDR_STR,"SR_MII_3_CTRL");
+			usxgmii_speed = usx_p3_spd;
+		}
+		LGM_NET_DBG("\nSet %s for negotiated USXGMII speed \n", BASE_ADDR_STR);
+		indirect_pcs_rd(BASE_ADDR,port);
+		LGM_NET_DBG("%s = 0x%08x\n", BASE_ADDR_STR, read_data);
+		read_data &= 0xFFFFDF9F; //Clear bit5, bit6 and bit13
+
+#if 1
+		if (usxgmii_speed == 3) {
+			//read_data = read_data | 0x00002040; //10Gbps
+			read_data &= ~(0x1 << 5);	//SS5	= 0
+			read_data |=  (0x1 << 6);	//SS6	= 1
+			read_data |= (0x1 << 13);	//SS13	= 1
+		}
+		else if (usxgmii_speed == 5) {
+			//read_data = read_data | 0x00002020; //5Gbps
+			read_data |=  (0x1 << 5);	//SS5	= 1
+			read_data &= ~(0x1 << 6);	//SS6	= 0
+			read_data |= (0x1 << 13);	//SS13	= 1
+		}
+		else if (usxgmii_speed == 4) {
+			//read_data = read_data | 0x00002000; //2.5Gbps
+			read_data |=  (0x1 << 5);	//SS5	= 1
+			read_data &= ~(0x1 << 6);	//SS6	= 0
+			read_data &= ~(0x1 << 13);	//SS13	= 0
+		}
+		else if (usxgmii_speed == 2) {
+			//read_data = read_data | 0x00000040; //1Gbps
+			read_data &= ~(0x1 << 5);	//SS5	= 0
+			read_data |=  (0x1 << 6);	//SS6	= 1
+			read_data &= ~(0x1 << 13);	//SS13	= 0
+		}
+		else if (usxgmii_speed == 1) {
+			//read_data = read_data | 0x00000020; //100Mbps
+			read_data &= ~(0x1 << 5);	//SS5	= 0
+			read_data &= ~(0x1 << 6);	//SS6	= 0
+			read_data |=  (0x1 << 13);	//SS13	= 1
+		}
+		else if (usxgmii_speed == 0) {
+			//read_data = read_data | 0x00000000; //10Mbps
+			read_data &= ~(0x1 << 5);	//SS5	= 0
+			read_data &= ~(0x1 << 6);	//SS6	= 0
+			read_data &= ~(0x1 << 13);	//SS13	= 0
+		}
+#endif
+		indirect_pcs_wr(BASE_ADDR, read_data, port);
+		indirect_pcs_rd(BASE_ADDR,port);
+		LGM_NET_DBG("%s = 0x%08x\n", BASE_ADDR_STR, read_data);
+	}
+}
+
+void usxgmii_init(int port, int speed, int mode)
+{
+	//Initializing XPCS x Port
+	if (mode == USX_SINGLE) {
+		if (speed == KR_10G)
+			LGM_NET_DBG("\n*** Initializing 10G USXGMII Single Mode Port%d ... ***\n", port);
+		else if (speed == KR_5G)
+			LGM_NET_DBG("\n*** Initializing 5G USXGMII Single Mode Port%d ... ***\n", port);
+		else if (speed == KR_2P5G)
+			LGM_NET_DBG("\n*** Initializing 2.5G USXGMII Single Mode Port%d ... ***\n", port);
+	} else if (mode == USX_QUAD) {
+		LGM_NET_DBG("\n*** Initializing 10G USXGMII Quad Mode Port%d ... ***\n", port);
+	}
+
+	//1. Write 4'b0000 to bits[3:0] of SR_XS_PCS_CTRL2 register to switch DWC_xpcs to BASE-R mode.
+	//This will be set on xfi_10g5g2p5g_kr_cl73_bringup(int port, int speed)
+
+	//2. Program bit[9] (USXG_EN) of VR_XS_PCS_DIG_CTRL1 Register to 1 to enable USXGMII Mode inside DWC_xpcs.
+	LGM_NET_DBG("\nEnable USXGMII Mode inside DWC_xpcs\n");
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	LGM_NET_DBG("[RD] VR_XS_PCS_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+	//read_data = read_data | 0x00000200; // bit[9] = 1 -- enable USXGMII Mode inside DWC_xpcs
+	//read_data = read_data | 0x00000208; // bit[9] = 1 -- enable USXGMII Mode inside DWC_xpcs
+	read_data |= 0x1 << 9; // bit[9] = 1 -- enable USXGMII Mode inside DWC_xpcs
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,read_data,port);
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	LGM_NET_DBG("[WR] VR_XS_PCS_DIG_CTRL1 BIT9 USXG_EN = 0x%08x\n", read_data);
+
+	//3. Select the appropriate USXGMII mode by programming USXG_MODE field of VR_XS_PCS_KR_CTRL register to suitable values.
+	LGM_NET_DBG("\nProgram appropriate USXGMII mode at VR_XS_PCS_KR_CTRL\n");
+	/*	BIT12:10 USXG_MODE
+	USXGMII Mode Select
+	This field chooses the current USXGMII mode in which
+	DWC_xpcs should operate. The encoding of the mode is as
+	*/
+	indirect_pcs_rd(VR_XS_PCS_KR_CTRL,port);
+	LGM_NET_DBG("[RD] VR_XS_PCS_KR_CTRL BIT12:10 USXG_MODE = 0x%08x\n", read_data);
+	read_data &= ~(0x7 << 10); 	//Clear BIT[12:10] USXG_MODE
+	if (mode == USX_SINGLE) {
+		if(speed == KR_10G)
+			read_data &= ~(0x7 << 10);		// BIT[12:10] = 000 : 10G-SXGMII
+		else if(speed == KR_5G)
+			read_data |= (0x1 << 10);	// BIT[12:10] = 001 : 5G-SXGMII
+		else if(speed == KR_2P5G)
+			read_data |= (0x2 << 10);	// BIT[12:10] = 010 : 2.5G-SXGMII
+	} else if(mode == USX_QUAD)
+		read_data |= (0x5 << 10);	// BIT[12:10] = 101 : 10G-QXGMII
+	indirect_pcs_wr(VR_XS_PCS_KR_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PCS_KR_CTRL,port);
+	LGM_NET_DBG("[WR] VR_XS_PCS_KR_CTRL BIT12:10 USXG_MODE = 0x%08x\n", read_data);
+
+	//4. Program the PHY to operate at 10.3125Gbps/5.15625Gbps/2.578125Gbps.
+	//5. Initiate the vendor-specific software reset by writing to VR_RST bit[15] of VR_XS_PCS_DIG_CTRL1 register.
+	//6. For Synopsys Enterprise Gen5 16G PHY, perform steps mentioned in Table 7-1.
+	//7. Wait for bit[15] (VR_RST) of VR_XS_PCS_DIG_CTRL1 register to get cleared.
+
+	auto_10g_enable = 0; //This is to prevent CL73/72 autoneg on USXGMII when initializing xfi_10g5g2p5g_kr_cl73_bringup()
+	xfi_10g5g2p5g_kr_cl73_bringup(port, speed);
+
+	//8. In Backplane Ethernet PCS configurations, program bit[12] (AN_EN) of SR_AN_CTRL Register to 0
+	//	 and bit[12] (CL37_BP) of VR_XS_PCS_DIG_CTRL1 Register to 1.
+	LGM_NET_DBG("\nDisable CL73 Autonegotiation\n");
+	indirect_pcs_rd(SR_AN_CTRL,port);
+	LGM_NET_DBG("SR_AN_CTRL BIT12 = 0x%08x\n", read_data);
+	read_data = read_data & 0xFFFFEFFF; // bit[12] = 0 -- (AN_EN)
+	indirect_pcs_wr(SR_AN_CTRL,read_data,port);
+	indirect_pcs_rd(SR_AN_CTRL,port);
+	LGM_NET_DBG("SR_AN_CTRL BIT12 = 0x%08x\n", read_data);
+
+	LGM_NET_DBG("\nEnable CL37\n");
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 BIT12 = 0x%08x\n", read_data);
+	read_data = read_data | 0x00001000; // bit[12] = 1 -- (CL37_BP)
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,read_data,port);
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 BIT12 = 0x%08x\n", read_data);
+
+	//8a. Additional CONFIGURING PCS_CSR_DEBUG_CTL TO SUPRESS PHY LOS SIGNAL
+	LGM_NET_DBG("\nCONFIGURING PCS_CSR_DEBUG_CTL TO SUPRESS PHY LOS SIGNAL\n");
+	indirect_pcs_rd(VR_XS_PCS_DEBUG_CTRL,port);
+	LGM_NET_DBG("VR_XS_PCS_DEBUG_CTRL BIT4, 6 = 0x%08x\n", read_data);
+	read_data = read_data | 0x0050; // bit[4], bit[6] set to 1.
+	indirect_pcs_wr(VR_XS_PCS_DEBUG_CTRL,read_data,port);
+	indirect_pcs_rd(VR_XS_PCS_DEBUG_CTRL,port);
+	LGM_NET_DBG("VR_XS_PCS_DEBUG_CTRL BIT4, 6 = 0x%08x\n", read_data);
+
+	LGM_NET_DBG("\nSet VR_MII_AN_CTRL Setting \nBIT0 MII_AN_INTR_EN = 1'b1\nBIT3 TX_CONFIG = 1'b0\nBIT4 SGMII_LINK_STS = 1'b0\nBIT8 MII_CTRL = 1'b0\n");
+	indirect_pcs_rd(VR_MII_AN_CTRL,port);
+	LGM_NET_DBG("VR_MII_AN_CTRL = 0x%08x\n", read_data);
+	read_data &= 0xFFFFFEE6; //Clear BIT8,4,3,0
+	read_data |=   0x1 << 0; 	// BIT0 MII_AN_INTR_EN 	= 1 Complete Interrupt Enable
+	read_data &= ~(0x1 << 3); 	// BIT3 TX_CONFIG 		= 0 for MAC side
+	read_data |=  (0x1 << 4); 	// BIT4 SGMII_LINK_STS 	= 1 set for MAC side.
+	read_data &= ~(0x1 << 8); 	// BIT8 MII_CTRL 		= 0 for 4-BIT MII (FLM using 8-BIT MII)
+	indirect_pcs_wr(VR_MII_AN_CTRL,read_data,port);
+	indirect_pcs_rd(VR_MII_AN_CTRL,port);
+	LGM_NET_DBG("VR_MII_AN_CTRL = 0x%08x\n", read_data);
+
+	if (mode == USX_QUAD) {
+		// QUAD Port 1
+		LGM_NET_DBG("\nSet VR_MII_1_AN_CTRL Setting \nBIT0 MII_AN_INTR_EN = 1'b1\nBIT3 TX_CONFIG = 1'b0\nBIT4 SGMII_LINK_STS = 1'b0\nBIT8 MII_CTRL = 1'b0\n");
+		indirect_pcs_rd(VR_MII_1_AN_CTRL,port);
+		LGM_NET_DBG("VR_MII_1_AN_CTRL = 0x%08x\n", read_data);
+		read_data &= 0xFFFFFEE6; //Clear BIT8,4,3,0
+		read_data |=   0x1 << 0; 	// BIT0 MII_AN_INTR_EN 	= 1 Complete Interrupt Enable
+		read_data &= ~(0x1 << 3); 	// BIT3 TX_CONFIG 		= 0 for MAC side
+		read_data |=  (0x1 << 4); 	// BIT4 SGMII_LINK_STS 	= 1 set for MAC side.
+		read_data &= ~(0x1 << 8); 	// BIT8 MII_CTRL 		= 0 for 4-BIT MII (FLM using 8-BIT MII)
+		indirect_pcs_wr(VR_MII_1_AN_CTRL,read_data,port);
+		indirect_pcs_rd(VR_MII_1_AN_CTRL,port);
+		LGM_NET_DBG("VR_MII_1_AN_CTRL = 0x%08x\n", read_data);
+
+		// QUAD Port 2
+		LGM_NET_DBG("\nSet VR_MII_2_AN_CTRL Setting \nBIT0 MII_AN_INTR_EN = 1'b1\nBIT3 TX_CONFIG = 1'b0\nBIT4 SGMII_LINK_STS = 1'b0\nBIT8 MII_CTRL = 1'b0\n");
+		indirect_pcs_rd(VR_MII_2_AN_CTRL,port);
+		LGM_NET_DBG("VR_MII_2_AN_CTRL = 0x%08x\n", read_data);
+		read_data &= 0xFFFFFEE6; //Clear BIT8,4,3,0
+		read_data |=   0x1 << 0; 	// BIT0 MII_AN_INTR_EN 	= 1 Complete Interrupt Enable
+		read_data &= ~(0x1 << 3); 	// BIT3 TX_CONFIG 		= 0 for MAC side
+		read_data |=  (0x1 << 4); 	// BIT4 SGMII_LINK_STS 	= 1 set for MAC side.
+		read_data &= ~(0x1 << 8); 	// BIT8 MII_CTRL 		= 0 for 4-BIT MII (FLM using 8-BIT MII)
+		indirect_pcs_wr(VR_MII_2_AN_CTRL,read_data,port);
+		indirect_pcs_rd(VR_MII_2_AN_CTRL,port);
+		LGM_NET_DBG("VR_MII_2_AN_CTRL = 0x%08x\n", read_data);
+
+		// QUAD Port 3
+		LGM_NET_DBG("\nSet VR_MII_3_AN_CTRL Setting \nBIT0 MII_AN_INTR_EN = 1'b1\nBIT3 TX_CONFIG = 1'b0\nBIT4 SGMII_LINK_STS = 1'b0\nBIT8 MII_CTRL = 1'b0\n");
+		indirect_pcs_rd(VR_MII_3_AN_CTRL,port);
+		LGM_NET_DBG("VR_MII_3_AN_CTRL = 0x%08x\n", read_data);
+		read_data &= 0xFFFFFEE6; //Clear BIT8,4,3,0
+		read_data |=   0x1 << 0; 	// BIT0 MII_AN_INTR_EN 	= 1 Complete Interrupt Enable
+		read_data &= ~(0x1 << 3); 	// BIT3 TX_CONFIG 		= 0 for MAC side
+		read_data |=  (0x1 << 4); 	// BIT4 SGMII_LINK_STS 	= 1 set for MAC side.
+		read_data &= ~(0x1 << 8); 	// BIT8 MII_CTRL 		= 0 for 4-BIT MII (FLM using 8-BIT MII)
+		indirect_pcs_wr(VR_MII_3_AN_CTRL,read_data,port);
+		indirect_pcs_rd(VR_MII_3_AN_CTRL,port);
+		LGM_NET_DBG("VR_MII_3_AN_CTRL = 0x%08x\n", read_data);
+	}
+
+	//A1. Enable MAC_AUTO_SW
+	if(mode == USX_SINGLE) {
+		LGM_NET_DBG("\nA1. Enable MAC_AUTO_SW Mode inside DWC_xpcs\n");
+		indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		LGM_NET_DBG("[RD] VR_MII_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+		read_data |= 0x1 << 9; // bit[9] = 1 -- enable MAC_AUTO_SW Mode inside DWC_xpcs
+		indirect_pcs_wr(VR_MII_DIG_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		LGM_NET_DBG("[WR] VR_MII_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+	} else if(mode == USX_QUAD){
+		LGM_NET_DBG("\nA1. Enable MAC_AUTO_SW Mode inside DWC_xpcs\n");
+
+		indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		LGM_NET_DBG("[RD] Port0 VR_MII_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+		read_data |= 0x1 << 9; // bit[9] = 1 -- enable MAC_AUTO_SW Mode inside DWC_xpcs
+		indirect_pcs_wr(VR_MII_DIG_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		LGM_NET_DBG("[WR] Port0 VR_MII_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+
+		indirect_pcs_rd(VR_MII_1_DIG_CTRL1,port);
+		LGM_NET_DBG("[RD] Port1 VR_MII_1_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+		read_data |= 0x1 << 9; // bit[9] = 1 -- enable MAC_AUTO_SW Mode inside DWC_xpcs
+		indirect_pcs_wr(VR_MII_1_DIG_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_MII_1_DIG_CTRL1,port);
+		LGM_NET_DBG("[WR] Port1 VR_MII_1_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+
+		indirect_pcs_rd(VR_MII_2_DIG_CTRL1,port);
+		LGM_NET_DBG("[RD] Port2 VR_MII_2_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+		read_data |= 0x1 << 9; // bit[9] = 1 -- enable MAC_AUTO_SW Mode inside DWC_xpcs
+		indirect_pcs_wr(VR_MII_2_DIG_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_MII_2_DIG_CTRL1,port);
+		LGM_NET_DBG("[WR] Port2 VR_MII_2_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+
+		indirect_pcs_rd(VR_MII_3_DIG_CTRL1,port);
+		LGM_NET_DBG("[RD] Port3 VR_MII_3_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+		read_data |= 0x1 << 9; // bit[9] = 1 -- enable MAC_AUTO_SW Mode inside DWC_xpcs
+		indirect_pcs_wr(VR_MII_3_DIG_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_MII_3_DIG_CTRL1,port);
+		LGM_NET_DBG("[WR] Port3 VR_MII_3_DIG_CTRL1 BIT9 = 0x%08x\n", read_data);
+	}
+}
+
+int usxgmii_bringup(int port, int speed, int mode)
+{
+	struct usxspd *usx_speed = &g_usxspeed_defs[0];
+
+	//Initializing XPCS x Port
+	if(mode == USX_SINGLE){
+		if(speed == KR_10G)
+			LGM_NET_DBG("\n*** Start to bring up 10G USXGMII Single Mode Port%d ***\n", port);
+		else if(speed == KR_5G)
+			LGM_NET_DBG("\n*** Start to bring up 5G USXGMII Single Mode Port%d ***\n", port);
+		else if(speed == KR_2P5G)
+			LGM_NET_DBG("\n*** Start to bring up 2.5G USXGMII Single Mode Port%d ***\n", port);
+	}else if(mode == USX_QUAD)
+		LGM_NET_DBG("\n*** Start to bring up 10G USXGMII Quad Mode Port%d ***\n", port);
+
+/*10. (Optional step) Duration of link timer can be changed (default setting corresponds to 1.6ms) by
+programming VR_MII_LINK_TIMER_CTRL Register suitably and by setting bit [3] of
+VR_MII_DIG_CTRL1 Register to 1.
+
+	For USXGMII configurations: This field forms the upper
+	16-bit of the 24-bit value that gets loaded to the link timer.The
+	lower 8-bits are hard-coded as zero. For example, if
+	CL37_LINK_TIME = 1, the value that is loaded to the timer is
+	24'h100, which corresponds to a duration of 1638 ns
+	(256*6.4ns) in USXGMII mode or 2048 ns (256*8ns) in
+	1000BaseX/SGMII mode.
+
+	24 Bits
+	[24:8] 	Upper 16bits in this VR_MII_LINK_TIMER_CTRL register
+	[7:0]	Lower 8bits hardcoded to 0h.
+*/
+
+	//Default is 0x3D100 (BIT[24:8] = 0x3D1) which is 1.6ms (250,112*6.4ns).
+	//Setting to 6.71ms = 0x10 0000 (BIT[24:8] = 0x100)
+	LGM_NET_DBG("\nSet VR_MII_LINK_TIMER_CTRL BIT15:0 = 0x1000 (6.71ms)\n");
+	indirect_pcs_rd(VR_MII_LINK_TIMER_CTRL,port);
+	LGM_NET_DBG("VR_MII_LINK_TIMER_CTRL = 0x%08x\n", read_data);
+	read_data = read_data | 0x00003d1; //Set to 6.71ms.
+	//read_data = read_data | 0x0000100; //Set to 6.71ms.
+	//read_data = read_data | 0x0000000A;
+	indirect_pcs_wr(VR_MII_LINK_TIMER_CTRL,read_data,port);
+	indirect_pcs_rd(VR_MII_LINK_TIMER_CTRL,port);
+	LGM_NET_DBG("VR_MII_LINK_TIMER_CTRL = 0x%08x\n", read_data);
+
+	LGM_NET_DBG("\nSet VR_MII_DIG_CTRL1 BIT3 = 1'b1 (6.71ms)\n"); //To override the CL37 LINKTIMER
+	indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+	LGM_NET_DBG("VR_MII_DIG_CTRL1 = 0x%08x\n", read_data);
+	read_data |= 0x1 << 3;
+	indirect_pcs_wr(VR_MII_DIG_CTRL1,read_data,port);
+	indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+	LGM_NET_DBG("VR_MII_DIG_CTRL1 = 0x%08x\n", read_data);
+
+	if(mode == USX_QUAD) {
+		//*****QUAD Port 1
+		LGM_NET_DBG("\nSet VR_MII_1_DIG_CTRL1 BIT3 = 1'b1 (6.71ms)\n"); //To override the CL37 LINKTIMER
+		indirect_pcs_rd(VR_MII_1_DIG_CTRL1,port);
+		LGM_NET_DBG("VR_MII_1_DIG_CTRL1 = 0x%08x\n", read_data);
+		read_data |= 0x1 << 3;
+		indirect_pcs_wr(VR_MII_1_DIG_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_MII_1_DIG_CTRL1,port);
+		LGM_NET_DBG("VR_MII_1_DIG_CTRL1 = 0x%08x\n", read_data);
+		//*****QUAD Port 2
+		LGM_NET_DBG("\nSet VR_MII_2_DIG_CTRL1 BIT3 = 1'b1 (6.71ms)\n"); //To override the CL37 LINKTIMER
+		indirect_pcs_rd(VR_MII_2_DIG_CTRL1,port);
+		LGM_NET_DBG("VR_MII_2_DIG_CTRL1 = 0x%08x\n", read_data);
+		read_data |= 0x1 << 3;
+		indirect_pcs_wr(VR_MII_2_DIG_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_MII_2_DIG_CTRL1,port);
+		LGM_NET_DBG("VR_MII_2_DIG_CTRL1 = 0x%08x\n", read_data);
+		//*****QUAD Port 3
+		LGM_NET_DBG("\nSet VR_MII_3_DIG_CTRL1 BIT3 = 1'b1 (6.71ms)\n"); //To override the CL37 LINKTIMER
+		indirect_pcs_rd(VR_MII_3_DIG_CTRL1,port);
+		LGM_NET_DBG("VR_MII_3_DIG_CTRL1 = 0x%08x\n", read_data);
+		read_data |= 0x1 << 3;
+		indirect_pcs_wr(VR_MII_3_DIG_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_MII_3_DIG_CTRL1,port);
+		LGM_NET_DBG("VR_MII_3_DIG_CTRL1 = 0x%08x\n", read_data);
+	}
+
+/*12. Enable Clause 37 auto-negotiation by programming bit [12] of SR_MII_CTRL Register to 1.*/
+	LGM_NET_DBG("\nEnable CL37 Auto-Neg by setting SR_MII_CTRL Setting:\nBIT12 AN_ENABLE = 1\n");
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	LGM_NET_DBG("SR_MII_CTRL = 0x%08x\n", read_data);
+	read_data |= 0x1 << 12; //BIT12 AN_ENABLE = 1
+	indirect_pcs_wr(SR_MII_CTRL,read_data,port);
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	LGM_NET_DBG("SR_MII_CTRL = 0x%08x\n", read_data);
+
+	if (mode == USX_QUAD) {
+		//QUAD Port 1
+		LGM_NET_DBG("\nEnable CL37 Auto-Neg by setting SR_MII_1_CTRL Setting:\nBIT12 AN_ENABLE = 1\n");
+		indirect_pcs_rd(SR_MII_1_CTRL,port);
+		LGM_NET_DBG("SR_MII_1_CTRL = 0x%08x\n", read_data);
+		read_data |= 0x1 << 12; //BIT12 AN_ENABLE = 1
+		indirect_pcs_wr(SR_MII_1_CTRL,read_data,port);
+		indirect_pcs_rd(SR_MII_1_CTRL,port);
+		LGM_NET_DBG("SR_MII_1_CTRL = 0x%08x\n", read_data);
+		//QUAD Port 2
+		LGM_NET_DBG("\nEnable CL37 Auto-Neg by setting SR_MII_2_CTRL Setting:\nBIT12 AN_ENABLE = 1\n");
+		indirect_pcs_rd(SR_MII_2_CTRL,port);
+		LGM_NET_DBG("SR_MII_2_CTRL = 0x%08x\n", read_data);
+		read_data |= 0x1 << 12; //BIT12 AN_ENABLE = 1
+		indirect_pcs_wr(SR_MII_2_CTRL,read_data,port);
+		indirect_pcs_rd(SR_MII_2_CTRL,port);
+		LGM_NET_DBG("SR_MII_2_CTRL = 0x%08x\n", read_data);
+		//QUAD Port 3
+		LGM_NET_DBG("\nEnable CL37 Auto-Neg by setting SR_MII_3_CTRL Setting:\nBIT12 AN_ENABLE = 1\n");
+		indirect_pcs_rd(SR_MII_3_CTRL,port);
+		LGM_NET_DBG("SR_MII_3_CTRL = 0x%08x\n", read_data);
+		read_data |= 0x1 << 12; //BIT12 AN_ENABLE = 1
+		indirect_pcs_wr(SR_MII_3_CTRL,read_data,port);
+		indirect_pcs_rd(SR_MII_3_CTRL,port);
+		LGM_NET_DBG("SR_MII_3_CTRL = 0x%08x\n", read_data);
+	}
+
+#ifdef CONFIG_LGM_P34X_SUPPORT
+	u32 soc_version = get_soc_version();
+
+	if (soc_version == 7)
+	{
+		if (external_fw_load()){
+			printf("external gphy fw loading fail \n");
+			return -1;
+		}
+	}		
+	else if (!((!CONFIG_IS_ENABLED(BOARD_OCTOPUS) && (!cpu_is_urx6x1()))
+		|| !CONFIG_IS_ENABLED(EXTERNAL_P34X_ATTACHED))) {
+
+		/*need to wait 550ms here for gphy241 to display correct phy id. 
+		While mxl86249 will always display 0 on phy id here.(mxl86249 
+		display phy id only after fw been loaded)*/
+		/*the delay needed for gphy241 to display correct ID is different
+		between different boards. while mxl86249 consistent return 0 before
+		singed gphy fw loaded.*/
+
+		if ((show_phy_id() & GPHY241_MASK) == 0) {
+			if (external_fw_load()){
+				printf("external gphy fw loading fail \n");
+				return -1;
+			}
+		}
+		else {
+			p34x_hrst();
+		}
+	} else {
+		if (internal_fw_load()){
+			printf("internal gphy fw loading fail \n");
+			return -1;
+		}
+	}
+#endif
+	LGM_NET_DBG("\n16. Program SS13, SS6 and SS5 bits of SR_MII_CTRL Register to configure DWC_xpcs to the USXGMII speed mode indicated by PHY in step 6.\n");
+	usx_mac_mii_spd_config(port, mode, usx_speed->usx_p0_spd, usx_speed->usx_p1_spd, usx_speed->usx_p2_spd, usx_speed->usx_p3_spd);
+
+	/*18. Program USXGMII Rate Adaptor Reset 'USRA_RST' bit 1 and wait
+	 * for it to get selfcleared.
+	 */
+	usx_rate_adapt_rst(port, mode);
+	return 0;
+}
+
+
+void xfi_10g5g2p5g_kr_cl73_bringup(int port, int speed)
+{
+	char spd_str[20];
+	if (speed == KR_10G)
+		sprintf(spd_str, "10G KR");
+	else if (speed == KR_5G)
+		sprintf(spd_str, "5G KR");
+	else if (speed == KR_2P5G)
+		sprintf(spd_str, "2.5G KR");
+
+	if (port < WAN_XPCS4)
+		LGM_NET_DBG("\n########## Start to bring up %s LAN XPCS %d ##########\n", spd_str, port);
+	else if (port == WAN_XPCS4)
+		LGM_NET_DBG("\n########## Start to bring up %s WAN XPCS %d ##########\n", spd_str, port);
+	else
+		LGM_NET_DBG("\n########## Start to bring up %s LAN XPCS %d ##########\n", spd_str, port);
+
+	//Initializing XPCS x Port
+	check_rxtx_stable(port);
+	disable_an(port);
+	disable_an_37(port);
+	//pma_type_config(port);
+	xfi_10g5g2p5g_kr_serdes_bringup(port, speed);
+
+	/*Clause 73/72 Auto-negotiation Setup*/
+	if (auto_10g_enable == 0) {
+		//Disable C73 Auto-negotiation as not supported by SFP+ as it was default enable for CL73
+		disable_an(port);
+		disable_an_37(port);
+
+	} else if (auto_10g_enable == 1){
+		cl72_73_an_en(port);
+	}
+
+	LGM_NET_DBG("\n XPCS%d and Serdes%d Bring Up Complete.\n", port, port);
+}
+
+void pma_type_config(int port)
+{
+	int value = 11; /*Default at 10GBASE-KR PMA Type BIT3:0 */
+
+	/*writing to SR_PMA_CTRL1 register for BIT13 SS13 Speed Selection; 0 = 1G KX Mode, 1 = 10GBASE-X PCS mode. */
+	printf("\nWriting to SR_PMA_CTRL1 register BIT13 for Speed Selection\n");
+	indirect_pcs_rd(SR_PMA_CTRL1,port);
+
+	if (pma_type < 12)
+		indirect_pcs_wr(SR_PMA_CTRL1,(read_data | 0x2000),port);/*10G Mode */
+	else
+		indirect_pcs_wr(SR_PMA_CTRL1,(read_data & 0xFFFFDFFF),port); /*1G Mode */
+
+	/*value = 0x2000; */
+	indirect_pcs_rd(SR_PMA_CTRL1,port);
+	printf("\n[WR] SR_PMA_CTRL1: SS13 Speed Selection BIT13, 0 = 1G KX Mode, 1 = 10GBASE-X PCS = 0x%08x\n", read_data);
+
+	/*writing to SR_PMA_CTRL2 register for PMA_TYPE */
+	value = 0x0;
+	value |= pma_type << 0;
+
+	printf("\nWriting to SR_PMA_CTRL2 register for PMA_TYPE\n");
+	indirect_pcs_wr(SR_PMA_CTRL2,value,port);
+	indirect_pcs_rd(SR_PMA_CTRL2,port);
+	printf("\n[WR] SR_PMA_CTRL2: PMA_TYPE BIT3:0, > 0xb is 1G PMA/PMD type, <0xb is 10G PMA/PMD type = 0x%08x\n", read_data);
+
+}
+
+void disable_an(int port)
+{
+	LGM_NET_DBG("Disabling Auto-Negotiation \n");
+	/*SR_AN_CTRL BIT12 AN_EN = 0, BIT13 EXP_NP_CTL = 0 */
+	indirect_pcs_rd(SR_AN_CTRL, port);
+	LGM_NET_DBG("[RD]Read SR_AN_CTRL Setting BIT12 AN_EN, BIT13 EXP_NP_CTL = 0= 0x%08x\n", read_data);
+	read_data &= ~0x00003000;
+	indirect_pcs_wr(SR_AN_CTRL,read_data, port);
+	indirect_pcs_rd(SR_AN_CTRL, port);
+	LGM_NET_DBG("[WR]Set SR_AN_CTRL Setting BIT12 AN_EN, BIT13 EXP_NP_CTL = 0x%08x\n", read_data);
+}
+
+void disable_an_37(int port)
+{
+	LGM_NET_DBG("Disabling Clause 37 AN \n");
+	indirect_pcs_rd(SR_MII_CTRL, port);
+	read_data &= ~0x00001000; /* wr_data[12] = 1'b0; */
+	indirect_pcs_wr(SR_MII_CTRL, read_data, port);
+	indirect_pcs_rd(SR_MII_CTRL, port);
+	LGM_NET_DBG("[WR]Set SR_AN_CTRL Setting BIT12 AN_EN = 0x%08x\n", read_data);
+}
+
+void base_1g_bringup(int port)
+{
+	if (port < WAN_XPCS4)
+		printf("\n########## Start to bring up 1G SGMII LAN XPCS %d ##########\n", port);
+	else if (port == WAN_XPCS4)
+		printf("\n########## Start to bring up 1G SGMII WAN XPCS %d ##########\n", port);
+	else if (port == XPCS5)
+		printf("\n########## Start to bring up 1G SGMII LAN XPCS %d ##########\n", port);
+
+	check_rxtx_stable(port);
+	disable_an(port);
+	disable_an_37(port);
+	pma_type_config(port);
+	base_1g_serdes_bringup(port);
+
+	/* CSR block triggers the software reset process: all internal blocks are reset except Managment Interface block and SDR block. */
+	/* PHY is also reset. Self clearing. */
+	/* vr_reset(port,~(autoneg_1g)); */
+	/* XPCS0 and XPCS2 need to reset the last if both XPCS0 and XPCS1 or XPCS2 and XPCS3 are configured together. */
+
+	if (port == XPCS0 || port == XPCS2 || port == WAN_XPCS4 || port == XPCS5) {
+		/* Clause 37 Auto-negotiation Setup */
+		if (autoneg_1g == 1) {
+			cl37_autoneg(port);
+		} else {
+			/* Program Various field of VR_MII_AN_CTRL register
+			 * Set SGMII Mode for 1G
+			 * VR_MII_AN_CTRL
+			 * BIT0		MII_AN_INTR_EN = 1b to enable Complete Interrupt Enable.
+			 * BIT2:1		PCS_MODE = 00b for 1000BASE-X mode
+			 * BIT3		TX_CONFIG = 1b; 0b for DWC_xpcs as MAC side, 1b for PHY side
+			 * BIT4		SGMII_LINK_STS = 0b Link Down; 1b Link Up
+			 * BIT8		MII_CTRL = 1b for 8-BIT MII
+			 */
+			printf("\nSet VR_MII_AN_CTRL Setting MII_AN_INTR_EN BIT0 = 1'b1 PCS_MODE BIT2:1 = 2'b10, TX_CONFIG BIT3 = 1'b1\n");
+			indirect_pcs_rd(VR_MII_AN_CTRL,port);
+			read_data = read_data & 0xFFFFFF70;
+			/* indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x010d),port); */ /* For PHY. try 0x0108 for PHY side.*/
+			indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x0100),port); /* For MAC. try 0x0100 for MAC side. */
+			indirect_pcs_rd(VR_MII_AN_CTRL,port);
+			printf("[WR] Enabling PCS mode VR_MII_AN_CTRL = 0x%08x\n", read_data);
+
+			/* Disable C73 and CL37 Auto-negotiation as not supported by SFP+ as it was default enable for CL73 and CL37 */
+			disable_an(port);
+			disable_an_37(port);
+		}
+
+		if (port == XPCS0 || port == XPCS2) {
+			int port_sel = port + 1;
+			/* Clause 37 Auto-negotiation Setup */
+			if (autoneg_1g == 1) {
+				cl37_autoneg(port_sel);
+			} else {
+
+				/* Program Various field of VR_MII_AN_CTRL register
+				 * Set SGMII Mode for 1G
+				 * VR_MII_AN_CTRL
+				 * BIT0		MII_AN_INTR_EN = 1b to enable Complete Interrupt Enable.
+				 * BIT2:1	PCS_MODE = 00b for 1000BASE-X mode
+				 * BIT3		TX_CONFIG = 1b; 0b for DWC_xpcs as MAC side, 1b for PHY side
+				 * BIT4		SGMII_LINK_STS = 0b Link Down; 1b Link Up
+				 * BIT8		MII_CTRL = 1b for 8-BIT MII
+				 */
+				printf("\nSet VR_MII_AN_CTRL Setting MII_AN_INTR_EN BIT0 = 1'b1 PCS_MODE BIT2:1 = 2'b10, TX_CONFIG BIT3 = 1'b1\n");
+				indirect_pcs_rd(VR_MII_AN_CTRL,port_sel);
+				read_data = read_data & 0xFFFFFF70;
+				/* indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x010d),port_sel); */ /* For PHY. try 0x0108 for PHY side. */
+				indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x0100),port_sel); /* For MAC. try 0x0100 for MAC side.*/
+				indirect_pcs_rd(VR_MII_AN_CTRL,port_sel);
+				printf("[WR] Enabling PCS mode VR_MII_AN_CTRL = 0x%08x\n", read_data);
+
+				/* Disable C73 and CL37 Auto-negotiation as not supported by SFP+ as it was default enable for CL73 and CL37 */
+				disable_an(port_sel);
+				disable_an_37(port_sel);
+			}
+		}
+	}
+
+	if (dprint_enable == 1)
+		dump_xpcs_tx_reg(port);
+
+	printf("\nPort%d 1G XPCS and Serdes Bring Up Complete.\n", port);
+}
+
+#if defined(CONFIG_LAN_HSIO_R_SGMII_2500BASEX) || defined(CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET)
+void xpcs_disable_an_gsw140(int port)
+{
+	/* Disable CL73 Autoneg */
+	//XPCS_RGWR_VAL(pdata, AN_CTRL, AN_EN, 0);
+	indirect_pcs_rd(SR_AN_CTRL, port);
+	indirect_pcs_wr(SR_AN_CTRL,read_data & (~(1<<12)),port);
+
+	/* Disable Next page */
+	//XPCS_RGWR_VAL(pdata, AN_CTRL, EXP_NP_CTL, 0);
+	indirect_pcs_rd(SR_AN_CTRL, port);
+	indirect_pcs_wr(SR_AN_CTRL,read_data & (~(1<<13)),port);
+
+
+	/* Disable Backplane CL37 Autonegotiation */
+	//XPCS_RGWR_VAL(pdata, PCS_DIG_CTRL1, CL37_BP, 0);
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, port);
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,read_data & (~(1<<12)),port);
+
+
+	/* Disable CL37 Autoneg */
+	//XPCS_RGWR_VAL(pdata, SR_MII_CTRL, AN_ENABLE, 0);
+	indirect_pcs_rd(SR_MII_CTRL, port);
+	indirect_pcs_wr(SR_MII_CTRL,read_data & (~(1<<12)),port);
+
+
+	/* Disable Auto Speed Mode Change after CL37 AN */
+	//XPCS_RGWR_VAL(pdata, VR_MII_DIG_CTRL1, MAC_AUTO_SW, 0);
+	indirect_pcs_rd(VR_MII_DIG_CTRL1, port);
+	indirect_pcs_wr(VR_MII_DIG_CTRL1,read_data & (~(1<<9)),port);
+
+
+	/* Reset MII Ctrl register, 
+	bit0,	MII_AN_INTR_EN
+	bit2:1,	PCS_MODE
+	bit3,	TX_CONFIG
+	*/
+	//XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, PCS_MODE, 0);
+	//XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, TX_CONFIG, 0);
+	//XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, MII_AN_INTR_EN, 0);
+	indirect_pcs_rd(VR_MII_AN_CTRL, port);
+	indirect_pcs_wr(VR_MII_AN_CTRL,read_data & (~(0xf)),port);
+
+	/* 4-BIT MII Interface for LMAC */
+	//XPCS_RGWR_VAL(pdata, VR_MII_AN_CTRL, MII_CONTROL, 0);
+	indirect_pcs_rd(VR_MII_AN_CTRL, port);
+	indirect_pcs_wr(VR_MII_AN_CTRL,read_data & (~(1<<8)),port);
+	return;
+}	
+
+int xpcs_set_mode_2500basex(int port)
+{
+	/* Setting SS13 bit PMA side */
+	indirect_pcs_rd(SR_PMA_CTRL1,port);
+	indirect_pcs_wr(SR_PMA_CTRL1,(read_data & (~0x2000)),port);
+	indirect_pcs_rd(SR_PMA_CTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(SR_PMA_CTRL1,port); = 0x%x\n", read_data);
+
+
+	/* 13	PMA_TYPE_1G_BASE_KX */
+	indirect_pcs_wr(SR_PMA_CTRL2,0xd,port);
+	indirect_pcs_rd(SR_PMA_CTRL2,port);
+	LGM_NET_DBG("indirect_pcs_rd(SR_PMA_CTRL2,port); = 0x%x\n", read_data);
+
+/* When this field is written with 2'b00, the KR
+ * speed mode is selected. When this field is written with a value other
+ * than 2'b00, the KR speed mode is de-selected and non-KR speed
+ * mode (KX4 or KX) is selected
+0001: Select 10GBASE-X PCS Type
+ */
+	indirect_pcs_wr(SR_XS_PCS_CTRL2,1,port);
+	indirect_pcs_rd(SR_XS_PCS_CTRL2,port);
+	LGM_NET_DBG("indirect_pcs_rd(SR_XS_PCS_CTRL2,port); = 0x%x\n", read_data);
+
+	/* XAUI Mode to 0 to disable RXAUI Mode */
+	indirect_pcs_rd(VR_XS_PCS_XAUI_CTRL,port);
+	indirect_pcs_wr(VR_XS_PCS_XAUI_CTRL,(read_data & (~1)),port);
+	indirect_pcs_rd(VR_XS_PCS_XAUI_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PCS_XAUI_CTRL,port); = 0x%x\n", read_data);
+
+	/* Setting SS13 bit of PCS side */
+	indirect_pcs_rd(SR_XS_PCS_CTRL1,port);
+	indirect_pcs_wr(SR_XS_PCS_CTRL1,(read_data & (~0x2000)),port);
+	indirect_pcs_rd(SR_XS_PCS_CTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(SR_XS_PCS_CTRL1,port); = 0x%x\n", read_data);
+
+	/* Enable 2.5G GMII Mode */
+	//XPCS_RGWR_VAL(pdata, VR_MII_DIG_CTRL1, EN_2_5G_MODE, en_2p5);
+	indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+	indirect_pcs_wr(VR_MII_DIG_CTRL1,(read_data | 0x4),port);
+	indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_MII_DIG_CTRL1,port); = 0x%x\n", read_data);
+
+	/* Full duplex by default */
+	//XPCS_RGWR_VAL(pdata, SR_MII_CTRL, DUPLEX_MODE, 1);
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	indirect_pcs_wr(SR_MII_CTRL,(read_data | 0x100),port);
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(SR_MII_CTRL,port); = 0x%x\n", read_data);
+
+	/* 1Gbps SGMII Mode or speed for Non-ANEG mode */
+	/* 0 - 10M, 1 - 100M, 2 - 1G */
+	//XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS13, spd & BIT(0));
+	//XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS6, (spd >> 1) & BIT(0));
+	//XPCS_RGWR_VAL(pdata, SR_MII_CTRL, SS5, 0);
+
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	indirect_pcs_wr(SR_MII_CTRL,((read_data & (~0x2060)) | 0x40),port);
+	indirect_pcs_rd(SR_MII_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(SR_MII_CTRL,port); = 0x%x\n", read_data);
+	return 0;
+}
+
+int xpcs_cfg_mplla(int port)
+{
+	//XPCS_RGWR_VAL(pdata, PMA_MPLLA_C0, MPLLA_MULTIPLIER, mode_cfg->mplla_mult);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,((read_data & (~0xff)) | gsw140_xpcs_mode_cfg.mplla_mult),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL(pdata, PMA_MPLLA_C0, MPLLA_CAL_DISABLE, 0);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,((read_data & (~0x8000)) | 0),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL(pdata, PMA_MPLLA_C3, MPPLA_BANDWIDTH, mode_cfg->mplla_bw);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,gsw140_xpcs_mode_cfg.mplla_bw,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,port=%d); = 0x%x\n", port, read_data);
+
+/*
+bit10	MPLLA_DIV16P5_CLK_EN
+bit9	MPLLA_DIV10_CLK_EN
+bit8	MPLLA_DIV8_CLK_EN
+
+u32 mplla_div165_clk_en = 0;
+u32 mplla_div10_clk_en = 1;
+u32 mplla_div8_clk_en = 0;
+
+val = XPCS_RGRD(pdata, PMA_MPLLA_C2);		
+XPCS_SET_VAL(val, PMA_MPLLA_C2, MPLLA_DIV16P5_CLK_EN,mode_cfg->mplla_div165_clk_en);	
+XPCS_SET_VAL(val, PMA_MPLLA_C2, MPLLA_DIV10_CLK_EN,mode_cfg->mplla_div10_clk_en);	
+XPCS_SET_VAL(val, PMA_MPLLA_C2, MPLLA_DIV8_CLK_EN,mode_cfg->mplla_div8_clk_en);	
+XPCS_RGWR(pdata, PMA_MPLLA_C2, val);		
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,((read_data & (~0x700)) | 0x200),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,port=%d); = 0x%x\n", port, read_data);
+	return 0;
+}
+
+
+int xpcs_cfg_clk_pair(int port0, int port1)
+{
+	//XPCS_RGWR(pdata, PMA_REF_CLK_CTRL, val);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL, ref_clk_ctrl, port0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL, ref_clk_ctrl, port1);
+
+	xpcs_cfg_mplla(port0);
+	xpcs_cfg_mplla(port1);
+
+	//bit10:8	tx_vboost_lvl
+	//XPCS_RGWR_VAL(pdata, PMA_TX_GENCTRL1, VBOOST_LVL, val);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,((read_data & (~0x700)) | (gsw140_xpcs_serdes_cfg.tx_vboost_lvl<<8)),port0);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port0);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port=%d); = 0x%x\n", port0, read_data);
+
+	//XPCS_RGWR_VAL(pair_pdata, PMA_TX_GENCTRL1, VBOOST_LVL, val);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port1);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,((read_data & (~0x700)) | (gsw140_xpcs_serdes_cfg.tx_vboost_lvl<<8)),port1);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port1);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port=%d); = 0x%x\n", port1, read_data);
+	return 0;
+}
+
+void xpcs_cfg_table(int port)
+{
+	/*
+	XPCS_RGWR(pdata, PMA_MPLL_CMN_CTRL, 0);
+	XPCS_RGWR(pdata, PMA_VCO_CAL_REF0, 0);
+	XPCS_RGWR(pdata, PMA_VCO_CAL_REF1, 0);
+	XPCS_RGWR(pdata, PMA_RX_PPM_CTRL0, 0);
+	XPCS_RGWR(pdata, PMA_RX_GENCTRL3, 0);
+	*/
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL , 0, port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0, 0, port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF1, 0, port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0, 0, port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3, 0, port);
+
+	/*there is only 1 lane, follow lane always = 0*/
+	//bit0 MPLL_EN_0 : Tx MPLL Enable-lane 0 This bit should be set to power-up the MPLL.This bit should be 1, for normal operation.
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_MPLL_CMN_CTRL, MPLL_EN_0, 1, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,((read_data & (~0x1)) | 1),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port=%d); = 0x%x\n", port, read_data);
+
+	//bit4 MPLLB_SEL_0 : Tx MPLLB Select-lane 0 When this bit is set, PHY selects MPLLB to generate Tx analog clocks on lane 0
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_MPLL_CMN_CTRL, MPLLB_SEL_0, pdata->mpllb ? 1 : 0, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,((read_data & (~0x10)) | (MPLLB << 4)),port);	//mpllb = 0
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_OFF(pdata, PMA_VCO_CAL_LD0, VCO_LD_VAL_0, mode_cfg->vco_ld_val, lane);	
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,gsw140_xpcs_mode_cfg.vco_ld_val,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,port=%d); = 0x%x\n", port, read_data);
+
+			
+	//XPCS_RGWR_VAL_OFF_SHIFT(pdata, PMA_VCO_CAL_REF0, VCO_REF_LD_0, mode_cfg->vco_ref_ld, lane / 2, (lane & 1) * 8);			
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,((read_data & (~0x7f)) | (gsw140_xpcs_mode_cfg.vco_ref_ld)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_EQ_CTRL4, CONT_ADAPT_0, lane_cfg->cont_adapt, lane);					
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,((read_data & (~0x1)) | (gsw140_xpcs_serdes_cfg.cont_adapt)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port=%d); = 0x%x\n", port, read_data);
+
+	/*execute following write when mpllb == 0.  3'b010 : baud/4 */	
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_TX_RATE_CTRL, TX_RATE_0, mode_cfg->tx_rate, lane * 4);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,((read_data & (~0x7)) | (gsw140_xpcs_mode_cfg.tx_rate)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port=%d); = 0x%x\n", port, read_data);
+
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_RATE_CTRL, RX_RATE_0, mode_cfg->rx_rate, lane * 4);	
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,((read_data & (~0x3)) | (gsw140_xpcs_mode_cfg.rx_rate)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_TX_GENCTRL2, TX_WIDTH_0, mode_cfg->tx_width, lane * 2);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,((read_data & (~0x300)) | (gsw140_xpcs_mode_cfg.tx_width<<8)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_GENCTRL2, RX_WIDTH_0, mode_cfg->rx_width, lane * 2);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,((read_data & (~0x300)) | (gsw140_xpcs_mode_cfg.rx_width<<8)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port=%d); = 0x%x\n", port, read_data);
+
+	/* Tx Voltage Boost Maximum level,		
+ 	* maximum achievable Tx swing in the PHY		
+ 	*/
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_TX_GENCTRL1, VBOOST_EN_0, lane_cfg->tx_vboost_en, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,((read_data & (~0x10)) | (gsw140_xpcs_serdes_cfg.tx_vboost_en<<4)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port=%d); = 0x%x\n", port, read_data);
+
+	/* PHY RX attenuation Level */
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_ATTN_CTRL, LVL, lane_cfg->rx_attn_lvl, lane * 4);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,((read_data & (~0x7)) | (gsw140_xpcs_serdes_cfg.rx_attn_lvl)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port=%d); = 0x%x\n", port, read_data);
+
+	/* PHY ctle_pole and boost and gain register 
+		boost_gain = ((lane_cfg->rx_vga1_gain & 0x0F) << 12)
+		     | ((lane_cfg->rx_vga2_gain & 0x0F) << 8)
+		     | ((lane_cfg->rx_ctle_pole & 0x07) << 5)
+		     | (lane_cfg->rx_ctle_boost & 0x1F);
+		XPCS_RGWR(pdata, PMA_RX_EQ_CTRL0 + lane * 4, boost_gain);
+	*/
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,((gsw140_xpcs_serdes_cfg.rx_ctle_boost<<0) | (gsw140_xpcs_serdes_cfg.rx_ctle_pole<<5) | (gsw140_xpcs_serdes_cfg.rx_vga2_gain<<8) | (gsw140_xpcs_serdes_cfg.rx_vga1_gain<<12)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_PPM_CTRL0, CDR_PPM_MAX, mode_cfg->cdr_ppm_max, lane * 8);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,((read_data & (~0x1f)) | (gsw140_xpcs_mode_cfg.cdr_ppm_max)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_CDR_CTRL1, VCO_TEMP_COMP_EN, mode_cfg->vco_temp_comp_en, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,((read_data & (~0x1)) | (gsw140_xpcs_mode_cfg.vco_temp_comp_en)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_CDR_CTRL1, VCO_STEP_CTRL, mode_cfg->vco_step_ctrl, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,((read_data & (~0x10)) | (gsw140_xpcs_mode_cfg.vco_step_ctrl<<4)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_CDR_CTRL1, VCO_FRQBAND, mode_cfg->vco_frqband, lane * 2);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,((read_data & (~0x300)) | (gsw140_xpcs_mode_cfg.vco_frqband<<8)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_OFF_SHIFT(pdata, PMA_RX_MISC_CTRL0, MISC, mode_cfg->rx_misc, lane / 2, (lane & 1) * 8);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,((read_data & (~0xff)) | (gsw140_xpcs_mode_cfg.rx_misc)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_GEN_CTRL4, DFE_BYP, lane_cfg->rx_dfe_bypass, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,((read_data & (~0x100)) | (gsw140_xpcs_serdes_cfg.rx_dfe_bypass<<8)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_OFF_SHIFT(pdata, PMA_DFE_TAP_CTRL0, DFE_TAP1, mode_cfg->rx_dfe_tap1, lane / 2, (lane & 1) * 8);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,((read_data & (~0xff)) | (gsw140_xpcs_mode_cfg.rx_dfe_tap1)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_OFF(pdata, PMA_RX_IQ_CTRL, DELTA_IQ, mode_cfg->rx_delta_iq, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,((read_data & (~0xf00)) | (gsw140_xpcs_mode_cfg.rx_delta_iq<<8)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_OFF(pdata, PMA_RX_IQ_CTRL, MARGIN_IQ, mode_cfg->rx_margin_iq, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,((read_data & (~0x7f)) | (gsw140_xpcs_mode_cfg.rx_margin_iq)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_EQ_CTRL5, ADPT_SEL, mode_cfg->adpt_sel, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,((read_data & (~0x1)) | (gsw140_xpcs_mode_cfg.adpt_sel)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_EQ_CTRL5, ADPT_MODE, mode_cfg->adpt_mode, lane);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,((read_data & (~0x30)) | (gsw140_xpcs_mode_cfg.adpt_mode<<4)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port=%d); = 0x%x\n", port, read_data);
+
+	/* PHY LOS threshold register */
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_RX_GENCTRL3, LOS_TRSHLD, mode_cfg->los_thr, lane * 3);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,((read_data & (~0x7)) | (gsw140_xpcs_mode_cfg.los_thr)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port=%d); = 0x%x\n", port, read_data);
+
+	/* Rx Biasing Current Control for Rx analog front end */
+	//XPCS_RGWR_VAL(pdata, PMA_MISC_C0, RX_VREF_CTRL, mode_cfg->rx_vref_ctrl);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,((read_data & (~0x1f00)) | (gsw140_xpcs_mode_cfg.rx_vref_ctrl<<8)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL(pdata, PMA_MISC_CTRL2, SUP_MISC, 1);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MISC_CTRL2,((read_data & (~0xff)) | (1)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port=%d); = 0x%x\n", port, read_data);
+}
+
+void tx_eq_config_sgmii_2500basex(int port)
+{
+/*
+	tx_eq0 = XPCS_RGRD(pdata, PMA_TX_EQ_C0);
+
+	XPCS_SET_VAL(tx_eq0, PMA_TX_EQ_C0, TX_EQ_MAIN,
+		     lane_cfg->tx_eq_main);
+	XPCS_SET_VAL(tx_eq0, PMA_TX_EQ_C0, TX_EQ_PRE,
+		     lane_cfg->tx_eq_pre);
+
+	XPCS_RGWR(pdata, PMA_TX_EQ_C0, tx_eq0);
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,((read_data & (~0x3f3f)) | (gsw140_xpcs_serdes_cfg.tx_eq_main<<8)  | (gsw140_xpcs_serdes_cfg.tx_eq_pre<<0)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,port=%d); = 0x%x\n", port, read_data);
+
+/*
+	tx_eq1 = XPCS_RGRD(pdata, PMA_TX_EQ_C1);
+
+	XPCS_SET_VAL(tx_eq1, PMA_TX_EQ_C1, TX_EQ_POST,
+		     lane_cfg->tx_eq_post);
+	XPCS_SET_VAL(tx_eq1, PMA_TX_EQ_C1, TX_EQ_OVR_RIDE,
+		     lane_cfg->tx_eq_ovrride);
+
+	XPCS_RGWR(pdata, PMA_TX_EQ_C1, tx_eq1);
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,((read_data & (~0x7f)) | (gsw140_xpcs_serdes_cfg.tx_eq_ovrride<<6)  | (gsw140_xpcs_serdes_cfg.tx_eq_post<<0)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,port=%d); = 0x%x\n", port, read_data);
+
+	//XPCS_RGWR_VAL_SHIFT(pdata, PMA_TX_BOOST_CTRL, TX0_IBOOST, lane_cfg->tx_iboost_lvl, lane * 4);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,((read_data & (~0xf)) | (gsw140_xpcs_serdes_cfg.tx_iboost_lvl)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,port=%d); = 0x%x\n", port, read_data);
+}
+
+void kr_workaround(int port)
+{
+	//XPCS_RGWR_VAL(pdata, PMA_TX_GENCTRL1, CLK_RDY, 1);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,((read_data & (~0x1000)) | (1<<12)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port=%d); = 0x%x\n", port, read_data);
+
+	/*
+	bit6 RX_DT_EN_CTL. 
+	bit4 SUPRESS_LOS_DET
+
+	val = XPCS_RGRD(pdata, PCS_DBG_CTRL);
+	XPCS_SET_VAL(val, PCS_DBG_CTRL, RX_DT_EN, 1);
+	XPCS_SET_VAL(val, PCS_DBG_CTRL, SUPRESS_LOST_DET, 1);
+	XPCS_RGWR(pdata, PCS_DBG_CTRL, val);
+	*/
+	indirect_pcs_rd(PCS_DBG_CTRL,port);
+	indirect_pcs_wr(PCS_DBG_CTRL,((read_data & (~0x50)) | (0x50)),port);
+	indirect_pcs_rd(PCS_DBG_CTRL,port);
+	LGM_NET_DBG("indirect_pcs_rd(PCS_DBG_CTRL,port=%d); = 0x%x\n", port, read_data);
+}
+
+/* XPCS Vendor Specific Soft Reset
+ * When the host sets this bit, the CSR block triggers the software reset
+ * process in which all internal blocks are reset, except the Management
+ * Interface block and CSR block.
+ * When this bit is set, it also resets the PHY.
+ * This bit is self cleared
+ */
+static int xpcs_vs_reset_sgmii_2500basex(int port)
+{
+	u32 idx = 0;
+
+	//sram_ext_ld_done(pdata, 0);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_SRAM,port);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_SRAM,((read_data & (~0x2)) | (0x0)),port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_SRAM,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_SRAM,port=%d); = 0x%x\n", port, read_data);
+
+/*
+#define VR_XS_PCS_DIG_CTRL1                            0x0E0000
+bit15 = VR_RST
+*/
+	//XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PCS_DIG_CTRL1, 0x1, 15, 1, 0);
+	//XPCS_RGWR_VAL(pdata, PCS_DIG_CTRL1, VR_RST, 1);
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,((read_data & (~0x8000)) | (1<<15)),port);
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	LGM_NET_DBG("indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port=%d); = 0x%x\n", port, read_data);
+
+	sram_init_chk(port, 0);
+
+	do {
+/*
+#define VR_XS_PCS_DIG_CTRL1                            0x0E0000
+bit15 = VR_RST
+*/
+		if (!(indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port) & (1 << 15)))
+			break;
+
+		/* To put a small delay and make sure previous operations
+		 * are complete
+		 */
+		udelay(20);
+	} while (++idx < 2000);
+
+	if (idx >= 2000) {
+		printf("Timeout on polling VR_RST clear to 0. \n");
+		return -EIO;
+	}
+
+	check_rxtx_stable(port);
+
+	return 0;
+}
+
+int phy_calibrate(int port)
+{
+	u32 cr_base;
+	int i, lane = 0;
+
+	u32 PCS_XF_ATE_OVRD_IN_2 = 0x3008;
+	u32 PCS_XF_RX_ADAPT_ACK = 0x3010;
+
+	u32 RAWLANE0_DIG_PCS_XF_ATE_OVRD_IN_2_X2;
+	u32 RAWLANE0_DIG_PCS_XF_RX_ADAPT_ACK_X2;
+
+	if(port == COMBO_PORT20)
+		cr_base = 0xc0a00000;
+
+	if(port == COMBO_PORT21)
+		cr_base = 0xc0b00000;
+
+	RAWLANE0_DIG_PCS_XF_ATE_OVRD_IN_2_X2 	= cr_base + (((PCS_XF_ATE_OVRD_IN_2) + (lane) * 0x100) << 2);
+	RAWLANE0_DIG_PCS_XF_RX_ADAPT_ACK_X2 	= cr_base + (((PCS_XF_RX_ADAPT_ACK) + (lane) * 0x100) << 2);
+
+	/* trigger auto RX adaptation */
+	//cbphy_w32_off_mask(cr_base, ADAPT_REQ, 3, 3, CR_ADDR(PCS_XF_ATE_OVRD_IN_2, id));
+	REG32(RAWLANE0_DIG_PCS_XF_ATE_OVRD_IN_2_X2) |= 3 << 4;
+	LGM_NET_DBG("port=%d,REG32(RAWLANE0_DIG_PCS_XF_ATE_OVRD_IN_2_X2) = 0x%x\n",port, REG32(RAWLANE0_DIG_PCS_XF_ATE_OVRD_IN_2_X2));
+
+	for(i=0;i<500;i++){
+		if((REG32(RAWLANE0_DIG_PCS_XF_RX_ADAPT_ACK_X2) & 1) == 1)
+			break;
+		udelay(10);
+	}
+
+	if(i>=500)
+		LGM_NET_DBG("port=%d,RX Adaptation failed! \n",port);
+	else
+		LGM_NET_DBG("port=%d,RX Adaptation success! \n",port);
+
+	/* Stop RX adaptation */
+	//cbphy_w32_off_mask(cr_base, ADAPT_REQ, 3, 0, CR_ADDR(PCS_XF_ATE_OVRD_IN_2, id));
+	REG32(RAWLANE0_DIG_PCS_XF_ATE_OVRD_IN_2_X2) &= ~(3 << 4);
+	LGM_NET_DBG("port=%d,REG32(RAWLANE0_DIG_PCS_XF_ATE_OVRD_IN_2_X2) = 0x%x\n",port, REG32(RAWLANE0_DIG_PCS_XF_ATE_OVRD_IN_2_X2));
+
+	return 0;
+}
+
+void init_xpcs_sgmii_2500basex(int p0_id, int p1_id, int p0_spd, int p1_spd)
+{
+	int base1000x_en = 0;
+	int ret;
+
+	//XPCS1 XGMII interface clock is disabled
+	REG32(HSIOR_TOP_BASE + XPCS1_XGMII_CLK_CTR) = 0;
+	//XPCS0 XGMII interface clock is disabled
+	REG32(HSIOR_TOP_BASE + XPCS0_XGMII_CLK_CTR) = 0;
+
+	sram_init_chk(p0_id, base1000x_en);
+
+	check_rxtx_stable(p1_id);
+	xpcs_disable_an_gsw140(p1_id);
+	xpcs_set_mode_2500basex(p1_id);
+
+	check_rxtx_stable(p0_id);
+	xpcs_disable_an_gsw140(p0_id);
+	xpcs_set_mode_2500basex(p0_id);
+
+	xpcs_cfg_clk_pair(p0_id, p1_id);
+
+	xpcs_cfg_table(p1_id);
+	xpcs_cfg_table(p0_id);
+
+	ret = xpcs_vs_reset_sgmii_2500basex(p0_id);
+	if (ret)
+		return;
+
+	tx_eq_config_sgmii_2500basex(p0_id);
+	kr_workaround(p0_id);
+
+	tx_eq_config_sgmii_2500basex(p1_id);
+	kr_workaround(p1_id);
+
+	//xpcs_an(pdata);->xpcs_disable_an(pdata);
+	//xpcs_an(pair_pdata);->xpcs_disable_an(pair_pdata);
+	xpcs_disable_an_gsw140(p0_id);
+	xpcs_disable_an_gsw140(p1_id);
+
+	phy_calibrate(p0_id);
+	phy_calibrate(p1_id);
+
+	//XPCS0 XGMII interface clock is disabled
+	REG32(HSIOR_TOP_BASE + XPCS0_XGMII_CLK_CTR) = 1;
+	//XPCS1 XGMII interface clock is disabled
+	REG32(HSIOR_TOP_BASE + XPCS1_XGMII_CLK_CTR) = 1;
+}
+#endif
+
+void init_xpcs(int p0_id, int p1_id, int p0_spd, int p1_spd)
+{
+	int an_73_p0 = 0, an_73_p1 = 0;
+
+	/* Configure XPCS1/XPCS3 first so that XCPS0/XPCS2 will
+	 * trigger VR reset with MPLL configuration.
+	 */
+	if (p1_spd == XFI_10G_KR_NO_ANEG || p1_spd == XFI_10G_KR) {
+		pma_type = PMA_TYPE_10G_BASE_KR;
+
+		if (p1_spd == XFI_10G_KR_NO_ANEG)
+			auto_10g_enable = 0;
+		else if (p1_spd == XFI_10G_KR)
+			auto_10g_enable = 1;
+
+		an_73_p1 = auto_10g_enable;
+		xfi_10g5g2p5g_kr_cl73_bringup(p1_id, KR_10G);
+	} else if (p1_spd == SGMII_1G || p1_spd == SGMII_1000BASEX) {
+		pma_type = PMA_TYPE_1G_BASE_KX;
+		if (p1_spd == SGMII_1000BASEX)
+			autoneg_1g = 0;
+		else if (p1_spd == SGMII_1G)
+			autoneg_1g = 1;
+		base_1g_bringup(p1_id);
+	}
+
+	/* Configure Port1 first. Don't do VR reset */
+	if (p0_spd == XFI_10G_KR_NO_ANEG || p0_spd == XFI_10G_KR) {
+		pma_type = PMA_TYPE_10G_BASE_KR;
+		if (p0_spd == XFI_10G_KR_NO_ANEG)
+			auto_10g_enable = 0;
+		else if (p0_spd == XFI_10G_KR)
+			auto_10g_enable = 1;
+
+		an_73_p0 = auto_10g_enable;
+		xfi_10g5g2p5g_kr_cl73_bringup(p0_id, KR_10G);
+		if (an_73_p0 == 0)
+			disable_an(p0_id);
+		if (an_73_p1 == 0)
+			disable_an(p1_id);
+	} else if (p0_spd == SGMII_1G || p0_spd == SGMII_1000BASEX) {
+		pma_type = PMA_TYPE_1G_BASE_KX;
+		if (p0_spd == SGMII_1000BASEX)
+			autoneg_1g = 0;
+		else if (p0_spd == SGMII_1G)
+			autoneg_1g = 1;
+		base_1g_bringup(p0_id);
+	}
+}
+
+int verify_reset_status(int p0_id, int p1_id)
+{
+	int i;
+
+	if (PON_WAN_PORT4 == p1_id) {
+		for (i = 0; i < RST_STAT_CHK_CNT; i++) {
+			if (pon_shell_rst_stat() != 1) {
+				LGM_NET_DBG("RCU ETHNOC PON resets deasserted\n");
+				break;
+			}
+			udelay(10);
+		}
+
+		if (i > RST_STAT_CHK_CNT) {
+			printf("RCU ETHNOC PON resets failed to de-assert");
+			return -1;
+		}
+		return 0;
+	}
+
+	for (i = 0; i < RST_STAT_CHK_CNT; i++) {
+		if ((combophy_rst_stat(p0_id) != 1
+				&& combophy_rst_stat(p1_id))  != 1) {
+			LGM_NET_DBG("COMBOPHY resets deasserted\n");
+			break;
+		}
+		udelay(10);
+	}
+
+	if (i > RST_STAT_CHK_CNT) {
+		printf("COMBOPHY resets failed to de-assert");
+		return -1;
+	}
+
+	for (i = 0; i < RST_STAT_CHK_CNT; i++) {
+		if ((xpcs_rst_stat(p0_id) != 1 &&
+			xpcs_rst_stat(p1_id))  != 1) {
+			LGM_NET_DBG("XPCS resets deasserted\n");
+			break;
+		}
+		udelay(10);
+	}
+
+	if (i > RST_STAT_CHK_CNT) {
+		printf("XPCS resets failed to de-assert");
+		return -1;
+	}
+
+	for (i = 0; i < RST_STAT_CHK_CNT; i++) {
+		if (eth_phy_rst_stat(p0_id) != 1) {
+			LGM_NET_DBG("PHY10 resets deasserted\n");
+			break;
+		}
+	}
+
+	if (i > RST_STAT_CHK_CNT) {
+		printf("PHY10 resets failed to de-assert");
+		return -1;
+	}
+
+	return 0;
+}
+
+void read_mpll_state(int port)
+{
+#ifdef LGM_NET_VERBOSE
+	u32 val;
+
+	/* boot time optimization */
+	/* mdelay(1000); */
+
+	if(port!= P34X_PORT5)
+		val = REG32(SUP_DIG_ASIC_IN(port));
+	else
+		val = serdes_cr_read(port, SUP_DIG_ASIC_IN_OFFSET);
+
+	LGM_NET_DBG("Port %d: SUP_DIG_ASIC_IN 0x%08x MPLLA_STATE %s\n",
+		port, val, (val & MPLLA_STATE)? "set": "clr");
+	LGM_NET_DBG("Port %d: SUP_DIG_ASIC_IN 0x%08x MPLLB_STATE %s\n",
+		port, val, (val & MPLLB_STATE)? "set": "clr");
+#endif /* LGM_NET_VERBOSE */
+}
+
+int gswip_xpcs5_init_rtl8261(int spd)
+{
+	int i;
+
+	//Configuring COMBOPHY Mode
+	//combophy_mode(P34X_PORT5, DUAL_ETH); //Only need to configure once for either PORT10 or PORT20
+
+	//Assert RESET of COMBOPHY, PHY10/11 and XPCS0/1 first
+	combophy_rst_assert(P34X_PORT5);
+	eth_phy_rst_assert(P34X_PORT5);
+	xpcs_rst_assert(P34X_PORT5);
+
+	//De-assert WAN/COMBOPHY Subsystem Reset, PHY0/1/2 Reset, XPCS0/1/2 Reset
+	combophy_rst_deassert(P34X_PORT5);
+	eth_phy_rst_deassert(P34X_PORT5);
+	xpcs_rst_deassert(P34X_PORT5);
+
+	//check for rst_status to ensure reset is clear
+	for (i = 0; i < RST_STAT_CHK_CNT; i++) {
+		if ((combophy_rst_stat(P34X_PORT5) != 1
+			&& eth_phy_rst_stat(P34X_PORT5) !=1
+			&& xpcs_rst_stat(P34X_PORT5))!= 1) {
+			LGM_NET_DBG("Port%d COMBOPHY, PHY, XPCS resets deasserted\n", P34X_PORT5);
+			break;
+		}
+		udelay(10);
+	}
+
+	if (i > RST_STAT_CHK_CNT)
+		printf("COMBOPHY, PHY, XPCS resets failed to de-assert");
+
+	LGM_NET_DBG("SRAM Init for Port %d\n", P34X_PORT5);
+	sram_init_chk(P34X_PORT5, 0);
+
+	mdelay(20);
+
+	//Bring Up XPCS and Serdes
+	usxgmii_init(P34X_PORT5, KR_10G, USX_SINGLE);
+	//Enable RX auto adapt //Must disable for short link
+	//phy_rxeq_autoadapt(P34X_PORT5, LANE0);
+	LGM_NET_DBG("\n P34X/XPCS5 XPCS and Serdes Port%d Bring Up Completed.\n", P34X_PORT5);
+	return 0;
+}
+
+int gswip_xpcs5_init(int spd)
+{
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	struct tx_eq *txeq = &tx_presets[TX_PRST_4];
+	int i;
+
+	pma_type = PMA_TYPE_10G_BASE_KR;
+	//Initialize combo phy global settings.
+	//combo_global_init(P34X_PORT5);
+	init_combo_base(&paddr[P34X_PORT5], P34X_PORT5);
+
+	// Configure LJPLL3 to 156.25Mhz+15ppm or 156.25Mhz
+	//ljpll3_cfg_frac_eth(); //156.25Mhz+15ppm
+
+	//Enable Clock for XPCS
+	hsiotop_clk_gate_cfg(P34X_PORT5, 0); //0 means disable glock gate.
+
+	//Configuring COMBOPHY Mode
+	//combophy_mode(P34X_PORT5, DUAL_ETH); //Only need to configure once for either PORT10 or PORT20
+
+	//Assert RESET of COMBOPHY, PHY10/11 and XPCS0/1 first
+	combophy_rst_assert(P34X_PORT5);
+	eth_phy_rst_assert(P34X_PORT5);
+	xpcs_rst_assert(P34X_PORT5);
+
+	//De-assert WAN/COMBOPHY Subsystem Reset, PHY0/1/2 Reset, XPCS0/1/2 Reset
+	combophy_rst_deassert(P34X_PORT5);
+	eth_phy_rst_deassert(P34X_PORT5);
+	xpcs_rst_deassert(P34X_PORT5);
+
+	//check for rst_status to ensure reset is clear
+	for (i = 0; i < RST_STAT_CHK_CNT; i++) {
+		if ((combophy_rst_stat(P34X_PORT5) != 1
+			&& eth_phy_rst_stat(P34X_PORT5) !=1
+			&& xpcs_rst_stat(P34X_PORT5))!= 1) {
+			LGM_NET_DBG("Port%d COMBOPHY, PHY, XPCS resets deasserted\n", P34X_PORT5);
+			break;
+		}
+		udelay(10);
+	}
+
+	if (i > RST_STAT_CHK_CNT)
+		printf("COMBOPHY, PHY, XPCS resets failed to de-assert");
+
+	LGM_NET_DBG("SRAM Init for Port %d\n", P34X_PORT5);
+	sram_init_chk(P34X_PORT5, 0);
+
+	mdelay(20);
+
+	//Bring Up XPCS and Serdes
+	usxgmii_init(P34X_PORT5, KR_10G, USX_QUAD);
+
+	//Do VR Reset for XPCS Master
+	vr_reset(P34X_PORT5, 0);
+
+	//Poll VR Reset Clear Bit and PHY Power Stable.
+	vr_reset_poll(P34X_PORT5);
+
+	check_rxtx_stable(P34X_PORT5);
+
+	//Configure TX EQ after VR Reset
+	tx_eq_config(P34X_PORT5, txeq);
+
+	if(usxgmii_bringup(P34X_PORT5, KR_10G, USX_QUAD))
+		return -1;
+
+	//READ MPLLA/B state
+	read_mpll_state(P34X_PORT5);
+
+	//Enable RX auto adapt //Must disable for short link
+	//phy_rxeq_autoadapt(P34X_PORT5, LANE0);
+	LGM_NET_DBG("\n P34X/XPCS5 XPCS and Serdes Port%d Bring Up Completed.\n", P34X_PORT5);
+	return 0;
+}
+
+int wan_init(int spd)
+{
+	int ret;
+	struct combo_port *paddr = &g_combo_port_defs[0];
+	int epon_en = 0;
+
+	/* Initialize combo phy global settings. */
+	init_combo_base(&paddr[PON_WAN_PORT4], PON_WAN_PORT4);
+
+	/* De-assert RESET of PON SHELL TOP Reset from RCU */
+	pon_shell_rst_deassert();
+
+	/* check for rst_status to ensure reset is clear */
+	ret = verify_reset_status(NULL_ARG, PON_WAN_PORT4);
+	if (ret)
+		return ret;
+
+	/* Change APB timer APB_CLKFREQ from 'd500 to 'd200 as it is wrong by default in PON_SHELL_APB_APP */
+	SET_X_BITS(REG32(PON_IP_SHELL_APB_APP),0,10,200);
+
+	/* Disable SRAM Bypass BIT0 */
+	SET_X_BITS(REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_SRAM_CSR), SRAM_BYPASS_POS, SRAM_BYPASS_WIDTH, 0X0); /* BIT0 SRAM_BYPASS = To disable SRAM_BYPASS */
+	LGM_NET_DBG("Disable SRAM BYPASS:\n PON_SHELL_SRAM_CSR(0x%08x) = 0x%08x\n",
+			REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_SRAM_CSR),
+			REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_SRAM_CSR));
+
+	/* Enable CML MUX to Reference Clock */
+	/* PON_SHELL_GEN_CTRL */
+	/* REF_CLK_EN */
+	/* u32 PON_SHELL_GEN_CTRL_LOCAL = (PON_WAN_PHY_APP_BASE + PON_SHELL_GEN_CTRL); */
+	SET_X_BITS(REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL), REF_CLK_EN_POS,
+			REF_CLK_EN_WIDTH, 0X1); /* BIT16 REF_CLK_EN = Enable Reference Clock for PHY. */
+	LGM_NET_DBG("Enable CML MUX to Reference Clock:\n PON_SHELL_GEN_CTRL(0x%08x) = 0x%08x\n",
+				REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),
+				REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL));
+
+	/* Init PON Shell CLK_GATE, PHY/XPCS RST, REFCLKEN, PCS/PMA Power Stable */
+	pon_shell_wan_init(epon_en);
+
+	/* Enable REFLCK BIT16 of PON_SHELL_GEN_CTRL.REFCLK_EN */
+	/* SET_X_BITS(REG32(PON_WAN_PHY_APP_BASE+PON_SHELL_GEN_CTRL),REF_CLK_EN_POS,REF_CLK_EN_WIDTH,0x1); */
+
+	/* Set SRAM_EXT_LD_DONE */
+	/* xpcs4_sram_init(); */
+	LGM_NET_DBG("SRAM Init for Port %d\n", PON_WAN_PORT4);
+	ret = sram_init_chk(PON_WAN_PORT4, 0);
+	if (ret)
+		return ret;
+
+	/* Override RES_ACK workaround */
+	serdes_cal_ovrd(PON_WAN_PORT4);
+	init_xpcs(NULL_ARG, PON_WAN_PORT4, NULL_ARG, spd);
+
+	/* READ MPLLA/B state */
+	read_mpll_state(PON_WAN_PORT4);
+
+	/* Enable RX auto adapt */
+	phy_rxeq_autoadapt(PON_WAN_PORT4, LANE0);
+
+	LGM_NET_DBG("\n WAN XPCS and Serdes Port%d Bring Up Done.\n", PON_WAN_PORT4);
+
+	LGM_NET_DBG("\n <linkup_status(PON_WAN_PORT4)> first call\n");
+	linkup_status(PON_WAN_PORT4);
+	LGM_NET_DBG("\n <linkup_status(PON_WAN_PORT4)> second call\n");
+	linkup_status(PON_WAN_PORT4);
+
+#ifdef CONFIG_WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G
+	/*disable_xpcs_clk(HSIOR_TOP_BASE);*/
+	LGM_NET_DBG("SRAM Init for Port %d\n", PON_WAN_PORT4);
+	ret = sram_init_chk(PON_WAN_PORT4, 0);
+	if (ret)
+		return ret;
+
+	check_rxtx_stable(PON_WAN_PORT4);
+	set_mode_usxgmii(PON_WAN_PORT4);
+	xpcs_disable_an(PON_WAN_PORT4);
+	xpcs_cfg_clk(PON_WAN_PORT4);
+	xpcs_cfg_table(PON_WAN_PORT4);
+	xpcs_vs_reset(PON_WAN_PORT4);
+	tx_eq_config_kernel(PON_WAN_PORT4);
+	KR_workaround(PON_WAN_PORT4);
+	xpcs_an(PON_WAN_PORT4);
+	/*enable_xpcs_clk(HSIOR_TOP_BASE);*/
+
+#endif
+	return 0;
+}
+
+#if !defined(CONFIG_LIGHTNING_A0)
+static void enable_xpcs_clk(u32 base)
+{
+	/* Enable XPCS clk before initializing.
+	 * This is only needed in LGM B0
+	 */
+	REG32(base + XPCS0_XGMII_CLK_CTR) = HSIO_TOP_XGMII_CLK_EN;
+	REG32(base + XPCS1_XGMII_CLK_CTR) = HSIO_TOP_XGMII_CLK_EN;
+}
+#if defined(CONFIG_LAN_HSIO_R_USXGMII_10G)
+static void disable_xpcs_clk(u32 base)
+{
+	/* Enable XPCS clk before initializing.
+	 * This is only needed in LGM B0
+	 */
+	REG32(base + XPCS0_XGMII_CLK_CTR) = 0;
+	REG32(base + XPCS1_XGMII_CLK_CTR) = 0;
+}
+#endif
+#else
+static void enable_xpcs_clk(u32 base) {};
+#endif /* !CONFIG_LIGHTNING_A0 */
+
+#if defined(CONFIG_LAN_HSIO_R_USXGMII_10G ) || defined(CONFIG_WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G) || defined(CONFIG_XPCS5_USXGMII_RTL8261)
+static void xpcs_usxgmii_an(u32 xpcs_prt)
+{
+	int i;
+
+/*SR_AN_CTRL
+BIT12,AN_EN*/
+	indirect_pcs_rd(SR_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(SR_AN_CTRL, (read_data & (~(0x1 << 12))), xpcs_prt);
+
+/*VR_XS_PCS_DIG_CTRL1
+BIT12,CL37_BP*/
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1, ((read_data & (~(0x1 << 12))) | (0x1 << 12)), xpcs_prt);
+
+/*VR_MII_AN_CTRL
+BIT0,MII_AN_INTR_EN*/
+	indirect_pcs_rd(VR_MII_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_AN_CTRL, ((read_data & (~(0x1 << 0))) | (0x1 << 0)), xpcs_prt);
+
+/*VR_MII_AN_CTRL
+BIT3,TX_CONFIG*/
+	indirect_pcs_rd(VR_MII_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_AN_CTRL, ((read_data & (~(0x1 << 3))) | (0x0 << 3)), xpcs_prt);
+
+/*VR_MII_AN_CTRL
+BIT4,SGMII_LINK_STS*/
+	indirect_pcs_rd(VR_MII_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_AN_CTRL, ((read_data & (~(0x1 << 4))) | (0x1 << 4)), xpcs_prt);
+
+/*VR_MII_AN_CTRL
+BIT8,MII_CONTROL*/
+	indirect_pcs_rd(VR_MII_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_AN_CTRL, ((read_data & (~(0x1 << 8))) | (0x1 << 8)), xpcs_prt);
+
+/*VR_MII_1_AN_CTRL
+BIT0,MII_AN_INTR_EN
+BIT3,TX_CONFIG
+BIT4,SGMII_LINK_STS
+BIT8,MII_CONTROL*/
+	indirect_pcs_rd(VR_MII_1_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_1_AN_CTRL, ((read_data & (~(0x119 << 0))) | (0x111 << 0)), xpcs_prt);
+
+/*VR_MII_2_AN_CTRL
+BIT0,MII_AN_INTR_EN
+BIT3,TX_CONFIG
+BIT4,SGMII_LINK_STS
+BIT8,MII_CONTROL*/
+	indirect_pcs_rd(VR_MII_2_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_2_AN_CTRL, ((read_data & (~(0x119 << 0))) | (0x111 << 0)), xpcs_prt);
+
+/*VR_MII_3_AN_CTRL
+BIT0,MII_AN_INTR_EN
+BIT3,TX_CONFIG
+BIT4,SGMII_LINK_STS
+BIT8,MII_CONTROL*/
+	indirect_pcs_rd(VR_MII_3_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_3_AN_CTRL, ((read_data & (~(0x119 << 0))) | (0x111 << 0)), xpcs_prt);
+
+/*VR_MII_DIG_CTRL1
+BIT9,MAC_AUTO_SW*/
+	indirect_pcs_rd(VR_MII_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_DIG_CTRL1, ((read_data & (~(0x1 << 9))) | (0x1 << 9)), xpcs_prt);
+
+/*VR_MII_1_DIG_CTRL1
+BIT9,MAC_AUTO_SW*/
+	indirect_pcs_rd(VR_MII_1_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_1_DIG_CTRL1, ((read_data & (~(0x1 << 9))) | (0x1 << 9)), xpcs_prt);
+
+/*VR_MII_2_DIG_CTRL1
+BIT9,MAC_AUTO_SW*/
+	indirect_pcs_rd(VR_MII_2_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_2_DIG_CTRL1, ((read_data & (~(0x1 << 9))) | (0x1 << 9)), xpcs_prt);
+
+/*VR_MII_3_DIG_CTRL1
+BIT9,MAC_AUTO_SW*/
+	indirect_pcs_rd(VR_MII_3_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_3_DIG_CTRL1, ((read_data & (~(0x1 << 9))) | (0x1 << 9)), xpcs_prt);
+
+/*VR_MII_LINK_TIMER_CTRL
+BIT15:0,CL37_LINK_TIME*/
+	indirect_pcs_rd(VR_MII_LINK_TIMER_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_LINK_TIMER_CTRL, ((read_data & (~(0xffff << 0))) | (0x3d1 << 0)), xpcs_prt);
+
+/*VR_MII_DIG_CTRL1
+BIT3,CL37_TMR_OVR_RIDE*/
+	indirect_pcs_rd(VR_MII_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_DIG_CTRL1, ((read_data & (~(0x1 << 3))) | (0x1 << 3)), xpcs_prt);
+
+/*VR_MII_1_DIG_CTRL1
+BIT3,CL37_TMR_OVR_RIDE*/
+	indirect_pcs_rd(VR_MII_1_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_1_DIG_CTRL1, ((read_data & (~(0x1 << 3))) | (0x1 << 3)), xpcs_prt);
+
+/*VR_MII_2_DIG_CTRL1
+BIT3,CL37_TMR_OVR_RIDE*/
+	indirect_pcs_rd(VR_MII_2_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_2_DIG_CTRL1, ((read_data & (~(0x1 << 3))) | (0x1 << 3)), xpcs_prt);
+
+/*VR_MII_3_DIG_CTRL1
+BIT3,CL37_TMR_OVR_RIDE*/
+	indirect_pcs_rd(VR_MII_3_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_3_DIG_CTRL1, ((read_data & (~(0x1 << 3))) | (0x1 << 3)), xpcs_prt);
+
+/*SR_MII_CTRL
+BIT12,AN_ENABLE*/
+	indirect_pcs_rd(SR_MII_CTRL, xpcs_prt);
+	indirect_pcs_wr(SR_MII_CTRL, ((read_data & (~(0x1 << 12))) | (0x1 << 12)), xpcs_prt);
+
+/*SR_MII_1_CTRL
+BIT12,AN_ENABLE*/
+	indirect_pcs_rd(SR_MII_1_CTRL, xpcs_prt);
+	indirect_pcs_wr(SR_MII_1_CTRL, ((read_data & (~(0x1 << 12))) | (0x1 << 12)), xpcs_prt);
+
+/*SR_MII_2_CTRL
+BIT12,AN_ENABLE*/
+	indirect_pcs_rd(SR_MII_2_CTRL, xpcs_prt);
+	indirect_pcs_wr(SR_MII_2_CTRL, ((read_data & (~(0x1 << 12))) | (0x1 << 12)), xpcs_prt);
+
+/*SR_MII_3_CTRL
+BIT12,AN_ENABLE*/
+	indirect_pcs_rd(SR_MII_3_CTRL, xpcs_prt);
+	indirect_pcs_wr(SR_MII_3_CTRL, ((read_data & (~(0x1 << 12))) | (0x1 << 12)), xpcs_prt);
+
+	for (i = 0; i <= MAX_BUSY_RETRY; i++) {
+		indirect_pcs_rd(VR_MII_AN_INTR_STS, xpcs_prt);
+		if (read_data & 1) {
+			indirect_pcs_wr(VR_MII_AN_INTR_STS, ((read_data & (~(0x1 << 0))) | (0x0 << 0)), xpcs_prt);
+			break;
+		}
+		udelay(500);
+	}
+
+	/* 17. Wait for some time so that clocks at clk_xgmii_tx_i and
+	 * clk_xgmii_rx_i ports get stabilized at the desired frequencies.
+	 */
+	mdelay(100);
+
+/*VR_XS_PCS_DIG_CTRL1
+bit10:USRA_RST*/
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1, ((read_data & (~(0x1 << 10))) | (0x1 << 10)), xpcs_prt);
+	for (i = 0; i <= MAX_BUSY_RETRY; i++) {
+		indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, xpcs_prt);
+		if (!(read_data & (0x1 << 10)))
+			break;
+		udelay(10);
+	}
+}
+
+static void xpcs_an(u32 xpcs_prt)
+{
+	xpcs_disable_an(xpcs_prt);
+	xpcs_usxgmii_an(xpcs_prt);
+}
+
+/* XPCS Vendor Specific Soft Reset
+ * When the host sets this bit, the CSR block triggers the software reset
+ * process in which all internal blocks are reset, except the Management
+ * Interface block and CSR block.
+ * When this bit is set, it also resets the PHY.
+ * This bit is self cleared
+ */
+static int xpcs_vs_reset(u32 xpcs_prt)
+{
+	u32 idx = 0;
+/*
+#define VR_XS_PCS_DIG_CTRL1                            0x0E0000
+bit15 = VR_RST
+*/
+	XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PCS_DIG_CTRL1, 0x1, 15, 1, 0);
+	sram_init_chk(xpcs_prt, 0);
+
+	do {
+/*
+#define VR_XS_PCS_DIG_CTRL1                            0x0E0000
+bit15 = VR_RST
+*/
+		if (!(XPCS_RGRD(xpcs_prt, VR_XS_PCS_DIG_CTRL1) & (1 << 15)))
+			break;
+
+		/* To put a small delay and make sure previous operations
+		 * are complete
+		 */
+		udelay(20);
+	} while (++idx < MAX_BUSY_RETRY);
+
+	if (idx >= MAX_BUSY_RETRY) {
+		printf("Timeout on polling VR_RST clear to 0. \n");
+		return -EIO;
+	}
+
+	check_rxtx_stable(xpcs_prt);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_XPCS5_USXGMII_RTL8261
+int combophy_hsio_init_xpcs5_rtl8261(int phy)
+{
+	int ret;
+	int p0_id = 0;
+	int p1_id = 0;
+	int p0_spd = 0;
+	int p1_spd = 0;
+	struct combo_port *paddr = &g_combo_port_defs[0];
+
+	p0_id = P34X_PORT5;
+	p0_spd = XFI_10G_KR_NO_ANEG;
+
+	init_combo_base(&paddr[p0_id], p0_id);
+
+	/* remove this at the moment, kernel cannot seem to
+	 * re-init after u-boot reconfigs the ljpll3 */
+	/*ljpll3_cfg_frac_eth(); */
+
+	hsiotop_clk_gate_cfg(p0_id, 0);
+
+	/* Only need to configure once for either PORT10 or PORT20 */
+	ret = combophy_mode(p0_id, DUAL_ETH);
+	if (ret)
+		return ret;
+
+	/* Assert RESET of COMBOPHY */
+	combophy_rst_assert(p0_id);
+
+	/* Assert reset on PHY 10/11 */
+	eth_phy_rst_assert(p0_id);
+
+	/* Asser reset on XPCS0/1 */
+	xpcs_rst_assert(p0_id);
+
+	udelay(10);
+
+	/* De-assert WAN/COMBOPHY Subsystem Reset */
+	combophy_rst_deassert(p0_id);
+
+	/* De-assert PHY0/1/2 Reset */
+	eth_phy_rst_deassert(p0_id);
+
+	/* De-assert XPCS0/1/2 Reset */
+	xpcs_rst_deassert(p0_id);
+	mdelay(100);
+	combophy_paraclk_div2_cfg(paddr, p0_id, 1); /*1 means enable clock. */
+	udelay(100);
+
+	/* Enable SRAM_BYPASS */
+	combophy_sram_bypass_cfg(paddr, p0_id, 1); /*1 means enable SRAM Bypass to use internal FW. */
+
+	LGM_NET_DBG("SRAM Init for Port %d\n", p0_id);
+	ret = sram_init_chk(p0_id, 0);
+	if (ret)
+		return ret;
+
+	init_xpcs(p0_id, p1_id, p0_spd, p1_spd);
+
+	/*READ MPLLA/B state */
+	read_mpll_state(p0_id);
+
+	/*Enable RX auto adapt */
+	phy_rxeq_autoadapt(p0_id, LANE0);
+
+	LGM_NET_DBG("SRAM Init for Port %d\n", p0_id);
+	ret = sram_init_chk(p0_id, 0);
+	if (ret)
+		return ret;
+
+	check_rxtx_stable(p0_id);
+	set_mode_usxgmii(p0_id);
+	xpcs_disable_an(p0_id);
+	xpcs_cfg_clk(p0_id);
+	xpcs_cfg_table(p0_id);
+	xpcs_vs_reset(p0_id);
+	tx_eq_config_kernel(p0_id);
+	KR_workaround(p0_id);
+	xpcs_an(p0_id);
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET)
+
+void combo_global_init(int port)
+{
+	struct combo_addr_map *paddr = &g_combo_port_defs[port].port_to_addr;
+	
+	switch (port) {
+	case COMBO_PORT10:
+	default:
+		LGM_NET_DBG("COMBO HSIOL Port10 global config\n");
+		paddr->phy_app_base = COMBO_HSIOL_PHY10_APP_BASE;
+		paddr->phy_cr_base = COMBO_HSIOL_PHY10_CR_BASE;
+		break;
+	case COMBO_PORT11:
+		LGM_NET_DBG("COMBO HSIOL Port11 global config\n");
+		paddr->phy_app_base = COMBO_HSIOL_PHY11_APP_BASE;
+		//paddr->phy_cr_base = COMBO_HSIOL_PHY11_CR_BASE; //Not accessible. Use PHY10 for LANE1 access.
+		paddr->phy_cr_base = COMBO_HSIOL_PHY10_CR_BASE;
+		break;
+	case COMBO_PORT20:
+		LGM_NET_DBG("COMBO HSIOR Port20 global config\n");
+		paddr->phy_app_base = COMBO_HSIOR_PHY20_APP_BASE;
+		paddr->phy_cr_base = COMBO_HSIOR_PHY20_CR_BASE;
+		break;
+	case COMBO_PORT21:
+		LGM_NET_DBG("COMBO HSIOR Port21 global config\n");
+		paddr->phy_app_base = COMBO_HSIOR_PHY21_APP_BASE;
+		//paddr->phy_cr_base = COMBO_HSIOR_PHY21_CR_BASE; //Not accessible. Use PHY20 for LANE1 access.
+		paddr->phy_cr_base = COMBO_HSIOR_PHY20_CR_BASE;
+		break;
+	case PON_WAN_PORT4:
+		LGM_NET_DBG("PON WAN Port4 global config\n");
+		paddr->phy_app_base = PON_WAN_PHY_APP_BASE;
+		paddr->phy_cr_base = PON_WAN_PHY_CR_BASE;
+		break;		
+	case P34X_PORT5:
+		LGM_NET_DBG("P34X Port5 global config\n");
+		paddr->phy_app_base = PHY5_APP_BASE;
+		//paddr->phy_cr_base = PHY5_CR_BASE;
+		break;
+	case COMBO_PORT30:
+		LGM_NET_DBG("COMBO HSIOL Port30 global config\n");
+		//paddr->phy_app_base = COMBO_HSIOL_PHY30_APP_BASE;
+		//paddr->phy_cr_base = COMBO_HSIOL_PHY30_CR_BASE;
+		paddr->phy_app_base = PAIR_CM2PHY0_APP;
+		paddr->phy_cr_base = PAIR_CM2PHY0_CR;
+		break;
+	case COMBO_PORT40:
+		LGM_NET_DBG("COMBO HSIOR Port40 global config\n");
+		//paddr->phy_app_base = COMBO_HSIOR_PHY40_APP_BASE;
+		//paddr->phy_cr_base = COMBO_HSIOR_PHY40_CR_BASE;
+		paddr->phy_app_base = PAIR_CM2PHY0_APP;
+		paddr->phy_cr_base = PAIR_CM2PHY0_CR;
+		break;
+	}
+	LGM_NET_DBG("port =0x%x \n", port);
+	LGM_NET_DBG("paddr->phy_app_base =0x%x \n", paddr->phy_app_base);
+	LGM_NET_DBG("paddr->phy_cr_base =0x%x \n",paddr->phy_cr_base );
+}
+
+void ct_ljpll3_cfg_frac_eth(void)
+{
+	if(pll3_frac_configured == 0){
+		LGM_NET_DBG("Start LJPLL3 Fraction 156.25+15.5ppm refclk for CDR bring-up config: LJPLL3_CFG0\n");
+		
+		LGM_NET_DBG("Clear PLL3_CFG0 and disable LJPLL3\n");
+		//LJPLL3_CFG0
+			//#define PLL3_CFG0	(0xE020 00E0)
+			u32 LJPLL_CFG0_LOCAL = (CGU_LJPLL3_CFG0);
+			//To Disble the LJPLL3	
+			REG32(LJPLL_CFG0_LOCAL) &= ~(0xFFFFFFFF << 0); //Clear all BITs to '0'
+			LGM_NET_DBG("PLL3_CFG0 0x%08x\n", REG32(LJPLL_CFG0_LOCAL));	//Should get back 0x0
+			 
+		LGM_NET_DBG("Start PLL3_CFG2 config\n");	
+		//LJPLL3_CFG2
+			//#define LJPLL3_CFG2	(0xE020 00E8)
+			u32 LJPLL_CFG2_LOCAL = (CGU_LJPLL3_CFG2);
+			REG32(LJPLL_CFG2_LOCAL) &= ~(0xFFF << 0); 
+			//REG32(LJPLL_CFG2_LOCAL) |= 124 << 0 ; //FBDIV Bit 11:0 LJPLL Feedback Divider (124 = 0x7C). 5G FVCO
+			REG32(LJPLL_CFG2_LOCAL) |= 250 << 0 ; //FBDIV Bit 11:0 LJPLL Feedback Divider (250 = 0xFA). 10G FVCO
+			REG32(LJPLL_CFG2_LOCAL) &= ~(0x3F << 18); 	
+			REG32(LJPLL_CFG2_LOCAL) |= 1 << 18; //REFDIV Bit 23:18 PLL Reference Clock Input Divider (1 = 0x1)
+			REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 24); //BYPASS0 Bit 24 FOUT0 Bypass	
+			REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 25); //BYPASS0 Bit 25 FOUT1 Bypass	
+			REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 26); //BYPASS0 Bit 26 FOUT2 Bypass	
+			REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 27); //BYPASS0 Bit 27 FOUT3 Bypass	
+			REG32(LJPLL_CFG2_LOCAL) &= ~(0x1 << 28);
+			REG32(LJPLL_CFG2_LOCAL) |= 0x1 << 28; //FREFCMLEN Bit 28 0h = CMOS Mode; 1h = CML Mode. Enable Reference Clock CML Mode
+			LGM_NET_DBG("PLL3_CFG2 REG32(0x%08x) = 0x%08x\n", LJPLL_CFG2_LOCAL, REG32(LJPLL_CFG2_LOCAL));
+
+		LGM_NET_DBG("Start PLL3_CFG0 config\n");	
+			//To configure 
+			REG32(LJPLL_CFG0_LOCAL) &= ~(0xFFFFFF << 2); //FRAC Bit 25:2 FLL Fractional Divider
+			//REG32(LJPLL_CFG0_LOCAL) |= (0xD4FDF4 << 2); //Bit 25:2 = FRAC Bit 23:0 LJPLL Fractional Divider (0.832/2^-24 = 13958644 = 0xD4FDF4). 10G VCO
+			//REG32(LJPLL_CFG0_LOCAL) |= (65012 << 2); //Bit 25:2 = FRAC Bit 23:0 LJPLL Fractional Divider (0.003875/2^-24 = 65012 = 0xFDF4). 10G VCO; exact 156.25MHz
+			//REG32(LJPLL_CFG0_LOCAL) |= (62915 << 2); //Bit 25:2 = FRAC Bit 23:0 LJPLL Fractional Divider (0.0075/2^-24 = 62915 = 0xF5C3). 5G VCO; +15ppm
+			REG32(LJPLL_CFG0_LOCAL) |= (125830 << 2); //Bit 25:2 = FRAC Bit 23:0 LJPLL Fractional Divider (0.0075/2^-24 = 125830 = 0x1EB86). 10G VCO; +15ppm
+			REG32(LJPLL_CFG0_LOCAL) &= ~(0x1 << 28);
+			REG32(LJPLL_CFG0_LOCAL) |= 0x1 << 28; //DSMEN Bit 28 (0h Integer Mode, 1h Fractional ;Delta-Sigma Modulator)
+			REG32(LJPLL_CFG0_LOCAL) &= ~(0x1 << 30);
+			REG32(LJPLL_CFG0_LOCAL) |= 0x1 << 30; //DACEN Bit 30 (0h DAC is disable, 1h DAC is enable)
+			REG32(LJPLL_CFG0_LOCAL) &= ~(0x1 << 31);
+			REG32(LJPLL_CFG0_LOCAL) |= 0x1 << 31; //LD Bit 31 (0h No operation, 1h Load action)
+			LGM_NET_DBG("PLL3_CFG0 0x%08x\n", REG32(LJPLL_CFG0_LOCAL));	//Should get back 0x4000 0003
+			
+		LGM_NET_DBG("Start LJPLL3 config: LJPLL3_CFG1\n");
+		//LJPLL3_CFG1
+			//#define PLL3_CFG1		(0xE020 00E8)
+			u32 LJPLL_CFG1_LOCAL = (CGU_LJPLL3_CFG1);
+			//#### DIV0 25MHz
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 0); 
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 0; //POST_DIV0A Bit 2:0 First post divide value for FOUTCML0P/N (nominal 50% duty cycle) 40MHz
+			REG32(LJPLL_CFG1_LOCAL) |= 0x7 << 0; //POST_DIV0A Bit 2:0 First post divide value for FOUTCML0P/N (nominal 50% duty cycle) 25MHz
+			//REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 3);
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 3; //POST_DIV0B Bit 5:3 2nd post divide value for FOUTCML0P/N (nominal 50% duty cycle). VCO 5G 40MHz
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 3; //POST_DIV0B Bit 5:3 2nd post divide value for FOUTCML0P/N (nominal 50% duty cycle). VCO 10G 40MHz
+			REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 3; //POST_DIV0B Bit 5:3 2nd post divide value for FOUTCML0P/N (nominal 50% duty cycle). VCO 10G 25MHz
+			
+			//#### DIV1 156.25MHz
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 6); 
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x7 << 6; //POST_DIV1A Bit 8:6 First post divide value for FOUTCML1P/N (nominal 50% duty cycle) FMX
+			REG32(LJPLL_CFG1_LOCAL) |= 0x3 << 6; //POST_DIV1A Bit 8:6 First post divide value for FOUTCML1P/N (nominal 50% duty cycle) LGM
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 9);
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x0 << 9; //POST_DIV1B Bit 11:9 2nd post divide value for FOUTCML1P/N (nominal 50% duty cycle). VCO 5G
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 9; //POST_DIV1B Bit 11:9 2nd post divide value for FOUTCML1P/N (nominal 50% duty cycle). VCO 10G FMX
+			REG32(LJPLL_CFG1_LOCAL) |= 0x3 << 9; //POST_DIV1B Bit 11:9 2nd post divide value for FOUTCML1P/N (nominal 50% duty cycle). VCO 10G LGM
+			
+			//#### DIV2 1250MHz
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 12); 
+			REG32(LJPLL_CFG1_LOCAL) |= 0x0 << 12; //POST_DIV2A Bit 14:12 First post divide value for FOUTCML2P/N (nominal 50% duty cycle)
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 15);
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 15; //POST_DIV2B Bit 17:15 2nd post divide value for FOUTCML2P/N (nominal 50% duty cycle). VCO 5G
+			REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 15; //POST_DIV2B Bit 17:15 2nd post divide value for FOUTCML2P/N (nominal 50% duty cycle). VCO 10G
+
+			//#### DIV3 500MHz
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 18); 
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 18; //POST_DIV3A Bit 20:18 First post divide value for FOUTCML3P/N (nominal 50% duty cycle) FMX
+			REG32(LJPLL_CFG1_LOCAL) |= 0x0 << 18; //POST_DIV3A Bit 20:18 First post divide value for FOUTCML3P/N (nominal 50% duty cycle) LGM
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x7 << 21);
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 21; //POST_DIV3B Bit 23:21 2nd post divide value for FOUTCML3P/N (nominal 50% duty cycle). VCO 5G
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x0 << 21; //POST_DIV3B Bit 23:21 2nd post divide value for FOUTCML3P/N (nominal 50% duty cycle). VCO 10G FMX
+			REG32(LJPLL_CFG1_LOCAL) |= 0x4 << 21; //POST_DIV3B Bit 23:21 2nd post divide value for FOUTCML3P/N (nominal 50% duty cycle). VCO 10G LGM
+
+			//#### FOUT[3:0]EN
+			//REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 24); 
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 24; //FOUT0EN Bit 24 PLL Clock Output 0 Enable 
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 25); 
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 25; //FOUT1EN Bit 25 PLL Clock Output 1 Enable 
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 26); 
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 26; //FOUT2EN Bit 26 PLL Clock Output 2 Enable
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 27);
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 27; //FOUT3EN Bit 27 PLL Clock Output 3 Enable
+
+			//#### POST_DIV0PRE for FOUT0 ONLY divide 2.5 when turn on.
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 29); 
+			REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 29; //POST_DIV0PRE Bit 29 Enable for Pre-Divide for FOUTCML0N/P 
+			LGM_NET_DBG("PLL3_CFG1 0x%08x\n", REG32(LJPLL_CFG1_LOCAL)); 
+
+
+		//LJPLL3_CFG3
+			//#define LJPLL3_CFG3		(0xE02000EC)	
+
+#if 0
+		//LJPLL 36 bit input config
+			//L(23:0) = FRAC (23:0)
+			//H(3:0) + L(31:24) = FBDIV (11:0)
+			LGM_NET_DBG("Start LJPLL3 36 bit input to LJPLL3 Lower config: REG_36B_0\n");
+			//#define REG_36B_0		(0xE020013C)	
+			u32 REG_36B_0_LOCAL = CGU_MODULE_BASE + REG_36B_0;		
+			REG32(REG_36B_0_LOCAL) &= ~(0xFFFFFFFF << 0); //Clearing all bits
+			//REG32(REG_36B_0_LOCAL) |= 0x6A7EFA << 0; //Bit 23:0 = FRAC Bit 23:0 LJPLL Fractional Divider (0.416/2^-24 = 6979322 = 0x6A7EFA). 5G VCO
+			REG32(REG_36B_0_LOCAL) |= 0xD4FDF4 << 0; //Bit 23:0 = FRAC Bit 23:0 LJPLL Fractional Divider (0.832/2^-24 = 13958644 = 0xD4FDF4). 10G VCO
+			//REG32(REG_36B_0_LOCAL) |= 0x7C << 24; //Bit 31:24 = FBDIV Bit 7:0 LJPLL Feedback Divider (124 = 0x7C)
+			REG32(REG_36B_0_LOCAL) |= 0xF8 << 24; //Bit 31:24 = FBDIV Bit 7:0 LJPLL Feedback Divider (248 = 0xF8)
+			LGM_NET_DBG("REG_36B_0_LOCAL 0x%08x\n", REG32(REG_36B_0_LOCAL));		
+			
+			LGM_NET_DBG("Start LJPLL3 36 bit input to LJPLL3 Higher config: REG_36B_1\n");
+			//#define REG_36B_1		(0xE0200140)	
+			u32 REG_36B_1_LOCAL = CGU_MODULE_BASE + REG_36B_1;
+			REG32(REG_36B_1_LOCAL) &= ~(0xF << 0); //Bit 3:0 = FBDIV Bit 11:8 LJPLL Feedback Divider (0x0)
+			LGM_NET_DBG("REG_36B_1_LOCAL 0x%08x\n", REG32(REG_36B_1_LOCAL));				
+
+		//DPLL Enable and Select PLLCTRL_SRC_SEL = 0 to use PLLFREQ_CTRL
+			LGM_NET_DBG("Select PLLCTRL_SRC_SEL = 0h to Register reg_36bit\n");
+			//#define CGU_IF_CLK 		(0xb6200140)	
+			u32 CGU_IF_CLK_LOCAL = (CGU_CGU_IF_CLK | KSEG1);
+			REG32(CGU_IF_CLK_LOCAL) &= ~(0x3 << 18); //PLLCTRL_SRC_SEL Bit 18. 0h = register reg_36bit; 1h = DPLL output
+			LGM_NET_DBG("CGU_IF_CLK_LOCAL 0x%08x\n", REG32(CGU_IF_CLK_LOCAL));		
+			
+			LGM_NET_DBG("DPLL Enable set to 1 \n");
+			//#define DPLL_CTRL		(0xb6200228)
+			u32 DPLL_CTRL_LOCAL = (CGU_DPLL_CTRL | KSEG1);
+			REG32(DPLL_CTRL_LOCAL) &= ~(0x1 << 0);
+			REG32(DPLL_CTRL_LOCAL) |= 0x1 << 0; //DPLL_CTRL Bit 0. 0h = Disable DPLL; 1h = Enable DPLL
+			LGM_NET_DBG("DPLL_CTRL_LOCAL 0x%08x\n", REG32(DPLL_CTRL_LOCAL));	
+#endif
+		
+		//To Enable the LJPLL3
+			REG32(LJPLL_CFG0_LOCAL) &= ~(0x1 << 0); //PLLEN Bit 0 (0h Disable, 1h Enable)
+			REG32(LJPLL_CFG0_LOCAL) |= 0x1 << 0; //PLLEN Bit 0 (0h Disable, 1h Enable)
+			LGM_NET_DBG("LJPLL_CFG0_LOCAL 0x%08x\n", REG32(LJPLL_CFG0_LOCAL));	
+			
+		//To wait for LJPLL3 lock status
+		#define LJPLL3_LOCK BIT(1) //LJPLL3 Lock Bit
+		//mdelay(1000);
+		// LJPLL_CFG0
+		
+		#define LJPLL3_LOCK_POLL_CNT 5000
+		u32 val;
+		int i;
+		for (i = 0; i < LJPLL3_LOCK_POLL_CNT; i++) {
+			if ((REG32(LJPLL_CFG0_LOCAL) & BIT(1)))
+			{
+				val = REG32(LJPLL_CFG0_LOCAL);
+				LGM_NET_DBG("LJPLL3_CFG0 0x%08x LJPLL3_LOCK %s\n",
+				val, (val & LJPLL3_LOCK)? "set": "clr");
+				break;
+			}
+			udelay(10);
+		}
+		
+		if (i >= LJPLL3_LOCK_POLL_CNT)
+			LGM_NET_DBG("LJPLL3 Lock failed\n");
+		else {
+			LGM_NET_DBG("LJPLL3 Lock succeed\n");
+		}
+		
+		LGM_NET_DBG("Enable all the LJPLL3_CFG1 FOUT0-3\n");
+		//Enable all FOUT0-3 after PLL lock.
+			//#define LJPLL3_CFG1		(0xE02000C4)
+			//REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 24); 
+			//REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 24; //FOUT0EN Bit 24 PLL Clock Output 0 Enable #Kay Seah: Disable P34X clock now as it take over the FAN PWM.
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 25); 
+			REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 25; //FOUT1EN Bit 25 PLL Clock Output 1 Enable 
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 26); 
+			REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 26; //FOUT2EN Bit 26 PLL Clock Output 2 Enable
+			REG32(LJPLL_CFG1_LOCAL) &= ~(0x1 << 27);
+			REG32(LJPLL_CFG1_LOCAL) |= 0x1 << 27; //FOUT3EN Bit 27 PLL Clock Output 3 Enable
+			LGM_NET_DBG("LJPLL3_CFG1 0x%08x\n", REG32(LJPLL_CFG1_LOCAL)); //Check bit 7 = 3 and Bit 0 = 8.
+
+		pll3_frac_configured = 1;
+	}else{
+		LGM_NET_DBG("LJPLL3 Fraction 156.25+15.5ppm refclk already configured\n");
+	}
+}
+
+static void ct_hsiotop_clk_gate_cfg(int port, int dis)
+{
+	if(port == 0){
+		//SET_X_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis);
+		REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis);
+		udelay(10);
+		LGM_NET_DBG("HSIOL Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	}else if(port == 1){
+		//SET_X_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+		REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+		LGM_NET_DBG("HSIOL Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	}else if(port == 2){
+		//SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis);
+		REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis);
+		LGM_NET_DBG("HSIOR Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	}else if(port == 3){
+		//SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+		REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+		LGM_NET_DBG("HSIOR Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG));
+
+// added to support COMBO_PORT30 and COMBO_PORT40
+	}else if(port == COMBO_PORT30){
+		//SET_X_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+		REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+		
+		REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_PCIE0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_PCIE0_CLK_DIS_WIDTH, dis);
+		REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_PCIE1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_PCIE1_CLK_DIS_WIDTH, dis);
+		LGM_NET_DBG("HSIOL Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	}else if(port == COMBO_PORT40){
+		//SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, dis);
+		REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, dis);
+
+		
+		REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_PCIE0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_PCIE0_CLK_DIS_WIDTH, dis);
+		REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_PCIE1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_PCIE1_CLK_DIS_WIDTH, dis);
+		LGM_NET_DBG("HSIOR Port%d TOP CLK DIS CFG: Enable XPCSx CLK = 0x%08x\n", port, REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG));
+	}
+	
+}
+
+int ct_combophy_rst_assert(int port)
+{
+	udelay(1);
+	if(port == COMBO_PORT10 || port == COMBO_PORT11){
+		set_reset(RST_REQ_HSIOL, REQ_PCIE1X_CPHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE1X_CPHY Reset BIT17 Asserted\n");		
+	}else if(port == COMBO_PORT20 || port == COMBO_PORT21){
+		set_reset(RST_REQ_HSIOR, REQ_PCIE2X_CPHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE2X_CPHY Reset BIT17 Asserted\n");		
+	}else if(port == P34X_PORT5){
+		set_reset(RST_REQ_ETHNOC, REQ_XPCS5_CPHY);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_CPHY Reset BIT17 Asserted\n");		
+	}
+
+	if(port == COMBO_PORT30){
+		
+		set_reset(RST_REQ_HSIOL, REQ_PCIE1X_CPHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE1X_CPHY Reset BIT17 Asserted\n");	
+	
+		set_reset(RST_REQ_HSIOL, REQ_PCIE3X_CPHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE3X_CPHY Reset BIT18 Asserted\n");
+
+		set_reset(RST_REQ_HSIOL, REQ_PCIE30_PHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE30_PHY Reset BIT8 Asserted\n");
+	}else if(port == COMBO_PORT40){
+	
+		set_reset(RST_REQ_HSIOR, REQ_PCIE2X_CPHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE2X_CPHY Reset BIT17 Asserted\n");
+		
+		set_reset(RST_REQ_HSIOR, REQ_PCIE4X_CPHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE4X_CPHY Reset BIT18 Asserted\n");
+	
+		set_reset(RST_REQ_HSIOR, REQ_PCIE40_PHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE40_PHY Reset BIT8 Asserted\n");	
+	}
+
+	return 0;
+}
+
+int ct_xpcs_rst_assert(int port)
+{
+	udelay(1);
+	if(port == COMBO_PORT10){
+		set_reset(RST_REQ_HSIOL, REQ_PCIE10_PCS);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE10_PCS Reset BIT12 Asserted\n");		
+	}else if(port == COMBO_PORT11 || port == COMBO_PORT30){
+		set_reset(RST_REQ_HSIOL, REQ_PCIE11_PCS);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE11_PCS Reset BIT13 Asserted\n");		
+	}else if(port == COMBO_PORT20){
+		set_reset(RST_REQ_HSIOR, REQ_PCIE20_PCS);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE20_PCS Reset BIT12 Asserted\n");		
+	}else if(port == COMBO_PORT21 || port == COMBO_PORT40){
+		set_reset(RST_REQ_HSIOR, REQ_PCIE21_PCS);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE21_PCS Reset BIT13 Asserted\n");		
+	}else if(port == P34X_PORT5){
+		set_reset(RST_REQ_ETHNOC, REQ_XPCS5_PCS0);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_PCS0 Reset BIT15 Asserted\n");		
+	}
+	return 0;
+}
+
+int ct_pcie_controller_rst_assert(int port)
+{
+	udelay(1);
+	if(port == COMBO_PORT30){
+		set_reset(RST_REQ_HSIOL, REQ_PCIE30_PCIE0);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE30_PCIE0 Reset BIT2 Asserted\n");	
+		set_reset(RST_REQ_HSIOL, REQ_PCIE31_PCIE1);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE31_PCIE1 Reset BIT3 Asserted\n");
+	}else if(port == COMBO_PORT40){
+		set_reset(RST_REQ_HSIOR, REQ_PCIE30_PCIE0);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE30_PCIE0 Reset BIT2 Asserted\n");	
+		set_reset(RST_REQ_HSIOR, REQ_PCIE31_PCIE1);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE31_PCIE1 Reset BIT3 Asserted\n");
+	}
+	return 0;
+}
+int ct_pcie_controller_rst_deassert(int port)
+{
+	udelay(1);
+	if(port == COMBO_PORT30){
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE30_PCIE0);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE30_PCIE0 Reset BIT2 Asserted\n");	
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE31_PCIE1);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE31_PCIE1 Reset BIT3 Asserted\n");
+	}else if(port == COMBO_PORT40){
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE30_PCIE0);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE30_PCIE0 Reset BIT2 Asserted\n");	
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE31_PCIE1);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE31_PCIE1 Reset BIT3 Asserted\n");
+	}
+	return 0;
+}
+
+int ct_combophy_rst_deassert(int port)
+{
+	udelay(1);
+	if(port == COMBO_PORT10 || port == COMBO_PORT11){
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE1X_CPHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE1X_CPHY Reset BIT17 Desserted\n");		
+	}else if(port == COMBO_PORT20 || port == COMBO_PORT21){
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE2X_CPHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE2X_CPHY Reset BIT17 Deasserted\n");		
+	}else if(port == P34X_PORT5){
+		clear_reset(RST_REQ_ETHNOC, REQ_XPCS5_CPHY);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_CPHY Reset BIT17 Deasserted\n");		
+	}
+
+	if(port == COMBO_PORT30){
+		
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE1X_CPHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE1X_CPHY Reset BIT17 Asserted\n");	
+	
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE3X_CPHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE3X_CPHY Reset BIT18 Asserted\n");
+
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE30_PHY);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE30_PHY Reset BIT8 Asserted\n");
+	}else if(port == COMBO_PORT40){
+	
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE2X_CPHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE2X_CPHY Reset BIT17 Asserted\n");
+		
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE4X_CPHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE4X_CPHY Reset BIT18 Asserted\n");
+	
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE40_PHY);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE40_PHY Reset BIT8 Asserted\n");	
+		}
+
+	return 0;
+}
+
+int ct_xpcs_rst_deassert(int port)
+{
+	udelay(1);
+	if(port == COMBO_PORT10){
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE10_PCS);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE10_PCS Reset BIT12 Deasserted\n");		
+	}else if(port == COMBO_PORT11 || port == COMBO_PORT30){
+		clear_reset(RST_REQ_HSIOL, REQ_PCIE11_PCS);
+		LGM_NET_DBG("HSIOL_REQ REQ_PCIE11_PCS Reset BIT13 Deasserted\n");		
+	}else if(port == COMBO_PORT20){
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE20_PCS);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE20_PCS Reset BIT12 Deaserted\n");		
+	}else if(port == COMBO_PORT21 || port == COMBO_PORT40){
+		clear_reset(RST_REQ_HSIOR, REQ_PCIE21_PCS);
+		LGM_NET_DBG("HSIOR_REQ REQ_PCIE21_PCS Reset BIT13 Deasserted\n");		
+	}else if(port == P34X_PORT5){
+		clear_reset(RST_REQ_ETHNOC, REQ_XPCS5_PCS0);
+		LGM_NET_DBG("ETHNOC_REQ REQ_XPCS5_PCS0 Reset BIT15 Deasserted\n");		
+	}
+	return 0;
+}
+
+int ct_combophy_rst_stat(int port)
+{
+	int stat = 0;
+	udelay(1);
+	if(port == COMBO_PORT10 || port == COMBO_PORT11 || port == COMBO_PORT30){
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE1X_CPHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE1X_CPHY);
+		//LGM_NET_DBG("HSIOL_STAT STAT_PCIE1X_CPHY Reset BIT17 Status = %d\n", stat);		
+	}else if(port == COMBO_PORT20 || port == COMBO_PORT21 || port == COMBO_PORT40){
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE2X_CPHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE2X_CPHY);
+		//LGM_NET_DBG("HSIOR_STAT STAT_PCIE2X_CPHY Reset BIT17 Status = %d\n", stat);
+	}else if(port == P34X_PORT5){
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_CPHY);
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_CPHY);
+		//LGM_NET_DBG("ETHNOC_STAT STAT_XPCS5_CPHY Reset BIT17 Status = %d\n", stat);
+	}
+
+	else if(port == COMBO_PORT30){
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE3X_CPHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE3X_CPHY);
+		//LGM_NET_DBG("HSIOL_STAT STAT_PCIE3X_CPHY Reset BIT18 Status = %d\n", stat);
+		
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE30_PHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE30_PHY);
+		//LGM_NET_DBG("HSIOL_STAT STAT_PCIE30_PHY Reset BIT8 Status = %d\n", stat);	
+	}else if(port == COMBO_PORT40){
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE4X_CPHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE4X_CPHY);
+		//LGM_NET_DBG("HSIOR_STAT STAT_PCIE4X_CPHY Reset BIT18 Status = %d\n", stat);
+		
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE40_PHY);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE40_PHY);
+		//LGM_NET_DBG("HSIOR_STAT STAT_PCIE40_PHY Reset BIT8 Status = %d\n", stat);	
+	}
+
+	return stat;
+}
+
+int ct_xpcs_rst_stat(int port)
+{
+	int stat = 0;
+	udelay(1);
+	if(port == COMBO_PORT10){
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE10_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE10_PCS);
+		//LGM_NET_DBG("HSIOL_STAT STAT_PCIE10_PCS Reset BIT12 = %d\n", stat);		
+	}else if(port == COMBO_PORT11){
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE11_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE11_PCS);
+		//LGM_NET_DBG("HSIOL_STAT STAT_PCIE11_PCS Reset BIT13 = %d\n", stat);		
+	}else if(port == COMBO_PORT20){
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE20_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE20_PCS);
+		//LGM_NET_DBG("HSIOR_STAT STAT_PCIE20_PCS Reset BIT12 = %d\n", stat);		
+	}else if(port == COMBO_PORT21){
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE21_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE21_PCS);
+		//LGM_NET_DBG("HSIOR_STAT STAT_PCIE21_PCS Reset BIT13 = %d\n", stat);		
+	}else if(port == P34X_PORT5){
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_PCS0);
+		stat = get_reset_bit_status(RST_STAT_ETHNOC, STAT_XPCS5_PCS0);
+		//LGM_NET_DBG("ETHNOC_STAT STAT_XPCS5_PCS0 Reset BIT15 = %d\n", stat);		
+	}
+
+	else if(port == COMBO_PORT30){
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE11_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOL, STAT_PCIE11_PCS);
+		//LGM_NET_DBG("HSIOL_STAT STAT_PCIE11_PCS Reset BIT13 = %d\n", stat);		
+	}
+		else if(port == COMBO_PORT40){
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE21_PCS);
+		stat = get_reset_bit_status(RST_STAT_HSIOR, STAT_PCIE21_PCS);
+		//LGM_NET_DBG("HSIOR_STAT STAT_PCIE21_PCS Reset BIT13 = %d\n", stat);		
+	}
+
+	return stat;
+}
+
+void ct_vr_reset_poll(int port)
+{
+	LGM_NET_DBG("\nPolling Port%d for VR_RESET BIT15 of VR_XS_PCS_DIG_CTRL1 to get clear\n",port);
+	#define VR_RESET BIT(15) //VR_RESET BIT
+
+		u32 val;
+		int i;
+		for (i = 0; i < VR_RESET_CNT; i++) {
+			if (!((indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port)) & VR_RESET))
+			{
+				//dprint_enable = 1;
+				val = indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+				//LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 0x%08x BIT15 VR_RST %s\n", val, (val & VR_RESET)? "set": "clr");
+				
+				LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 0x%08x BIT15 VR_RST %s\n", val, (val & VR_RESET)? "set": "clr");
+				break;
+			}
+			udelay(10);
+		}
+		
+		if (i >= VR_RESET_CNT)
+			LGM_NET_DBG("XPCS%d VR RESET Failed\n", port);
+		else {
+			LGM_NET_DBG("XPCS%d VR RESET succeed\n", port);
+		}
+		//dprint_enable = 1;
+#if 0
+		do{
+				indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port); //Waiting for BIT15 VR_RST to clear.
+		}while((read_data & 0x8000)  ==  0x8000); //check for tx, rx are stable 
+		indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+		LGM_NET_DBG("VR_RST Clear BIT15 = 0x%08x\n", read_data);
+#endif
+	
+}
+
+
+//Check RX/TX stable function
+void ct_check_rxtx_stable(int port)
+{
+	LGM_NET_DBG("\nCheck Port%d PMA Power Up Sequence STATE Stable\n",port);
+
+	//dprint_enable = 0;
+	
+	int i;
+	//u32 vr_rst_data;
+	u32 stable_data;
+	#define  CHECK_TIMEOUT	5000
+	for (i = 0; i < CHECK_TIMEOUT; i++) {
+	 //do{
+		//indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port); 
+		//vr_rst_data = read_data;
+
+	  //}while((read_data & 0x8000)  !=  0x0000); //check for tx, rx are stable
+		//Check VR_RST BIT15 is = 0 where VR_RST is de-assert.
+		//if ((vr_rst_data & 0x8000) == 0x0000) 
+		//{
+			//LGM_NET_DBG("\nVR_RST de-asserted.\n");
+			indirect_pcs_rd(VR_XS_PCS_DIG_STS,port); 
+			stable_data = read_data;
+			//LGM_NET_DBG("PSEQ_STATE BIT4:2 = 0x%08x\n", stable_data);
+			if ((stable_data & 0x00100010) != 0x0000)
+			{
+				//dprint_enable = 1;
+				indirect_pcs_rd(VR_XS_PCS_DIG_STS,port); 
+				LGM_NET_DBG("PSEQ_STATE BIT4:2 = 0x%08x\n", read_data);
+				break;
+			}
+		//}
+		udelay(10);
+	}
+
+	//dprint_enable = 1;
+
+	if (i >= CHECK_TIMEOUT)
+	{
+		pass_flag = 0;
+		LGM_NET_DBG("PHY%d TX/RX Stable TIMEOUT\n", port);
+		indirect_pcs_rd(VR_XS_PCS_DIG_STS,port); 
+		LGM_NET_DBG("PSEQ_STATE BIT4:2 = 0x%08x\n", read_data);
+	}
+	else {
+		pass_flag = 1;
+		LGM_NET_DBG("PHY%d TX/RX Stable cnt %d\n", port, i);
+		LGM_NET_DBG("PHY%d TX/RX Stable\n", port);
+	}
+}
+
+void ct_disable_an(int port) {
+	LGM_NET_DBG("\nDisabling XPCS%d Clause 73 AN \n", port);
+	//SR_AN_CTRL BIT12 AN_EN = 0, BIT13 EXP_NP_CTL = 0
+  	indirect_pcs_rd(SR_AN_CTRL, port); 
+	LGM_NET_DBG("[RD]Read SR_AN_CTRL Setting BIT12 AN_EN, BIT13 EXP_NP_CTL = 0x%08x\n", read_data);
+	read_data &= ~0x00003000;
+	indirect_pcs_wr(SR_AN_CTRL,read_data, port);
+	indirect_pcs_rd(SR_AN_CTRL, port);
+	LGM_NET_DBG("[WR]Set SR_AN_CTRL Setting BIT12 AN_EN, BIT13 EXP_NP_CTL = 0x%08x\n", read_data);
+}
+
+void ct_disable_an_37(int port) {
+	LGM_NET_DBG("\nDisabling XPCS%d Clause 37 AN \n", port);
+	indirect_pcs_rd(SR_MII_CTRL, port); 
+	read_data &= ~0x00001000; // wr_data[12] = 1'b0;
+	indirect_pcs_wr(SR_MII_CTRL, read_data, port);
+	indirect_pcs_rd(SR_MII_CTRL, port);
+	LGM_NET_DBG("[WR]Set SR_MII_CTRL Setting BIT12 AN_EN = 0x%08x\n", read_data);
+}
+
+void ct_pma_type_config(int port)
+{
+	//u32 value = 0x1; //Default at 10GBASE-X PCS mode 
+	int value = 11; //Default at 10GBASE-KR PMA Type BIT3:0
+
+#if 1	
+	//writing to SR_PMA_CTRL1 register for BIT13 SS13 Speed Selection; 0 = 1G KX Mode, 1 = 10GBASE-X PCS mode.
+    LGM_NET_DBG("\nWriting to SR_PMA_CTRL1 register BIT13 for Speed Selection\n");
+    indirect_pcs_rd(SR_PMA_CTRL1,port);
+	if (pma_type < 12)
+		indirect_pcs_wr(SR_PMA_CTRL1,(read_data | 0x2000),port);//10G Mode
+	else
+		indirect_pcs_wr(SR_PMA_CTRL1,(read_data & 0xFFFFDFFF),port); //1G Mode
+	//value = 0x2000;
+	indirect_pcs_rd(SR_PMA_CTRL1,port);
+	LGM_NET_DBG("\n[WR] SR_PMA_CTRL1: SS13 Speed Selection BIT13, 0 = 1G KX Mode, 1 = 10GBASE-X PCS = 0x%08x\n", read_data);
+#endif
+	
+	//writing to SR_PMA_CTRL2 register for PMA_TYPE
+	value = 0x0;
+	value |= pma_type << 0;
+    LGM_NET_DBG("\nWriting to SR_PMA_CTRL2 register for PMA_TYPE\n");
+    indirect_pcs_wr(SR_PMA_CTRL2,value,port);
+    indirect_pcs_rd(SR_PMA_CTRL2,port);
+	LGM_NET_DBG("\n[WR] SR_PMA_CTRL2: PMA_TYPE BIT3:0, > 0xb is 1G PMA/PMD type, <0xb is 10G PMA/PMD type = 0x%08x\n", read_data);
+
+}
+
+void ct_base_1g_c10phy_serdes_bringup(int port){
+
+		u32 value;
+		int tx_preset_id, rx_preset_id;
+	
+		tx_preset_id = TX_1G_CUSTOM;
+		rx_preset_id = RX_1G;
+	
+		struct tx_eq *txeq = &tx_presets[tx_preset_id];
+		struct rx_eq *rxeq = &rx_presets[rx_preset_id];
+	
+//		debugmsg = 0;
+	
+	
+		//SERDES Bringup sequence starts	 
+		LGM_NET_DBG("\nSERDES Bringup sequence starts\n");
+	
+		LGM_NET_DBG("TX PRESET\t:%d\nRX PRESET\t:%d \n", tx_preset_id, rx_preset_id);
+	
+		//Set PCS type to 01 -10GBASE-X PCS Type
+		//SR_XS_PCS_CTRL2
+		LGM_NET_DBG("\nSet SR_XS_PCS_CTRL2 Bit 3:0 PCS Type = 1\n");
+		indirect_pcs_rd(SR_XS_PCS_CTRL2,port);
+		LGM_NET_DBG("[RD]SR_XS_PCS_CTRL2 Bit 3:0 PCS Type = 0x%08x\n", read_data);	
+		read_data = read_data & 0xFFFFFFF0; //Clear Bit1:0 equals to zero.
+		indirect_pcs_wr(SR_XS_PCS_CTRL2,(read_data | 0x0001),port);
+		indirect_pcs_rd(SR_XS_PCS_CTRL2,port);
+		LGM_NET_DBG("[WR]SR_XS_PCS_CTRL2 Bit 3:0 PCS Type = 0x%08x\n", read_data);
+	
+		//Set to XAUI mode. 
+		//VR_XS_PCS_XAUI_CTRL
+		LGM_NET_DBG("\nSet VR_XS_PCS_XAUI_CTRL Bit 0 to XAUI mode = 0\n");
+		indirect_pcs_rd(VR_XS_PCS_XAUI_CTRL,port);
+		LGM_NET_DBG("[RD]VR_XS_PCS_XAUI_CTRL Bit 0 to XAUI mode = 0x%08x\n", read_data);	
+		indirect_pcs_wr(VR_XS_PCS_XAUI_CTRL,(read_data & 0xFFFFFFFE),port);
+		indirect_pcs_rd(VR_XS_PCS_XAUI_CTRL,port);
+		LGM_NET_DBG("[WR]VR_XS_PCS_XAUI_CTRL Bit 0 to XAUI mode = 0x%08x\n", read_data);
+		
+		//Setting SS13 bit of PCS side
+		//SR_XS_PCS_CTRL1
+		LGM_NET_DBG("\nSet SR_XS_PCS_CTRL1 Setting SS13 bit = 0\n");
+		indirect_pcs_rd(SR_XS_PCS_CTRL1,port);
+		LGM_NET_DBG("[RD]SR_XS_PCS_CTRL1 SS13 bit = 0x%08x\n", read_data);	
+		indirect_pcs_wr(SR_XS_PCS_CTRL1,(read_data & 0xFFFFDFFF),port);
+		indirect_pcs_rd(SR_XS_PCS_CTRL1,port);
+		LGM_NET_DBG("[WR]SR_XS_PCS_CTRL1 SS13 bit = 0x%08x\n", read_data);
+	
+		/*SR_MII_CTRL
+		BIT5	SS5
+		BIT6	SS6
+		BIT13	SS13
+		For SGMII configurations:
+		When SS6=1 and SS13=0, speed is 1000 Mbps
+		When SS6=0 and SS13=1, speed is 100 Mbps
+		When SS6=0 and SS13=0, speed is 10 Mbps */
+		LGM_NET_DBG("\nSet SR_MII_CTRL Setting SS6 BIT6 = 1 and SS13 BIT13 = 0\n");
+		indirect_pcs_rd(SR_MII_CTRL,port);
+		LGM_NET_DBG("[RD]SR_MII_CTRL Setting SS6 BIT6 = 1 and SS13 BIT13 = 0 for 1000Mbps: SR_MII_CTRL = 0x%08x\n", read_data); 	
+		read_data = read_data & 0xFFFFDFBF; //Clear bit6 and bit13
+		read_data |= (1 << 6);
+		read_data &= ~(1 << 13);
+		indirect_pcs_wr(SR_MII_CTRL,read_data,port); //Set bit6
+		indirect_pcs_rd(SR_MII_CTRL,port);
+		LGM_NET_DBG("[WR]SR_MII_CTRL Setting SS6 BIT6 = 1 and SS13 BIT13 = 0 for 1000Mbps: SR_MII_CTRL = 0x%08x\n", read_data);
+
+		if(port < WAN_XPCS4){
+			//MPLLB Configuration
+	
+			//writing to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT 5:3, REF_MPLLB_DIV2 BIT6
+			LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT and REF_MPLLB_DIV2\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,port);  
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL for BIT5:3 REF_RANGE BIT and BIT7 REF_MPLLB_DIV2= 0x%08x\n", read_data);
+			value = read_data;
+			//value = 0x0;
+			value |= 0x1 << 0; //REF_CLK_EN BIT0 = 1h
+			if(ref_use_pad == 0)
+				value &= ~(0x1 << 1); //REF_USE_PAD BIT1 = 0h
+			else if(ref_use_pad == 1)
+				value |= 0x1 << 1; //REF_USE_PAD BIT1 = 1h use external pad for clock. Only applicable for serdes HSIOL_1
+			value |= 0x1 << 2; //REF_CLK_DIV2 = 1h
+	
+			value &= ~(0x7 << 3); //Clear REF_RANGE BIT5:3
+			if(port == PON_WAN_PORT4 && pon_eth_sel == PON_MODE)
+				value |= 0x5 << 3; //REF_RANGE BIT5:3 = 3'b101: 130.1 - 156 MHz PON CLOCK
+			else
+				value |= 0x2 << 3; //REF_RANGE BIT5:3 = 3'b010: 156.1 - 182 MHz ETH CLOCK
+			//value &= ~(0x1 << 6); //REF_MPLLA_DIV2 BIT6
+			value |= (0x1 << 7); //REF_MPLLB_DIV2 BIT7
+			value &= ~(0x1 << 8); //REF_RPT_CLK_EN BIT8 //Disable now as Verification team did not enable this. It was enable in FLM.
+			indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,value,port);
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,port);  
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL for BIT5:3 REF_RANGE BIT and BIT7 REF_MPLLB_DIV2= 0x%08x\n", read_data);
+
+
+			//Set MPLLB_CAL_DISABLE
+			LGM_NET_DBG("\nWriting MPLLB_CAL_DISABLE register\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,port);	 
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0 Setting MPLLB_CAL_DISABLE bit15 = 0x%08x\n", read_data);
+			read_data &= ~(0x1<<15); // Clear BIT15
+			indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,read_data,port); 
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,port);
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0 MPLLB_CAL_DISABLE = 0x%08x\n", read_data);
+	
+			//Set MPLLB_MULTIPLIER
+			LGM_NET_DBG("\nWriting MPLLB_MULTIPLIER register\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,port);	 
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0 Setting MPLLB_MULTIPLIER bit7:0 = 0x%08x\n", read_data);		
+			indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,0x0060,port); //Setting BIT7:0 = 8'd96 = 2'h60
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0,port);
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL0 Setting MPLLB_MULTIPLIER bit7:0 = 0x%08x\n", read_data);
+	
+			//Set MPLLB_BANDWIDTH
+			LGM_NET_DBG("\nWriting MPLLB_BANDWIDTH register\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLB_CTRL3,port); 
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_MPLLB_CTRL3 Setting MPLLB_BANDWIDTH bit15:0 = 0x%08x\n", read_data);		
+			indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLB_CTRL3,0x3d,port); //Setting BIT15:0 = 16'd61 = 4'h3d
+			indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLB_CTRL3,port);
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_MPLLB_CTRL3 Setting MPLLB_BANDWIDTH bit15:0 = 0x%08x\n", read_data);
+	
+			//writing to MPLLB_CTRL2 register for MPLLB_DIV_MULT BIT6:0, MPLLB_DIV_CLK_EN BIT7
+			LGM_NET_DBG("\nwriting to MPLLB_CTRL2 register for MPLLB_DIV_MULT\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,port);
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2 Setting MPLLB DIV8/DIV10/DIV16P5 bits = 0x%08x\n", read_data);		
+			read_data &= ~(0x3FF << 0); //Clear BIT9:0
+			read_data |=  (30 << 0);	 // BIT6:0 MPLLB_DIV_MULT			= 30d
+			read_data &= ~(0x1 << 7);	 // BIT7 MPLLB_DIV_CLK_EN			= 0h
+			read_data &= ~(0x1 << 8);	 // BIT8 MPLLB_DIV8_CLK_EN			= 0h
+			read_data |=  (0x1 << 9);	 // BIT9 MPLLB_DIV10_CLK_EN 		= 1h
+	
+			indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,read_data,port);
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2,port);
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLB_CTRL2 Setting MPLLB DIV8/DIV10/DIV16P5 bits = 0x%08x\n", read_data);
+		}
+		else
+		{
+			//MPLLA Configuration
+	
+			//writing to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT 5:3, REF_MPLLA_DIV2 BIT6
+			LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL register for REF_RANGE BIT and REF_MPLLA_DIV2\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,port);  
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL for BIT5:3 REF_RANGE BIT and BIT6 REF_MPLLA_DIV2= 0x%08x\n", read_data);		
+			value = read_data;
+			//value = 0x0;
+			value |= 0x1 << 0; //REF_CLK_EN BIT0 = 1h
+			if(ref_use_pad == 0)
+				value &= ~(0x1 << 1); //REF_USE_PAD BIT1 = 0h
+			else if(ref_use_pad == 1)
+				value |= 0x1 << 1; //REF_USE_PAD BIT1 = 1h use external pad for clock. Only applicable for serdes HSIOL_1
+			value &= ~(0x1 << 2); //REF_CLK_DIV2 = 0h
+	
+			value &= ~(0x7 << 3); //Clear REF_RANGE BIT5:3		
+			if(port == PON_WAN_PORT4 && pon_eth_sel == PON_MODE)
+				value |= 0x5 << 3; //REF_RANGE BIT5:3 = 3'b101: 130.1 - 156 MHz PON CLOCK
+			else
+				value |= 0x6 << 3; //REF_RANGE BIT5:3 = 3'b110: 156.1 - 182 MHz ETH CLOCK
+			value |= 0x1 << 6; //REF_MPLLA_DIV2 BIT6
+			//value &= ~(0x1 << 7); //REF_MPLLB_DIV2 BIT7
+			value &= ~(0x1 << 8); //REF_RPT_CLK_EN BIT8 //Disable now as Verification team did not enable this. It was enable in FLM.
+			indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,value,port);
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL,port);  
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL for BIT5:3 REF_RANGE BIT and BIT6 REF_MPLLA_DIV2= 0x%08x\n", read_data);
+	
+			//Set MPLLA_MULTIPLIER
+			LGM_NET_DBG("\nWriting MPLLA_MULTIPLIER register\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,port);	 
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0 Setting MPLLA_MULTIPLIER bit7:0 = 0x%08x\n", read_data);		
+			indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,0x0020,port); //Setting BIT7:0 = 8'd32 = 2'h20
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0,port);
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0 Setting MPLLA_MULTIPLIER bit7:0 = 0x%08x\n", read_data);
+	
+			//Set MPLLA_BANDWIDTH
+			LGM_NET_DBG("\nWriting MPLLA_BANDWIDTH register\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,port);	 
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_MPLLA_CTRL3 Setting MPLLA_BANDWIDTH bit15:0 = 0x%08x\n", read_data);		
+			indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,0xA035,port); //Setting BIT15:0 = 16'd41013(databook 41022) = 4'hA035 (A03E)
+			indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3,port);
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_MPLLA_CTRL3 Setting MPLLA_BANDWIDTH bit15:0 = 0x%08x\n", read_data);
+	
+			//writing to MPLLA_CTRL2 register for MPLLA_DIV_MULT BIT6:0, MPLLA_DIV_CLK_EN BIT7
+			LGM_NET_DBG("\nwriting to MPLLA_CTRL2 register for MPLLA_DIV_MULT\n");
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,port);
+			LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2 Setting MPLLA DIV8/DIV10/DIV16P5 bits = 0x%08x\n", read_data);		
+			read_data &= ~(0x1 << 8);	 // BIT8 MPLLA_DIV8_CLK_EN			= 0h
+			read_data |= (0x1 << 9);	 // BIT9 MPLLA_DIV10_CLK_EN 		= 1h
+			read_data |= (0x1 << 10);	 // BIT10 MPLLA_DIV16P5_CLK_EN		= 1h
+			indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,read_data,port);
+			indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2,port);
+			LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2 Setting MPLLA DIV8/DIV10/DIV16P5 bits = 0x%08x\n", read_data);
+		}
+		
+		//writing to MPLLB_CTRL1 register for MPLLB_SSC_EN BIT0, MPLLB_SSC_CLK_SEL BIT4, MPLLB_FRACN_CTRL BIT15:5
+		LGM_NET_DBG("\nwriting to MPLLB_CTRL1 register for MPLLB_SSC_EN, MPLLB_SSC_CLK_SEL and MPLLB_FRACN_CTRL\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLB_CTRL1,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_MPLLB_CTRL1 MPLLB_SSC_EN BIT0, MPLLB_SSC_CLK_SEL BIT[4] and MPLLB_FRACN_CTRL BIT{15:5] = 0x%08x\n", read_data); 	
+		read_data &= ~(0xFFE0 << 0); //Clear MPLLB_FRACN_CTRL BIT15:5 = 0h
+		//read_data &= ~(0x10 << 4); //Clear BIT4
+		read_data &= ~(0x1 << 0);	 // BIT0 MPLLB_SSC_EN			= 0h
+		
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLB_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MPLLB_CTRL1,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_MPLLB_CTRL1 MPLLB_SSC_EN BIT0, MPLLB_SSC_CLK_SEL BIT[4] and MPLLB_FRACN_CTRL BIT{15:5] = 0x%08x\n", read_data); 
+
+		//Change TX VBOOST_LVL to 0x3
+		LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1  register for TX VBOOST_LVL[10:8] \n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port); 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_LVL[10:8] = 0x%08x\n", read_data);
+		//read_data = read_data & 0xFFFFF8EF;
+		
+		read_data &= ~(0x7<<8); //Clear BIT[10:8] VBOOST_LVL
+		read_data |= 0x3 << 8;	 // BIT[10:8] VBOOST_LVL		= 3'd3
+		//read_data |= (txeq->tx_vboost_lvl) << 8; //Setting VBOOST_LVL BIT[10:8] = Default 0x5 after reset. VBOOST_EN_0 = 0x1 set later in lane specific
+	
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_LVL[10:8] = 0x%08x\n", read_data);
+
+		//set RX_TERM_ACDC_0 to 0x0
+		LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1  register for RX_TERM_ACDC_0[8] \n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1,port); 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1 RX_TERM_ACDC_0[8] = 0x%08x\n", read_data);
+		read_data |= (0x1 << 8);	 // BIT8 RX_TERM_ACDC_0		= 1h
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1 RX_TERM_ACDC_0[8] = 0x%08x\n", read_data);
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL1,read_data,port);
+		
+	
+		// ##### PMA LANE Configuration ######	
+		LGM_NET_DBG("########### PMA LANE Configuration ############ \n");	 
+	
+		//Writing to VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL 
+		//BIT0		MPLL_EN_0		= Set only if XPCS0, XPCS1, XPCS2, XPCS3, XPCS4, XPCS5
+		//BIT3:1	MPLL_EN_3_1 	= Set LANE1 BIT1 RXAUI only
+		//BIT4		MPLLB_SEL_0 	= Set only if 1G of XPCS0, XPCS1, XPCS2, XPCS3, XPCS4,
+		//BIT7:5	MPLLB_SEL_3_1	= Set LANE1 BIT1 Not used
+		LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL BIT0 MPLL_EN_0, BIT4 MPLLB_SEL0, BIT1 MPLL_EN_1, BIT5 MPLLB_SEL_1 = 0x%08x\n", read_data);
+	
+		if(port < WAN_XPCS4){
+			//enabling MPLLB
+			//read_data &= ~(0xFF<<0); //Clear BIT7:0
+			read_data |= 0x1 << 0;	 // BIT0 MPLL_EN_0		= 0h
+			read_data |= 0x1 << 4;	 // BIT4 MPLLB_SEL_0		= 1h
+		}else{
+			//enabling MPLLA
+			//read_data &= ~(0xFF<<0); //Clear BIT7:0
+			read_data |= 0x1 << 0;	 // BIT0 MPLL_EN_0			= 1h
+			//read_data |= 0x0 << 4;	 // BIT4 MPLLB_SEL_0	= 0h
+		}
+	
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL Setting BIT0 MPLL_EN_0, BIT4 MPLLB_SEL0, BIT1 MPLL_EN_1, BIT5 MPLLB_SEL_1 = 0x%08x\n", read_data);	
+	
+		//RX VCO configuration 
+		//writing to VR_XS_PMA_GEN5_12G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0
+		LGM_NET_DBG("\nwriting to PHY LANE0 VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0\n");
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,0x0540,port); //13'd1344 = 3'h540 
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0,port);	  
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0 register for VCO_LD_VAL_0 BIT12:0= 0x%08x\n", read_data);	
+	
+		//writing to VR_XS_PMA_GEN5_12G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT5:0 and VCO_REF_LD_1 BIT13:8
+		LGM_NET_DBG("\nwriting to PHY LANE0 & 1 VR_XS_PMA_GEN5_16G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT5:0 and VCO_REF_LD_1 BIT13:8\n");
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,0x0015,port);   //6'd21 = 2'h15
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0,port);	 
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_VCO_CAL_REF0 register for VCO_REF_LD_0 BIT5:0 and VCO_REF_LD_1 BIT13:8= 0x%08x\n", read_data);		
+	
+		//configuring RX_EQ_CTRL4 register for CONT_ADAPT_0 = 0
+		LGM_NET_DBG("\nconfiguring RX_EQ_CTRL4 register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT8 RX_DFE_BYP_0 = 0x%08x\n", read_data); 
+		read_data = read_data & 0xFFFFFFF0; //bit[0] = CONT_ADAPT_0, bit[3:1] CONT_ADAPT_3_1
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,(read_data),port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT8 RX_DFE_BYP_0 = 0x%08x\n", read_data);
+	
+		//Writing TX Rate
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_TX_RATE_CTRL register for TX0_RATE BIT2:0\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port); 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL TX0_RATE BIT2:0 = 0x%08x\n", read_data);
+		read_data = read_data & 0xFFFFFFF8; //bit[2:0] = 3'b000 : baud
+		if(port < WAN_XPCS4){
+			read_data |= 0x2 << 0; //MPLL VCO 7.5G - 1G bit[2:0] = 3'b010 : baud/4
+		}else{
+			read_data |= 0x3 << 0; //MPLL VCO 5G - 1G bit[2:0] = 3'b011 : baud/8
+		}
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL,port); 
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL TX0_RATE BIT2:0 = 0x%08x\n", read_data);	
+	
+		//Change to RX Rate
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL register for RX0_RATE BIT2:0\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port); 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL RX0_RATE BIT1:0 = 0x%08x\n", read_data);
+		read_data = read_data & 0xFFFFFFFC; //bit[2:0] = 0 //2'b00 : baud
+		
+		read_data |= 0x3 << 0; //1G  2'b011 : baud/8	  //original
+		//read_data |= 0x2 << 0; //1G  2'b010 : baud/4	
+		//read_data |= 0x1 << 0; //1G  2'b001 : baud/2	 
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,read_data,port);	
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL,port); 
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL RX0_RATE BIT1:0 = 0x%08x\n", read_data);	
+	
+		//Change TX Width
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 register for TX0_WIDTH BIT9:8\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port); 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 TX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+		read_data = read_data & 0xFFFFFCFF; //bit[9:8] = 10 //2'b10: 16-bit; 2'b11: 20-bit
+		read_data |= 0x1 << 8; //bit[8] = 1;bit[9] = 0 //2'b01: 10-bit; 2'b11: 20-bit
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,read_data,port);  
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2,port); 
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2 TX0_WIDTH BIT9:8 = 0x%08x\n", read_data);	
+	
+		//Change RX Width
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2 register for RX0_WIDTH BIT9:8\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port); 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2 RX0_WIDTH BIT9:8 = 0x%08x\n", read_data);
+		read_data = read_data & 0xFFFFFCFF; //bit[9:8] = 10 //2'b10: 16-bit; 2'b11: 20-bit
+		read_data |= 0x01 << 8; //bit[8] = 1;bit[9] = 0 //2'b01: 10-bit; 2'b11: 20-bit
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,read_data,port);  
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2,port); 
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2 RX0_WIDTH BIT9:8 = 0x%08x\n", read_data);	
+	
+		
+		/************* added PCIE reg for LGMC c10phy *******************************/
+		/*	PCIE_EXT_MPLLA_BANDWIDTH [18:16]  App register to d4 */
+		/*	PCIE_EXT_MPLLA_BANDWIDTH [14] to d0*/
+		/*	PCIE_EXT_MPLLA_BANDWIDTH [13:11] to d0 */
+		/*	PCIE_EXT_MPLLA_BANDWIDTH [10:3]  App register to d0*/
+		/*	PCIE_EXT_MPLLA_BANDWIDTH [2] to d0 */
+		
+		REG32(0xd0c40068) = 0x40001; // should be 0x40001 to enable Rx CDR tracking
+		LGM_NET_DBG("\nMPLLB_DIV_MULT REG32(0x%08x) = 0x%08x\n", 0xd0c40068, REG32(0xd0c40068));
+		
+		LGM_NET_DBG("\PCIE_EXT_MPLLB_SSC_RANGE REG32(0x%08x) = 0x%08x\n", 0xd0c4003c, REG32(0xd0c4003c));
+		
+		LGM_NET_DBG("\nPCIE_PHY_EXT_MISC_CTRL_B REG32(0x%08x) = 0x%08x\n", 0xd0c40074, REG32(0xd0c40074));
+
+		LGM_NET_DBG("\nPCIE_PHY_EXT_MPLLB_CTRL_3 REG32(0x%08x) = 0x%08x\n", 0xd0c4006c, REG32(0xd0c4006c));
+		
+		LGM_NET_DBG("\nPCIE_PHY_MPLLB_CTRL REG32(0x%08x) = 0x%08x\n", 0xd0c40014, REG32(0xd0c40014));
+
+		LGM_NET_DBG("\PCIE_PHY_EXT_EQ_CTRL_1A REG32(0x%08x) = 0x%08x\n", 0xd0c40040, REG32(0xd0c40040));
+
+
+		//Change TX IBOOST_LVL 
+		LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL ,port); 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL TX0_IBOOST[3:0] TX1_IBOOST[7:4] = 0x%08x\n", read_data);	
+		//Clear BITS
+		read_data &= ~(0xF << 0); //Clear BIT3:0 TX0_IBOOST
+		//read_data &= ~(0xF << 4); //Clear BIT7:4 TX1_IBOOST
+
+		//Set TX IBOOST Values
+		read_data |= (txeq->tx_iboost_lvl) << 0; //Set BIT3:0 TX0_IBOOST	
+		//read_data |= (txeq->tx_iboost_lvl) << 4; //Set BIT7:4 TX1_IBOOST	
+
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,read_data,port);	
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL ,port); 
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL TX0_IBOOST[3:0] TX1_IBOOST[7:4] = 0x%08x\n", read_data);
+
+		
+		//Set DFE_TAP1_0
+		LGM_NET_DBG("\nWriting DFE_TAP1_0 register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,port);	 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0 Setting DFE_TAP1_0 bit7:0 = 0x%08x\n", read_data);		
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,0x0,port); //Setting BIT7:0 = 8'd0
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0 Setting DFE_TAP1_0 bit7:0 = 0x%08x\n", read_data);
+		/********************************************************************************************/	
+
+		
+		//Change Enable TX VBOOST_EN here as it is per lane configuration
+		LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1	register for VBOOST_EN_0 BIT4 \n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 ,port); 
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 TX VBOOST_EN_0 BIT4 = 0x%08x\n", read_data);
+		read_data |= (txeq->tx_vboost_en) << 4; //Setting VBOOST_EN_0 = 0x1.
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,port); 
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 ,port);	
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 VBOOST_EN_0 BIT4	= 0x%08x\n", read_data);	
+	
+		//writing to PHY att_lvl register
+		LGM_NET_DBG("\nwriting to PHY RX attenuation Level register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL BIT2:0 RX0_EQ_ATT_LVL = 0x%08x\n", read_data);
+		read_data &= 0x0000FFF8;
+		read_data |= rxeq->rx_att_lvl << 0; //BIT2:0 RX0_EQ_ATT_LVL 	
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL BIT2:0 RX0_EQ_ATT_LVL = 0x%08x\n", read_data);
+	
+		//writing to PHY ctle_pole and boost and gain register
+		LGM_NET_DBG("\nwriting to PHY ctle_pole and boost and gain register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0 BIT14:12 VGA1_GAIN_0 BIT10:8 VGA2_GAIN_0 BIT6:5 CTLE_POLE_0 BIT4:0 CTLE_BOOST_0 = 0x%08x\n", read_data);
+		read_data &= 0xFFFF8880;
+		
+		read_data |= 0x7 << 0; // BIT4:0 CTLE_BOOST_0 = 3'd7
+	//	read_data |= rxeq->rx_ctle_boost << 0; //BIT4:0 CTLE_BOOST_0		= 18
+		read_data |=  (0x7 << 0); //BIT4:0 CTLE_BOOST_0 	= 7
+		read_data |= rxeq->rx_ctle_pole  << 5; //BIT6:5 CTLE_POLE_0 		= 0
+		read_data |= rxeq->rx_vga2_gain  << 8; //BIT10:8 VGA2_GAIN_0		= 4
+		read_data |= rxeq->rx_vga1_gain  << 12; //BIT14:12 VGA1_GAIN_0		= 4
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0 BIT14:12 VGA1_GAIN_0 BIT10:8 VGA2_GAIN_0 BIT6:5 CTLE_POLE_0 BIT4:0 CTLE_BOOST_0 = 0x%08x\n", read_data);
+	
+		//writing to RX PPM CTRL0 register VR_XS_PMA_Gen5_16G_RX_PPM_CTRL0
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0 register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0 BIT4:0 RX0_CDR_PPM_MAX= 0x%08x\n", read_data); 
+		read_data &= ~(0x0F0F<<0); //Clear BIT12:8 RX1_CDR_PPM_MAX and BIT4:0 RX0_CDR_PPM_MAX
+		read_data |= 18 	<< 0; //BIT4:0 RX0_CDR_PPM_MAX = 18
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0 BIT4:0 RX0_CDR_PPM_MAX= 0x%08x\n", read_data);
+	
+		//writing to RX CDR CTRL1 register
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1 register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1 BIT9:8 VCO_FRQBAND_0 BIT4 VCO_STEP_CTRL0, BIT0 VCO_TEMP_COMP_EN_0 = 0x%08x\n", read_data); 
+		read_data |= rxeq->rx_vco_temp_comp_en	<< 0; //BIT0 VCO_TEMP_COMP_EN_0 	= 1
+		read_data |= rxeq->rx_vco_step_ctrl 	<< 4; //BIT4 VCO_STEP_CTRL0 		= 1
+		read_data |= rxeq->rx_vco_frqband		<< 8; //BIT9:8 VCO_FRQBAND_0		= 1
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1 BIT9:8 VCO_FRQBAND_0 BIT4 VCO_STEP_CTRL0, BIT0 VCO_TEMP_COMP_EN_0 = 0x%08x\n", read_data);
+	
+		//writing to VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 register
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 BIT12:8 RX_VREF_CTRL = 0x%08x\n", read_data);	
+		read_data &= ~(0x1F<<8); //Clear BIT12:8 RX_VREF_CTRL
+		read_data |= 17 << 8; //BIT12:8 RX_VREF_CTRL = 8'd17
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0 BIT12:8 RX_VREF_CTRL = 0x%08x\n", read_data);
+	
+		//writing to RX_MISC_CTRL0 register
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0 register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0 BIT7:0 RX0_MISC = 0x%08x\n", read_data);	
+		read_data &= 0xFFFFFF00;
+	//	read_data |= rxeq->rx_misc << 0; //BIT7:0 RX0_MISC	= 2'h12 8'd18
+		read_data |= (0x6 << 0); //BIT7:0 RX0_MISC	= 8'd6
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0 BIT7:0 RX0_MISC = 0x%08x\n", read_data);
+	
+		//writing to VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 register
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 register to clear RX DFE BYPASS\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT8 RX_DFE_BYP_0 = 0x%08x\n", read_data); 
+		read_data &= ~(1 << 8); //Clear BIT8 RX_DFE_BYP_0
+		read_data |= rxeq->rx_dfe_bypass << 8; //BIT8 RX_DFE_BYP_0	= 0
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT8 RX_DFE_BYP_0 = 0x%08x\n", read_data);
+	
+		//writing to VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0 register
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0 register to set RX0_DELTA_IQ\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT11:8 RX0_DELTA_IQ = 0x%08x\n", read_data);	
+		read_data &= 0xFFFFF0FF; //BIT11:8 RX0_DELTA_IQ = 0
+		read_data |= rxeq->rx_delta_iq << 8; //BIT8 RX_DFE_BYP_0	= 0
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4 BIT11:8 RX0_DELTA_IQ = 0x%08x\n", read_data);	
+	
+		//writing to VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 register
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 register to set RX_ADPT_SEL_0 and RX0_ADPT_MODE\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 BIT5:4 RX0_ADPT_MODE BIT0 RX_ADPT_SEL_0 = 0x%08x\n", read_data);		
+		read_data &= ~(0x1 << 0); // Clear BIT0 RX_ADPT_SEL_0
+		read_data &= ~(0x3 << 4); // Clear BIT5:4 RX0_ADPT_MODE
+		read_data |= rxeq->rx_adapt_sel << 0; //BIT0 RX_ADPT_SEL_0	= 0 To Select Bank0 for Adapt
+		read_data |= rxeq->rx_adapt_mode << 4; //BIT5:4 RX0_ADPT_MODE = 3
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5 BIT5:4 RX0_ADPT_MODE BIT0 RX_ADPT_SEL_0 = 0x%08x\n", read_data);	
+	
+		// added for LGMC0 c10phy ////////////////////////////////////////////
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+		LGM_NET_DBG("[RD] VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 BIT12 TX_CLK_RDY_0 = 0x%08x\n", read_data);
+		read_data &= ~(0x1 << 12); //Clear BIT[12] TX_CLK_RDY_0
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,port);
+		LGM_NET_DBG("[WR] VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 BIT12 TX_CLK_RDY_0 = 0x%08x\n", read_data);
+
+		//writing to PHY LOS threshold register 
+		LGM_NET_DBG("\nwriting to PHY LOS threshold register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3 LOS_TRSHLD_0 BIT2:0 = 0x%08x\n", read_data);
+		
+		read_data &= ~(0x7<<0); //Clear BIT2:0 LOS_TRSHLD_0[2:0]
+		read_data |= 0x3 << 0; //BIT2:0 LOS_TRSHLD_0[2:0] = d'3
+		read_data &= ~(0x1 << 12); //BIT12 LOS_LFPS_EN_0[12] = d'0
+		indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3 LOS_TRSHLD_0 BIT2:0 = 0x%08x\n", read_data);
+	
+		//writing to VR_XS_PMA_GEN5_16G_MISC_CTRL2 register
+		LGM_NET_DBG("\nwriting to VR_XS_PMA_GEN5_16G_MISC_CTRL2 register\n");
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port);
+		LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_16G_MISC_CTRL2 BIT7:0 SUP_MISC[7:0] = 0x%08x\n", read_data);	
+		read_data &= ~(0xFF<<0); //Clear BIT7:0 SUP_MISC[7:0]
+		read_data |= 0x1 << 0; //BIT7:0 SUP_MISC[7:0] = 1
+		indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MISC_CTRL2,read_data,port);
+		indirect_pcs_rd(VR_XS_PMA_GEN5_16G_MISC_CTRL2,port);
+		LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_16G_MISC_CTRL2 BIT7:0 SUP_MISC[7:0] = 0x%08x\n", read_data);
+	
+//		debugmsg = 0;
+
+}
+
+void ct_base_1g_c10phy_bringup(int port){
+		if(port < WAN_XPCS4)
+			LGM_NET_DBG("\n########## Start to bring up 1G SGMII LAN XPCS %d ##########\n", port);
+		else if(port == XPCS1)
+			LGM_NET_DBG("\n########## Start to bring up 1G SGMII LAN XPCS %d ##########\n", port);
+		else if(port == WAN_XPCS4)
+			LGM_NET_DBG("\n########## Start to bring up 1G SGMII WAN XPCS %d ##########\n", port);
+		else if(port == XPCS5)
+			LGM_NET_DBG("\n########## Start to bring up 1G SGMII LAN XPCS %d ##########\n", port);
+	
+		//check SRAM_INIT_DONE
+		//sram_init_chk(port); //Not required for 1000BASE-X
+	
+		//Initializing XPCS x Port
+		//LGM_NET_DBG("\nStart to bring up 1G Port%d\n", port);
+	
+		ct_check_rxtx_stable(port);
+		ct_disable_an(port);
+		ct_disable_an_37(port);
+		ct_pma_type_config(port);
+		ct_base_1g_c10phy_serdes_bringup(port);
+	
+		//CSR block triggers the software reset process: all internal blocks are reset except Managment Interface block and SDR block.
+		//PHY is also reset. Self clearing.
+		//vr_reset(port,~(autoneg_1g)); //XPCS0 and XPCS2 need to reset the last if both XPCS0 and XPCS1 or XPCS2 and XPCS3 are configured together.
+	
+#if 0
+		/*Clause 37 Auto-negotiation Setup*/
+	
+		if(port == XPCS0 || port == XPCS2 || port == WAN_XPCS4 || port == XPCS5){
+			/*Clause 37 Auto-negotiation Setup*/
+			if (autoneg_1g == 1){	
+				cl37_autoneg(port, 0x0);
+			}else{
+	
+#if 0
+				 //Program Various field of VR_MII_AN_CTRL register
+				 //Set SGMII Mode for 1G
+				 /*VR_MII_AN_CTRL
+				 BIT0	 MII_AN_INTR_EN = 1b to enable Complete Interrupt Enable.
+				 BIT2:1  PCS_MODE = 00b for 1000BASE-X mode
+				 BIT3	 TX_CONFIG = 1b; 0b for DWC_xpcs as MAC side, 1b for PHY side
+				 BIT4	SGMII_LINK_STS = 0b Link Down; 1b Link Up
+				 BIT8	 MII_CTRL = 1b for 8-BIT MII*/
+				 LGM_NET_DBG("\nSet VR_MII_AN_CTRL Setting MII_AN_INTR_EN BIT0 = 1'b1 PCS_MODE BIT2:1 = 2'b10, TX_CONFIG BIT3 = 1'b1\n");
+				 indirect_pcs_rd(VR_MII_AN_CTRL,port);
+				 read_data = read_data & 0xFFFFFF70;
+				 //indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x010d),port); //For PHY. try 0x0108 for PHY side.
+				 indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x0100),port); //For MAC. try 0x0100 for MAC side.
+				 indirect_pcs_rd(VR_MII_AN_CTRL,port);
+				 LGM_NET_DBG("[WR] Enabling PCS mode VR_MII_AN_CTRL = 0x%08x\n", read_data);  
+#endif
+				 //Disable C73 and CL37 Auto-negotiation as not supported by SFP+ as it was default enable for CL73 and CL37
+				disable_an(port);
+				disable_an_37(port);		
+	
+			}
+	
+			if(port == XPCS0 || port == XPCS2){
+				int port_sel = port + 1;
+				/*Clause 37 Auto-negotiation Setup*/
+				if (autoneg_1g == 1){	
+					cl37_autoneg(port_sel, 0x0);
+				}else{
+#if 0
+					 //Program Various field of VR_MII_AN_CTRL register
+					 //Set SGMII Mode for 1G
+					 /*VR_MII_AN_CTRL
+					 BIT0	 MII_AN_INTR_EN = 1b to enable Complete Interrupt Enable.
+					 BIT2:1  PCS_MODE = 00b for 1000BASE-X mode
+					 BIT3	 TX_CONFIG = 1b; 0b for DWC_xpcs as MAC side, 1b for PHY side
+					 BIT4	SGMII_LINK_STS = 0b Link Down; 1b Link Up
+					 BIT8	 MII_CTRL = 1b for 8-BIT MII*/
+					 LGM_NET_DBG("\nSet VR_MII_AN_CTRL Setting MII_AN_INTR_EN BIT0 = 1'b1 PCS_MODE BIT2:1 = 2'b10, TX_CONFIG BIT3 = 1'b1\n");
+					 indirect_pcs_rd(VR_MII_AN_CTRL,port_sel);
+					 read_data = read_data & 0xFFFFFF70;
+					 //indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x010d),port_sel); //For PHY. try 0x0108 for PHY side.
+					 indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x0100),port_sel); //For MAC. try 0x0100 for MAC side.
+					 indirect_pcs_rd(VR_MII_AN_CTRL,port_sel);
+					 LGM_NET_DBG("[WR] Enabling PCS mode VR_MII_AN_CTRL = 0x%08x\n", read_data);  
+#endif
+					 //Disable C73 and CL37 Auto-negotiation as not supported by SFP+ as it was default enable for CL73 and CL37
+					disable_an(port_sel);
+					disable_an_37(port_sel);		
+	
+				}		
+			}
+		}
+#endif
+	
+/*
+		// added for debugging	
+		
+		dprint_enable=0;
+		if (dprint_enable == 1)
+			dump_xpcs_c10phy_reg(port);
+			
+		dprint_enable=0;
+		//////////////////////////////////
+		
+		if (dprint_enable == 1)
+			dump_xpcs_tx_reg(port);
+*/
+		LGM_NET_DBG("\n 1G XPCS%d Bring Up Complete.\n", port);	
+
+
+}
+
+//VR Reset
+void ct_vr_reset(int port)
+{
+	LGM_NET_DBG("\ntriggering Port%d VR reset\n", port);			
+		indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	LGM_NET_DBG("VR_RST[RD] BIT15 = 0x%08x\n", read_data);
+	read_data   = read_data | 0x8000; //triggering VR reset
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,read_data,port);
+	
+	LGM_NET_DBG("VR_RST[WR] BIT15 = 0x%08x\n", read_data);
+	mdelay(10);
+	indirect_pcs_rd(VR_XS_PCS_DIG_STS,port);
+	LGM_NET_DBG("VR_XS_PCS_DIG_STS = 0x%08x\n", read_data);
+
+	mdelay(20);
+	
+	indirect_pcs_rd(VR_XS_PCS_DIG_STS,port);
+	LGM_NET_DBG("VR_XS_PCS_DIG_STS = 0x%08x\n", read_data);
+	
+ 	/*do{
+			indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port); //Waiting for BIT15 VR_RST to set.
+	}while((read_data & 0x8000)  ==  0x0000); //check for tx, rx are stable */
+	//indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	//LGM_NET_DBG("VR_RST Set BIT15 = 0x%08x\n", read_data);
+
+	//[Added 20-Oct-2019]: To follow SNPS Cores Ethernet PCS Databook Version 3.30a 
+	//Add SRAM init check and Set LD_DONE before pooling for VR_RST clear.
+
+#if 0	
+	//dprint_enable = 0;
+
+	#define VR_RESET BIT(15) //VR_RESET BIT
+	#define VR_RESET_CNT 2000
+	u32 val;
+	int i;
+	for (i = 0; i < VR_RESET_CNT; i++) {
+		if (!((indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port)) & VR_RESET))
+		{
+			//dprint_enable = 1;
+			val = indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+			LGM_NET_DBG("VR_XS_PCS_DIG_CTRL1 0x%08x BIT15 VR_RST %s\n",
+			val, (val & VR_RESET)? "set": "clr");
+			break;
+		}
+		udelay(10);
+	}
+	
+	if (i >= VR_RESET_CNT)
+		LGM_NET_DBG("XPCS VR RESET Failed\n");
+	else {
+		LGM_NET_DBG("XPCS VR RESET succeed\n");
+	}
+
+	//dprint_enable = 1;
+#if 0
+ 	do{
+			indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port); //Waiting for BIT15 VR_RST to clear.
+	}while((read_data & 0x8000)  ==  0x8000); //check for tx, rx are stable 
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+	LGM_NET_DBG("VR_RST Clear BIT15 = 0x%08x\n", read_data);
+#endif
+
+	LGM_NET_DBG("\nChecking rx tx stable\n");
+    indirect_pcs_rd(VR_XS_PCS_DIG_STS,port); //passing xpcs port num
+    //mdelay(1);
+    LGM_NET_DBG("PSEQ_STATE BIT4:2 = 0x%08x\n", read_data);
+   
+	LGM_NET_DBG("\n[WHILE] check for tx, rx are stable\n");
+	check_rxtx_stable(port);
+#endif
+}
+
+
+//TX EQ Override in XPCS
+void ct_tx_eq_config(int port, struct tx_eq *txeq)
+{
+	//Setting TX EQ_MAIN, EQ_PRE, EQ_POST
+	LGM_NET_DBG("\nConfiguring TX EQ for PHY Port%d \n",port);
+	
+	//Set VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 TX_EQ_PRE BIT5:0, TX_EQ_MAIN BIT13:8
+	LGM_NET_DBG("Set VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 EQ_PRE BIT5:0, EQ_MAIN BIT13:8 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 ,port);
+	//Clear BITS
+	read_data &= ~(0x3F << 0); //Clear BIT5:0 EQ_PRE
+	read_data &= ~(0x3F << 8); //Clear BIT13:8 EQ_MAIN
+
+	//Set TX EQ Values
+	read_data |= (txeq->tx_pre_cursor) << 0; //Set BIT5:0 EQ_PRE
+	read_data |= (txeq->tx_main_cursor) << 8; //SetBIT13:8 EQ_MAIN
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0,read_data,port);
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 ,port);
+	LGM_NET_DBG("VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0 = 0x%08x\n", read_data);
+
+	//Set VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 TX_EQ_POST BIT5:0, TX_EQ_OVR_RIDE BIT6 
+	LGM_NET_DBG("\nRead VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 TX_EQ_POST BIT5:0, TX_EQ_OVR_RIDE BIT6 \n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 ,port);
+	//Clear BITS
+	read_data &= ~(0x3F << 0); //Clear BIT5:0 TX_EQ_POST
+	read_data &= ~(0x1 << 6); //Clear BIT6 TX_EQ_OVR_RIDE
+
+	//Set TX EQ Values
+	read_data |= (txeq->tx_post_cursor) << 0; //Set BIT5:0 TX_EQ_POST
+	read_data |= (0x1) << 6; //Set BIT6 TX_EQ_OVR_RIDE
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,read_data,port);
+	
+	//indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,0x0054,port); //eq_post = 20 (0x14), ovr_ride = 1
+	//indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,0x068,port); //eq_post = 40 (0x28), ovr_ride = 1
+	//indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,0x060,port); //preset 7 eq_post = 32 (0x20), ovr_ride = 1
+	//indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1,0x040,port); //preset 4/5/6 eq_post = 0 (0x0), ovr_ride = 1
+
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 ,port);
+	LGM_NET_DBG("VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1 = 0x%08x\n", read_data);	
+
+	//Change TX IBOOST_LVL to higher from 0x5 to 0xF
+	LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL register\n");
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL ,port); 
+	LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL TX0_IBOOST[3:0] TX1_IBOOST[7:4] = 0x%08x\n", read_data);	
+	//Clear BITS
+	read_data &= ~(0xF << 0); //Clear BIT3:0 TX0_IBOOST
+	read_data &= ~(0xF << 4); //Clear BIT7:4 TX1_IBOOST
+
+	//Set TX IBOOST Values
+	read_data |= (txeq->tx_iboost_lvl) << 0; //Set BIT3:0 TX0_IBOOST	
+	read_data |= (txeq->tx_iboost_lvl) << 4; //Set BIT7:4 TX1_IBOOST	
+
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL,read_data,port);	
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL ,port); 
+	LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL TX0_IBOOST[3:0] TX1_IBOOST[7:4] = 0x%08x\n", read_data);
+
+}
+
+static void ct_hsiotop_xgmiiclk_gate_cfg(int port, int enable)
+{
+	if(port == 0){
+		//SET_X_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, enable);
+		REG32(HSIOL_TOP_BASE + XPCS0_XGMII_CLK_CTR_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), XPCS0_XGMII_CLK_CTR_POS, XPCS0_XGMII_CLK_CTR_WIDTH,enable);
+		udelay(10);
+		LGM_NET_DBG("HSIOL Port%d XGMII TX and RX CLK DIS CFG: Enable XGMII CLK = 0x%08x\n", port, REG32(HSIOL_TOP_BASE + XPCS0_XGMII_CLK_CTR_REG));
+	}else if(port == 1){
+		//SET_X_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, enable);
+		REG32(HSIOL_TOP_BASE + XPCS1_XGMII_CLK_CTR_REG) = SET_DATA_BITS(REG32(HSIOL_TOP_BASE + ETHSATA_CLK_DIS_REG), XPCS1_XGMII_CLK_CTR_POS, XPCS1_XGMII_CLK_CTR_WIDTH, enable);
+		LGM_NET_DBG("HSIOL Port%d XGMII TX and RX CLK DIS CFG: Enable XGMII CLK = 0x%08x\n", port, REG32(HSIOL_TOP_BASE + XPCS1_XGMII_CLK_CTR_REG));
+	}else if(port == 2){
+		//SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS0_CLK_DIS_WIDTH, enable);
+		REG32(HSIOR_TOP_BASE + XPCS0_XGMII_CLK_CTR_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), XPCS0_XGMII_CLK_CTR_POS, XPCS0_XGMII_CLK_CTR_WIDTH, enable);
+		LGM_NET_DBG("HSIOR Port%d XGMII TX and RX CLK DIS CFG: Enable XGMII CLK = 0x%08x\n", port, REG32(HSIOR_TOP_BASE + XPCS0_XGMII_CLK_CTR_REG));
+	}else if(port == 3){
+		//SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, enable);
+		REG32(HSIOR_TOP_BASE + XPCS1_XGMII_CLK_CTR_REG) = SET_DATA_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), XPCS1_XGMII_CLK_CTR_POS, XPCS1_XGMII_CLK_CTR_WIDTH, enable);
+		LGM_NET_DBG("HSIOR Port%d XGMII TX and RX CLK DIS CFG: Enable XGMII CLK = 0x%08x\n", port, REG32(HSIOR_TOP_BASE + XPCS1_XGMII_CLK_CTR_REG));
+	}else if(port == 4){
+		//SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, enable);
+		REG32(PON_WAN_PHY_APP_BASE + RSVDP_REG0) = SET_DATA_BITS(REG32(PON_WAN_PHY_APP_BASE + RSVDP_REG0), RSVDP_REG0_XGMII_TX_CLKG_POS, RSVDP_REG0_XGMII_TX_CLKG_WIDTH, enable);
+		LGM_NET_DBG("HSIO Port%d XGMII TX CLK DIS CFG: Enable XGMII TX CLK = 0x%08x\n", port, REG32(PON_WAN_PHY_APP_BASE + RSVDP_REG0));
+		REG32(PON_WAN_PHY_APP_BASE + RSVDP_REG0) = SET_DATA_BITS(REG32(PON_WAN_PHY_APP_BASE + RSVDP_REG0), RSVDP_REG0_XGMII_RX_CLKG_POS, RSVDP_REG0_XGMII_RX_CLKG_WIDTH, enable);
+		LGM_NET_DBG("HSIO Port%d XGMII TX CLK DIS CFG: Enable XGMII RX CLK = 0x%08x\n", port, REG32(PON_WAN_PHY_APP_BASE + RSVDP_REG0));		
+	}else if(port == 5){
+		//SET_X_BITS(REG32(HSIOR_TOP_BASE + ETHSATA_CLK_DIS_REG), ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_POS, ETHSATA_CLK_DIS_REG_XPCS1_CLK_DIS_WIDTH, enable);
+		REG32(CHIP_TOP_BASE + XPCS5_CFG_REG) = SET_DATA_BITS(REG32(CHIP_TOP_BASE + XPCS5_CFG_REG), XGMII_CLK_EN_POS, XGMII_CLK_EN_WIDTH, enable);
+		LGM_NET_DBG("HSIO Port%d TOP CLK DIS CFG: Enable XGMII TX and RX CLK = 0x%08x\n", port, REG32(CHIP_TOP_BASE + XPCS5_CFG_REG));
+	}
+}
+
+
+void ct_cl37_autoneg(int port, u32 link_timer){
+	/*Clause 37 Auto-negotiation Setup*/
+
+
+		//Configuration of Auto-negotiation Settings.
+		LGM_NET_DBG("\nConfiguration of CL37 Auto-negotiation Settings.\n");
+		
+		 //Clause37 Auto-negotiation Setup
+		 
+		 //Disable C73 Auto-negotiation
+		 //SR_AN_CTRL BIT12 AN_EN
+		 LGM_NET_DBG("\nSet SR_AN_CTRL Setting BIT12 AN_EN = 1'b0 to disable C73 autoneg\n");
+		 indirect_pcs_rd(SR_AN_CTRL,port);
+		 indirect_pcs_wr(SR_AN_CTRL,(read_data &0xFFFFEFFF),port);
+		 indirect_pcs_rd(SR_AN_CTRL,port);
+		 LGM_NET_DBG("[WR]Set SR_AN_CTRL Setting BIT12 AN_EN = 0x%08x\n", read_data); 
+		 
+		 //Enable Backplane CL37 autoneg
+		 //VR_XS_PCS_DIG_CTRL1 Setting AN_ENABLE BIT12 = 1
+		 LGM_NET_DBG("\nSet VR_XS_PCS_DIG_CTRL1 Setting AN_ENABLE BIT12 = 1 to enable BP CL37 Autoneg\n");
+		 indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+		 indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1,(read_data | 0x1000),port);
+		 indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1,port);
+		 LGM_NET_DBG("[WR]VR_XS_PCS_DIG_CTRL1 Setting AN_ENABLE BIT12 = 0x%08x\n", read_data);  
+		
+		 //Disable CL37 autoneg first SR_MII_CTRL Setting AN_ENABLE BIT12 = 0
+		 LGM_NET_DBG("\nSet SR_MII_CTRL Setting AN_ENABLE BIT12 = 0 to enable CL37 Autoneg\n");
+		 indirect_pcs_rd(SR_MII_CTRL,port);
+		 //indirect_pcs_wr(SR_MII_CTRL,(read_data & 0xFFFFEFFF),port);
+		 indirect_pcs_wr(SR_MII_CTRL,(read_data & 0xEFFF),port);
+		 indirect_pcs_rd(SR_MII_CTRL,port);
+		 LGM_NET_DBG("[WR]SR_MII_CTRL Setting AN_ENABLE BIT12 = 0x%08x\n", read_data);	 
+
+		 //Program Various field of VR_MII_AN_CTRL register
+		 //Set SGMII Mode for 1G
+		 /*VR_MII_AN_CTRL
+		 BIT0	 MII_AN_INTR_EN = 1b to enable Complete Interrupt Enable.
+		 BIT2:1  PCS_MODE = 10b for SGMII mode
+		 BIT3	 TX_CONFIG = 1b; 0b for DWC_xpcs as MAC side, 1b for PHY side
+		 BIT4	SGMII_LINK_STS = 0b Link Down; 1b Link Up
+		 BIT8	 MII_CTRL = 1b for 8-BIT MII*/
+		 LGM_NET_DBG("\nSet VR_MII_AN_CTRL Setting MII_AN_INTR_EN BIT0 = 1'b1 PCS_MODE BIT2:1 = 2'b10, TX_CONFIG BIT3 = 1'b1\n");
+		 indirect_pcs_rd(VR_MII_AN_CTRL,port);
+		 read_data = read_data & 0xFFFFFF70;
+		 //indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x010d),port); //For PHY. try 0x0105 for MAC side.
+		 indirect_pcs_wr(VR_MII_AN_CTRL,(read_data | 0x0105),port); //For MAC. try 0x010d for PHY side.
+		 indirect_pcs_rd(VR_MII_AN_CTRL,port);
+		 LGM_NET_DBG("[WR] Enabling PCS mode VR_MII_AN_CTRL = 0x%08x\n", read_data);  
+		
+
+#if 1 //Enable if TX_CONFIG is 1 (PHY SIDE)
+		   /*Configure VR_MII_DIG_CTRL1 BIT0 to 1. DWC_xpcs adveritses the values of input ports xpcs_sgmii_link_sts_i, xpcs_sgmii_link_speed_i and
+			xpcs_sgmii_full_duplex_i during SGMII/(Port0)QSGMII autonegotiation.*/
+		   LGM_NET_DBG("\nSet VR_MII_DIG_CTRL1 MAC_AUTO_SW BIT0 = 1 for DWC_xpcs adveritses the values of input ports \n");
+		   indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		   indirect_pcs_wr(VR_MII_DIG_CTRL1,(read_data | 0x0200),port);
+		   indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		   LGM_NET_DBG("[WR]VR_MII_DIG_CTRL1 Setting MAC_AUTO_SW BIT0 = 0x%08x\n", read_data);  
+		
+		
+		   //Configure SR_MII_AN_ADV BIT5 FD to 1 for Full duplex
+		   LGM_NET_DBG("\nConfigure SR_MII_AN_ADV BIT5 FD to 1 for Full duplex\n");
+		   indirect_pcs_rd(SR_MII_AN_ADV,port);
+		   indirect_pcs_wr(SR_MII_AN_ADV,(read_data | 0x0020),port);
+		   indirect_pcs_rd(SR_MII_AN_ADV,port);
+		   LGM_NET_DBG("[WR]VR_MII_DIG_CTRL1 SR_MII_AN_ADV BIT5 FD set 1 = 0x%08x\n", read_data);  
+#endif      
+		
+#if 0 //Enable if TX_CONFIG is 0 (MAC SIDE)
+		   //Configure VR_MII_DIG_CTRL1 Speed to change to Negotiated Speed after CL37 
+		   LGM_NET_DBG("\nSet VR_MII_DIG_CTRL1 MAC_AUTO_SW BIT9 = 1 to auto switch to CL37 Autonegotiated speed after CL37 completion\n");
+		   indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		   indirect_pcs_wr(VR_MII_DIG_CTRL1,(read_data | 0x0200),port);
+		   indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		   LGM_NET_DBG("[WR]VR_MII_DIG_CTRL1 Setting MAC_AUTO_SW BIT9 = 0x%08x\n", read_data);	
+#endif   
+
+	   /*	(Optional step) Duration of link timer can be changed (default setting corresponds to 1.6ms) by
+			programming VR_MII_LINK_TIMER_CTRL Register suitably and by setting bit [3] of
+			VR_MII_DIG_CTRL1 Register to 1.
+		  
+		  	For USXGMII configurations: This field forms the upper
+			16-bit of the 24-bit value that gets loaded to the link timer.The
+			lower 8-bits are hard-coded as zero. For example, if
+			CL37_LINK_TIME = 1, the value that is loaded to the timer is
+			24'h100, which corresponds to a duration of 1638 ns
+			(256*6.4ns) in USXGMII mode or 2048 ns (256*8ns) in
+			1000BaseX/SGMII mode.
+
+			24 Bits
+			[24:8] 	Upper 16bits in this VR_MII_LINK_TIMER_CTRL register
+			[7:0]	Lower 8bits hardcoded to 0h.
+
+			For configurations without USXGMII: This field forms the
+			upper 16-bit of the 24-bit value that gets loaded to the link
+			timer.The lower 8-bits are hardcoded as 8'h7D. For example, if
+			CL37_LINK_TIME = 1, the value that is loaded to the timer is
+			24'h17D, which corresponds to a duration of 3048 ns
+			(381*8ns).
+
+			For 2.5G SGMII
+			DWC_xpcs supports SGMII auto-negotiation in 2.5G mode, if the link-partner is also configured to 2.5G
+			mode. Before enabling auto-negotiation (step 8),
+			Enable 2.5G mode by programming bit[2] (EN_2_5G_MODE) of VR MII/XS/PCS MMD Digital
+			Control 1 Register
+			Program VR_MII_LINK_TIMER_CTRL to 16'h07A1 so that link timer runs for 1.6ms.
+			Program bit[3] (CL37_TMR_OVR_RIDE) of VR_MII_DIG_CTRL1 Register to 1.
+	   
+	   */
+#if 1	  
+	if(link_timer > 0){
+			//Setting to 1.6ms = 500,093*3.2ns = 0x7A17D (BIT[24:8] = 0x7A1)
+		   	LGM_NET_DBG("\nSet VR_MII_LINK_TIMER_CTRL BIT15:0 = 0x1000 (6.71ms)\n"); //Default is 0x400 which is 1.6ms (262,144*6.4ns). 0x1000 = 6.71ms  
+		   	indirect_pcs_rd(VR_MII_LINK_TIMER_CTRL,port);
+		   	LGM_NET_DBG("VR_MII_LINK_TIMER_CTRL = 0x%08x\n", read_data);
+		   	//read_data = read_data | 0x00001000;
+		   	read_data = read_data | link_timer; //set to 1.6ms in SGMII Mode
+		   	indirect_pcs_wr(VR_MII_LINK_TIMER_CTRL,read_data,port);
+		   	indirect_pcs_rd(VR_MII_LINK_TIMER_CTRL,port);	  
+		   	LGM_NET_DBG("VR_MII_LINK_TIMER_CTRL = 0x%08x\n", read_data);
+	   
+		   	LGM_NET_DBG("\nSet VR_MII_DIG_CTRL1 BIT3 = 1'b1 (6.71ms)\n"); //To override the CL37 LINKTIMER
+		   	indirect_pcs_rd(VR_MII_DIG_CTRL1,port);
+		   	LGM_NET_DBG("VR_MII_DIG_CTRL1 = 0x%08x\n", read_data);
+		   	read_data = read_data | 0x00000008;
+		   	indirect_pcs_wr(VR_MII_DIG_CTRL1,read_data,port);
+		   	indirect_pcs_rd(VR_MII_DIG_CTRL1,port);	  
+		   	LGM_NET_DBG("VR_MII_DIG_CTRL1 = 0x%08x\n", read_data);
+	}
+#endif
+
+#if 0	
+	   //Configuring VR_AN_TIMER_CTRL1 to higher value
+		LGM_NET_DBG("\nConfiguring VR_AN_TIMER_CTRL1 to higher value\n");
+	    indirect_pcs_rd(VR_AN_TIMER_CTRL1,port);
+	    read_data = read_data | 0x00000001; //setting bit [0] to 1
+	    //read_data = read_data | 0x00000002; //setting bit [0] to 2
+	    indirect_pcs_wr(VR_AN_TIMER_CTRL1,read_data,port);
+	    //Configuring VR_AN_DIG_CTRL to higher value
+		LGM_NET_DBG("\nConfiguring VR_AN_DIG_CTRL to higher value\n");
+	    indirect_pcs_rd(VR_AN_DIG_CTRL,port);
+	    read_data = read_data | 0x00000008; //setting bit [3] to 1
+	    indirect_pcs_wr(VR_AN_DIG_CTRL,read_data,port);
+	   //Adding it as per new PCS data sheet for FAST_SIM 
+		/*LGM_NET_DBG("\nAdding it as per new PCS data sheet \n");
+	    indirect_pcs_rd(SR_VSMMD_CTRL,port);
+	    indirect_pcs_wr(SR_VSMMD_CTRL,(read_data | 0x0010),port);*/
+	    //Restart autonegotiation
+		LGM_NET_DBG("\nRestart autonegotiation\n");
+	    indirect_pcs_rd(SR_AN_CTRL,port);
+	    indirect_pcs_wr(SR_AN_CTRL,(read_data | 0x0200),port);
+#endif
+
+		//SR_MII_CTRL Setting AN_ENABLE BIT12 = 1
+		LGM_NET_DBG("\nSet SR_MII_CTRL Setting AN_ENABLE BIT12 = 1 to enable CL37 Autoneg\n");
+	    indirect_pcs_rd(SR_MII_CTRL,port);
+	    //indirect_pcs_wr(SR_MII_CTRL,(read_data & 0xFFFFEFFF),port);
+	    indirect_pcs_wr(SR_MII_CTRL,(read_data | 0x1000),port);
+		indirect_pcs_rd(SR_MII_CTRL,port);
+		LGM_NET_DBG("[WR]SR_MII_CTRL Setting AN_ENABLE BIT12 = 0x%08x\n", read_data);  	
+
+
+}
+
+
+u32 ct_serdes_cr_write(int port, u32 addr, u32 data)
+{
+	#define CR_PORT_BUSY_TIMEOUT	5000
+	int i;
+	u32 read_data;
+
+	//Wait for BIT0 START_BUSY to becomes 0 = not busy 
+	for (i = 0; i < CR_PORT_BUSY_TIMEOUT; i++) {
+		if (indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port) && ~BIT(0))
+			break;
+		udelay(10);
+	}
+	
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_ADDR, addr, port); //Set CR Address to access
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_DATA, data, port); //Set CR Data to write
+
+	//Start Write Process
+	read_data = indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port);
+	read_data = SET_DATA_BITS(read_data, 1, 1, 0x1); //Set BIT1 to enable write access
+	read_data = SET_DATA_BITS(read_data, 0, 1, 0x1); //Set BIT0 to start port access
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_CTRL, read_data, port);
+
+	for (i = 0; i < CR_PORT_BUSY_TIMEOUT; i++) {
+		if (indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port) && ~BIT(0))
+			break;
+		udelay(10);
+	}
+
+	return 0;
+}
+
+
+u32 ct_serdes_cr_read(int port, u32 addr)
+{
+	#define CR_PORT_BUSY_TIMEOUT	5000
+	int i;
+	u32 read_data;
+
+	//Wait for BIT0 START_BUSY to becomes 0 = not busy 
+	for (i = 0; i < CR_PORT_BUSY_TIMEOUT; i++) {
+		if (indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port) && ~BIT(0))
+			break;
+		udelay(10);
+	}
+	
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_ADDR, addr, port); //Set CR Address to access
+
+	//Start Read Process
+	read_data = indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port);
+	read_data = SET_DATA_BITS(read_data, 1, 1, 0x0); //Set BIT1 to enable read access
+	read_data = SET_DATA_BITS(read_data, 0, 1, 0x1); //Set BIT0 to start port access
+	indirect_pcs_wr(VR_XS_PMA_SNPS_CR_CTRL, read_data, port);
+	
+	for (i = 0; i < CR_PORT_BUSY_TIMEOUT; i++) {
+		if (indirect_pcs_rd(VR_XS_PMA_SNPS_CR_CTRL, port) && ~BIT(0))
+			break;
+		udelay(10);
+	}
+	
+	read_data = indirect_pcs_rd(VR_XS_PMA_SNPS_CR_DATA, port); //Read Data from CR
+
+	return read_data;
+}
+
+
+void ct_phy_rxeq_autoadapt(int port, int lane)
+{
+	#define PHY_RXADAPT_POLL_CNT	5000
+	int i;
+	//u32 phy_cr_base = combo_phy_cr_base(port),
+	u32 rd_data;
+
+	if(port!= P34X_PORT5){	
+		LGM_NET_DBG("\nRX value before Adaptation:\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_0 (0x%08x) = 0x%08x\nBIT15:11 EQ_CTLE_BOOST\nBIT10:7 EQ_VGA2_GAIN\nBIT6:3 EQ_VGA1_GAIN\nBIT2:0 EQ_ATT_LVL\n", 
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(port, lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(port, lane)));
+		LGM_NET_DBG("\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_1 (0x%08x) = 0x%08x\nBIT10:3 EQ_DFE_TAP1\nBIT2:0 EQ_CTLE_POLE\n", 
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(port, lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(port, lane)));
+		
+		//RAWLANEN_DIG_PCS_XF_RX_OVRD_IN_3
+		/* 	15		CONT_OVRD_EN = 0
+			14		OFFCAN_CONT = 0
+			13		ADAPT_CONT = 0
+			12		ADAPT_REQ_OVRD_EN = 0
+			11		ADAPT_REQ = 0
+			10		REF_LD_VAL_OVRD_EN = 0
+			9:4		REF_LD_VAL_OVRD = 0
+			3		RX_LOS_THRSHLD_OVRD_EN = 0
+			2:0		RX_LOS_THRSHLD_OVRD_VAL = 0
+		*/
+
+		REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) &= ~(0x3 << 4); //Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5
+		REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) |= 0x3 << 4; //ADAPT_REQ and ADAPT_REQ_OVRD_EN set to '11'
+		LGM_NET_DBG("\nRequest for RX Adaptation to start:\n RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2 (0x%08x) = 0x%08x\n", 
+			(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)), REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) );	
+		
+		//Check for RX Adaptation is done RAWLANEN_DIG_AON_RX_ADAPT_DONE.RX_ADAPT_DONE[0]
+		for (i = 0; i < PHY_RXADAPT_POLL_CNT; i++) {
+			if ((REG32(RAWLANEN_DIG_AON_RX_ADAPT_DONE(port, lane))  & BIT(0)))
+				break;
+			udelay(10);
+		}
+		if (i >= PHY_RXADAPT_POLL_CNT)
+			LGM_NET_DBG("Port%d Lane%d RX Adaptation not done\n", port, lane);
+		else {
+			LGM_NET_DBG("Port%d Lane%d RX Adaptation done\n", port, lane);
+		}	
+		
+		//Stop RX Adaptation
+		REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) &= ~(0x3 << 4); //Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5
+		LGM_NET_DBG("RX Adaptation Turn off after done:\n RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2 (0x%08x) = 0x%08x\n", 
+			(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)), REG32(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2(port, lane)) );		
+		
+		//Display RX Adapt Value in PMA
+		LGM_NET_DBG("\nRead back on RX Adapted Value\n");
+		//LANEN_DIG_RX_ADPTCTL_ATT_STATUS ATT Adaptation code
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_ATT_STATUS [ (0x%08x) = 0x%08x\n", 
+			(LANEN_DIG_RX_ADPTCTL_ATT_STATUS(port, lane)), REG32(LANEN_DIG_RX_ADPTCTL_ATT_STATUS(port, lane)) );	
+		
+		//LANEN_DIG_RX_ADPTCTL_VGA_STATUS VGA Adaptation code
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_VGA_STATUS [ (0x%08x) = 0x%08x\n",		
+			(LANEN_DIG_RX_ADPTCTL_VGA_STATUS(port, lane)), REG32(LANEN_DIG_RX_ADPTCTL_VGA_STATUS(port, lane)) );		
+		
+		//LANEN_DIG_RX_ADPTCTL_CTLE_STATUS CTLE Adaptation code	
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_CTLE_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_CTLE_STATUS(port, lane)), REG32(LANEN_DIG_RX_ADPTCTL_CTLE_STATUS(port, lane)) );	
+		
+		//LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS DFE Tap1 Adaptation code		
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS [ (0x%08x) = 0x%08x\n",	
+			(LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS(port, lane)), REG32(LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS(port, lane)) );		
+		mdelay(1);
+		LGM_NET_DBG("\n RX value after Adaptation:\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_0 (0x%08x) = 0x%08x\nBIT15:11 EQ_CTLE_BOOST\nBIT10:7 EQ_VGA2_GAIN\nBIT6:3 EQ_VGA1_GAIN\nBIT2:0 EQ_ATT_LVL\n", 
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(port, lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0(port, lane)));
+		LGM_NET_DBG("\n LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1 (0x%08x) = 0x%08x\nBIT10:3 EQ_DFE_TAP1\nBIT2:0 EQ_CTLE_POLE\n", 
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(port, lane)), REG32(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1(port, lane)));	
+	}
+	else{
+		rd_data = ct_serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane));
+		rd_data &= ~(0x7 << 0); //Clear BITS 2:0
+		ct_serdes_cr_write(port, LANEN_DIG_ASIC_LANE_OVRD_IN_OFFSET(lane), rd_data);
+
+		LGM_NET_DBG("\nRX value before Adaptation:\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_0 (0x%08x) = 0x%08x\nBIT15:11 EQ_CTLE_BOOST\nBIT10:7 EQ_VGA2_GAIN\nBIT6:3 EQ_VGA1_GAIN\nBIT2:0 EQ_ATT_LVL\n", 
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane)), ct_serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane)));
+		LGM_NET_DBG("\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_1 (0x%08x) = 0x%08x\nBIT10:3 EQ_DFE_TAP1\nBIT2:0 EQ_CTLE_POLE\n", 
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(lane)), ct_serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(lane)));
+		
+		//RAWLANEN_DIG_PCS_XF_RX_OVRD_IN_3
+		/* 	15		CONT_OVRD_EN = 0
+			14		OFFCAN_CONT = 0
+			13		ADAPT_CONT = 0
+			12		ADAPT_REQ_OVRD_EN = 0
+			11		ADAPT_REQ = 0
+			10		REF_LD_VAL_OVRD_EN = 0
+			9:4		REF_LD_VAL_OVRD = 0
+			3		RX_LOS_THRSHLD_OVRD_EN = 0
+			2:0		RX_LOS_THRSHLD_OVRD_VAL = 0
+		*/
+		rd_data = ct_serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane));
+		rd_data &= ~(0x3 << 4); //Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5
+		rd_data |= 0x3 << 4; //ADAPT_REQ and ADAPT_REQ_OVRD_EN set to '11'
+		ct_serdes_cr_write(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane), rd_data);
+		LGM_NET_DBG("\nRequest for RX Adaptation to start:\n RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2 (0x%08x) = 0x%08x\n", 
+			(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane)), ct_serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane)));	
+		
+		//Check for RX Adaptation is done RAWLANEN_DIG_AON_RX_ADAPT_DONE.RX_ADAPT_DONE[0]
+		for (i = 0; i < PHY_RXADAPT_POLL_CNT; i++) {
+			if ((ct_serdes_cr_read(port, RAWLANEN_DIG_AON_RX_ADAPT_DONE_OFFSET(lane)))  & BIT(0))
+				break;
+			udelay(10);
+		}
+		if (i >= PHY_RXADAPT_POLL_CNT)
+			LGM_NET_DBG("Port%d Lane%d RX Adaptation not done\n", port, lane);
+		else {
+			LGM_NET_DBG("Port%d Lane%d RX Adaptation done\n", port, lane);
+		}	
+		
+		//Stop RX Adaptation
+		rd_data = ct_serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane));
+		rd_data &= ~(0x3 << 4); //Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5
+		ct_serdes_cr_write(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane), rd_data); //Clear ADAPT_REQ Bit 4 and ADAPT_REQ_OVRD_EN Bit 5
+		LGM_NET_DBG("RX Adaptation Turn off after done:\n RAWLANEN_DIG_PCS_XF_RX_OVRD_IN_3 (0x%08x) = 0x%08x\n", 
+			(RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane)), ct_serdes_cr_read(port, RAWLANEN_DIG_PCS_XF_ATE_OVRD_IN_2_OFFSET(lane)));		
+		
+		//Display RX Adapt Value in PMA
+		LGM_NET_DBG("\nRead back on RX Adapted Value\n");
+		//LANEN_DIG_RX_ADPTCTL_ATT_STATUS ATT Adaptation code
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_ATT_STATUS [ (0x%08x) = 0x%08x\n", 
+			(LANEN_DIG_RX_ADPTCTL_ATT_STATUS_OFFSET(lane)), ct_serdes_cr_read(port, LANEN_DIG_RX_ADPTCTL_ATT_STATUS_OFFSET(lane)));	
+		
+		//LANEN_DIG_RX_ADPTCTL_VGA_STATUS VGA Adaptation code
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_VGA_STATUS [ (0x%08x) = 0x%08x\n",		
+			(LANEN_DIG_RX_ADPTCTL_VGA_STATUS_OFFSET(lane)), ct_serdes_cr_read(port, LANEN_DIG_RX_ADPTCTL_VGA_STATUS_OFFSET(lane)));		
+		
+		//LANEN_DIG_RX_ADPTCTL_CTLE_STATUS CTLE Adaptation code	
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_CTLE_STATUS [ (0x%08x) = 0x%08x\n",
+			(LANEN_DIG_RX_ADPTCTL_CTLE_STATUS_OFFSET(lane)), ct_serdes_cr_read(port, LANEN_DIG_RX_ADPTCTL_CTLE_STATUS_OFFSET(lane)));
+		
+		//LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS DFE Tap1 Adaptation code		
+		LGM_NET_DBG("LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS [ (0x%08x) = 0x%08x\n",	
+			(LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS_OFFSET(lane)), ct_serdes_cr_read(port, LANEN_DIG_RX_ADPTCTL_DFE_TAP1_STATUS_OFFSET(lane)));			
+		mdelay(1);
+		LGM_NET_DBG("\n RX value after Adaptation:\nLANEN_DIG_ASIC_RX_EQ_ASIC_IN_0 (0x%08x) = 0x%08x\nBIT15:11 EQ_CTLE_BOOST\nBIT10:7 EQ_VGA2_GAIN\nBIT6:3 EQ_VGA1_GAIN\nBIT2:0 EQ_ATT_LVL\n", 
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane)), ct_serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_0_OFFSET(lane)));
+		LGM_NET_DBG("\n LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1 (0x%08x) = 0x%08x\nBIT10:3 EQ_DFE_TAP1\nBIT2:0 EQ_CTLE_POLE\n", 
+			(LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(lane)), ct_serdes_cr_read(port, LANEN_DIG_ASIC_RX_EQ_ASIC_IN_1_OFFSET(lane)));		
+	}
+}
+
+int combophy_hsio_c10phy_init(LGMC_SGMII_CONNECTION_SEL_t SGMII_CONNECTION)
+{
+	dprint_enable = 0; //Default disable debug print.
+	ref_use_pad = 0; //Default using internal PLL
+	pass_flag = 0; //Default is set to FAIL. '1' is success.
+	pma_type = 11; //Default 11 10GBASE-KR PMA or PMD type.
+	pon_eth_sel = 0; //Default '0' for PON and '1' is Ethernet.
+	auto_10g_enable = 0; //Default '0' disable, '1' enable.
+	autoneg_2p5g = 0; //Default '0' disable (2500BASE-X), '1' (2.5G SGMII ANEG mode) enable. To enable/disable 2.5G SGMII autoneg
+	autoneg_1g = 0; //Default '0' disable (1000BASE-X), '1' (1G SGMII ANEG mode) enable. To enable/disable 1G SGMII autoneg
+
+
+	int an_37_p0 = 0;
+	int tx_preset_id_p0 = 0;
+	//int tx_preset_id_p1 = 0;
+	//int rx_preset_id_p0 = 0, rx_preset_id_p1 = 0; 
+	int mpll_cfg_x2_xpcs_port=XPCS1;
+	u32 BASE_ADDR;
+	u32 read_data;
+	u32 cl37_link_timer_1g 		= 0x0; 
+	//u32 cl37_link_timer_2p5g 	= 0x7A1;
+	u32 cl37_link_timer_p0		= 0x0;
+	//u32 cl37_link_timer_p1		= 0x0;
+	//u32 cl37_usx_link_timer 	= 0x100;    //0.42ms CL37 Link Timer
+	//u32 cl73_break_link_timer 	= 0xA6;	//Setting CL73 Break Link Timer to ~70ms = 0xA6  (BIT[27:16] = 0xA6)
+	//u32 cl73_autoneg_link_timer = 0x95; 	//Setting CL73 Autoneg Link Timer to ~40ms = 0x95  (BIT[27:16] = 0x95)	 
+	read_data = 0;
+
+
+	int p0_id = COMBO_PORT30;
+	int p0_spd = SGMII_1G;
+
+	if (SGMII_CONNECTION == HSIO2_XPCS1_HSIO4_PHY0_C10) {
+		LGM_NET_DBG("HSIOR, HSIO2_XPCS1_HSIO4_PHY0_C10\n");
+		HSIO_TOP_BASE = 		HSIOR_TOP_BASE;
+		HSIO_RCU_RST_REQ = 	RCU_RST_REQ_HSIOR;
+		PAIR_CM1PHY0_CR = 	HSIO2_CB2PHY0_CR;
+		PAIR_CM1PHY0_APP = 	HSIO2_CB2PHY0_APP;
+		PAIR_CM1PHY1_CR = 	HSIO2_CB2PHY1_CR;
+		PAIR_CM1PHY1_APP = 	HSIO2_CB2PHY1_APP;
+		PAIR_CM2PHY0_CR = 	HSIO4_CB3PHY0_CR;
+		PAIR_CM2PHY0_APP = 	HSIO4_CB3PHY0_APP;
+		PAIR_CM2PHY1_CR = 	HSIO4_CB3PHY1_CR;
+		PAIR_CM2PHY1_APP = 	HSIO4_CB3PHY1_APP;
+
+		HSIO_XPCS1 = 			XPCS3;
+		}
+	else {
+		LGM_NET_DBG("HSIOL, HSIO1_XPCS1_HSIO3_PHY0_C10\n");
+		HSIO_TOP_BASE = 		HSIOL_TOP_BASE;
+		HSIO_RCU_RST_REQ = 	RCU_RST_REQ_HSIOL;
+		PAIR_CM1PHY0_CR = 	HSIO1_CB0PHY0_CR;
+		PAIR_CM1PHY0_APP = 	HSIO1_CB0PHY0_APP;
+		PAIR_CM1PHY1_CR = 	HSIO1_CB0PHY1_CR;
+		PAIR_CM1PHY1_APP = 	HSIO1_CB0PHY1_APP;
+		PAIR_CM2PHY0_CR = 	HSIO3_CB1PHY0_CR;
+		PAIR_CM2PHY0_APP = 	HSIO3_CB1PHY0_APP;
+		PAIR_CM2PHY1_CR = 	HSIO3_CB1PHY1_CR;
+		PAIR_CM2PHY1_APP = 	HSIO3_CB1PHY1_APP;
+	
+		HSIO_XPCS1 = 			XPCS1;
+		}
+
+	LGM_NET_DBG("p0_id =0x%x \n",p0_id);
+	LGM_NET_DBG("p0_spd =0x%x \n",p0_spd );
+
+
+/****************************added to configure for Single SGMII mode for both COMBO_PORT30 or COMBO_PORT40 (COMBOPHY_MODE register) **************/
+	if(p0_id == COMBO_PORT30){
+		
+		combo_global_init(p0_id);
+
+		mpll_cfg_x2_xpcs_port=XPCS1; // For serdes30
+		combo_global_init(mpll_cfg_x2_xpcs_port);
+	
+		// Set Gen3 combophy mode for serdes30 C10phy to Single SGMII 
+		BASE_ADDR = HSIOL_TOP_BASE + GEN3_COMBOPHY_MODE;
+		SET_X_BITS(REG32(BASE_ADDR), GEN3_COMBOPHY_MODE_POS, GEN3_COMBOPHY_MODE_WIDTH, 2);
+		LGM_NET_DBG("HSIOL_TOP.GEN3_COMBOPHY_MODE BIT2:0 REG32(0x%08x) = 0x%08x\n",			
+			BASE_ADDR, GET_X_BITS(REG32(BASE_ADDR), GEN3_COMBOPHY_MODE_POS, GEN3_COMBOPHY_MODE_WIDTH));
+	}else if(p0_id == COMBO_PORT40){
+		
+		combo_global_init(p0_id);
+
+		mpll_cfg_x2_xpcs_port=XPCS3; // For serdes40
+
+		// Set Gen3 combophy mode for serdes40 C10phy to Single SGMII 
+		BASE_ADDR = HSIOR_TOP_BASE + GEN3_COMBOPHY_MODE;
+		SET_X_BITS(REG32(BASE_ADDR), GEN3_COMBOPHY_MODE_POS, GEN3_COMBOPHY_MODE_WIDTH, 2);
+		LGM_NET_DBG("HSIOR_TOP.GEN3_COMBOPHY_MODE BIT2:0 REG32(0x%08x) = 0x%08x\n",			
+			BASE_ADDR, GET_X_BITS(REG32(BASE_ADDR), GEN3_COMBOPHY_MODE_POS, GEN3_COMBOPHY_MODE_WIDTH));		
+	}
+
+	// Set combophy mode for e16phy to dual PCIe with single lane
+	if(p0_id == COMBO_PORT30){
+		BASE_ADDR = HSIOL_TOP_BASE + ETHSATA_COMBOPHY_MODE;
+		SET_X_BITS(REG32(BASE_ADDR), ETHSATA_COMBOPHY_MODE_POS, ETHSATA_COMBOPHY_MODE_WIDTH, 0);
+		LGM_NET_DBG("HSIOL_TOP.ETHSATA_COMBOPHY_MODE BIT2:0 REG32(0x%08x) = 0x%08x\n", 			
+			BASE_ADDR, GET_X_BITS(REG32(BASE_ADDR), ETHSATA_COMBOPHY_MODE_POS, ETHSATA_COMBOPHY_MODE_WIDTH));
+	}else if(p0_id == COMBO_PORT40){
+		BASE_ADDR = HSIOR_TOP_BASE + ETHSATA_COMBOPHY_MODE;
+		SET_X_BITS(REG32(BASE_ADDR), ETHSATA_COMBOPHY_MODE_POS, ETHSATA_COMBOPHY_MODE_WIDTH, 0);
+		LGM_NET_DBG("HSIOR_TOP.ETHSATA_COMBOPHY_MODE BIT2:0 REG32(0x%08x) = 0x%08x\n", 			
+			BASE_ADDR, GET_X_BITS(REG32(BASE_ADDR), ETHSATA_COMBOPHY_MODE_POS, ETHSATA_COMBOPHY_MODE_WIDTH));		
+	}
+
+	// Configure LJPLL3 to 156.25Mhz+15ppm or 156.25Mhz
+	if(refclk_mode == 0){
+		ct_ljpll3_cfg_frac_eth(); //156.25Mhz+15ppm
+	}else if(refclk_mode == 1){
+	//	ljpll3_cfg_integ_eth(); //156.25Mh
+	}
+
+	mdelay(1);
+
+	// Enable all combo clocks
+	if(p0_spd != 0)
+		ct_hsiotop_clk_gate_cfg(p0_id, 0); //1 means disable glock gate.
+		
+/****************** added to assert and de-assert COMBO_PORT30/40 Cphy_rst_n, xpcs1_rstn, phy_rstn and put pcie controller in reset********************/
+
+	//Assert RESET of COMBOPHY, c10phy, XPCS1 and pcie controller
+	ct_combophy_rst_assert(p0_id);
+	//eth_phy_rst_assert(p0_id);
+	ct_xpcs_rst_assert(p0_id);	
+	ct_pcie_controller_rst_assert(p0_id);
+	mdelay(20);
+
+	if(p0_id == COMBO_PORT30){
+		LGM_NET_DBG("Reset of COMBOPHY, PHY, XPCS and pcie controller Asserted[WR] addr %x val %x\n", RCU_RST_REQ_HSIOL, REG32(RCU_MODULE_BASE+RST_REQ_HSIOL));  // set bits 2, 3, 8, 13, 17, 18 
+	}else if(p0_id == COMBO_PORT40){
+		LGM_NET_DBG("Reset of COMBOPHY, PHY, XPCS and pcie controller Asserted[WR] addr %x val %x\n", RCU_RST_REQ_HSIOR, REG32(RCU_MODULE_BASE+RST_REQ_HSIOR));	 // set bits 2, 3, 8, 13, 17, 18 
+	}
+	//De-assert RESET of COMBOPHY, c10phy, XPCS1 except for pcie controller
+	ct_combophy_rst_deassert(p0_id);
+	//eth_phy_rst_deassert(p0_id);
+	ct_xpcs_rst_deassert(p0_id);
+
+	if(p0_id == COMBO_PORT30){
+		LGM_NET_DBG("Reset of COMBOPHY, PHY, XPCS De-asserted[WR] addr %x val %x\n", RCU_RST_REQ_HSIOL, REG32(RCU_MODULE_BASE+RST_REQ_HSIOL));  // clear bits 8, 13, 17, 18 
+	}else if(p0_id == COMBO_PORT40){
+		LGM_NET_DBG("Reset of COMBOPHY, PHY, XPCS De-asserted[WR] addr %x val %x\n", RCU_RST_REQ_HSIOR, REG32(RCU_MODULE_BASE+RST_REQ_HSIOR));	 // clear bits 8, 13, 17, 18 
+	}
+	
+	mdelay(100);
+
+	//check for rst_status to ensure reset is clear
+#if 1
+	#define RST_STAT_CHK_CNT 5000
+	//u32 val;
+	int i;
+	for (i = 0; i < RST_STAT_CHK_CNT; i++) {
+		if (ct_combophy_rst_stat(p0_id) !=1 )
+		//if ((ct_combophy_rst_stat(p0_id) !=1))
+		{
+			LGM_NET_DBG("COMBOPHY resets deasserted\n");
+			break;
+		}
+		udelay(10);
+	}	
+
+	if(i > RST_STAT_CHK_CNT){
+		LGM_NET_DBG("COMBOPHY resets failed to de-assert");
+	}
+
+	for (i = 0; i < RST_STAT_CHK_CNT; i++) {
+		if (ct_xpcs_rst_stat(p0_id) != 1 )
+		//if ((ct_xpcs_rst_stat(p0_id) != 1))
+		{
+			LGM_NET_DBG("XPCS resets deasserted\n");
+			break;
+		}
+		udelay(10);
+	}	
+	
+	if(i > RST_STAT_CHK_CNT){
+		LGM_NET_DBG("XPCS resets failed to de-assert");
+	}
+
+#endif
+
+	//Add SRAM init check and Set LD_DONE before pooling for VR_RST clear.
+	//sram_init_chk(p0_id);
+	LGM_NET_DBG("**************[RD]SRAM CSR addr val %x*********************\n",  REG32(0xc0c40008));	
+
+/// commented: only needed if configuring cphy_mode combo1 (COMBO_PORT1x and COMBO_PORT2x) to ethernet mixed mode 13
+#if 0   
+	//Configure MPLL is always configured from XPCS0 regardless of pcs0 mode.
+	combophy_xpcs_master_en_cfg(p0_id, 1); //Setting XPCS_MASTER_EN = 1
+	combophy_xpcs_master_sel_cfg(p0_id, 0); //Setting XPCS_MASTER_SEL = 0 where all the MPLLA and MPLLB will come from XPCS0
+
+	//Enable SRAM_BYPASS - Not applicable for XPCS mode
+	//combophy_sram_bypass_cfg(p0_id, 1); //1 means enable SRAM Bypass to use internal FW.
+	//combophy_sram_bypass_cfg(p1_id, 1); //1 means enable SRAM Bypass to use internal FW.
+
+
+/************************* added for configuring cphy_mode combo2 (COMBO_PORT30 and COMBO_PORT40)******************************/
+
+	if(p0_id == COMBO_PORT30){
+		BASE_ADDR = COMBO_HSIOL_PHY10_APP_BASE + XPCS_CTRL_LOCAL;
+		SET_X_BITS(REG32(BASE_ADDR), XPCS_MASTER_EN_POS, XPCS_MASTER_EN_WIDTH, 1);
+		SET_X_BITS(REG32(BASE_ADDR), XPCS_MASTER_SEL_POS, XPCS_MASTER_SEL_WIDTH, 0);
+		LGM_NET_DBG("HSIOL_TOP.XPCS_CTRL_LOCAL BIT1:0 REG32(0x%08x) = 0x%08x\n",	BASE_ADDR, REG32(BASE_ADDR));
+	}else if(p0_id == COMBO_PORT40){
+		BASE_ADDR = COMBO_HSIOR_PHY20_APP_BASE + XPCS_CTRL_LOCAL;
+		SET_X_BITS(REG32(BASE_ADDR), XPCS_MASTER_EN_POS, XPCS_MASTER_EN_WIDTH, 1);
+		SET_X_BITS(REG32(BASE_ADDR), XPCS_MASTER_SEL_POS, XPCS_MASTER_SEL_WIDTH, 0);
+		LGM_NET_DBG("HSIOR_TOP.XPCS_CTRL_LOCAL BIT1:0 REG32(0x%08x) = 0x%08x\n",	BASE_ADDR, REG32(BASE_ADDR));
+	}
+#endif
+
+//	debugmsg = 0;
+
+//	REG32(0xd0a40130) = 0x1;
+//	LGM_NET_DBG("XPCS_CTRL %x val %x\n", 0xd0a40130, REG32(0xd0a40130));  
+
+
+	// Bypassing power up sequence
+	//writing to VR_PMA_DIG_CTRL1 register for BYP_PWRUP BIT1
+	LGM_NET_DBG("\nwriting to VR_PMA_DIG_CTRL1 register for BYP_PWRUP BIT1\n");
+	indirect_pcs_rd(VR_PMA_DIG_CTRL1,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[RD]VR_PMA_DIG_CTRL1 BYP_PWRUP BIT1 = 0x%08x\n", read_data); 	
+	
+	// DWC_xpcs bypasses the normal flow of the power-up sequence and reaches the Power_Good state to enable transmission or reception when BYP_PWRUP = 1h
+	read_data |=  (0x1 << 1);	 // BIT1 BYP_PWRUP 		= 1h
+
+	indirect_pcs_wr(VR_PMA_DIG_CTRL1,read_data,mpll_cfg_x2_xpcs_port);
+	indirect_pcs_rd(VR_PMA_DIG_CTRL1,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[WR]VR_PMA_DIG_CTRL1 BYP_PWRUP BIT1  = 0x%08x\n", read_data); 	
+
+	// DWC_xpcs initiates the reset for all the internal blocks except the Management Interface block and the CSR block when VR_RST = 1h (phy will be reset)
+	//vr_reset_poll(p0_id);
+	
+	ct_vr_reset_poll(mpll_cfg_x2_xpcs_port);
+
+	//writing to VR_PMA_DIG_CTRL1 register for BYP_PWRUP BIT1
+	LGM_NET_DBG("\nwriting to VR_PMA_DIG_CTRL1 register for BYP_PWRUP BIT1\n");
+	indirect_pcs_rd(VR_PMA_DIG_CTRL1,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[RD]VR_PMA_DIG_CTRL1 BYP_PWRUP BIT1 = 0x%08x\n", read_data);	
+	
+	// DWC_xpcs waits for the MPLL,Tx, or Rx PLL status from the Synopsys PHY before resuming the normal transmission and reception when BYP_PWRUP = 0h
+	read_data &= ~(0x1<<1); 	 // clear BIT1 BYP_PWRUP		= 0h
+
+	indirect_pcs_wr(VR_PMA_DIG_CTRL1,read_data,mpll_cfg_x2_xpcs_port);
+	indirect_pcs_rd(VR_PMA_DIG_CTRL1,mpll_cfg_x2_xpcs_port);
+	LGM_NET_DBG("[WR]VR_PMA_DIG_CTRL1 BYP_PWRUP BIT1 = 0x%08x\n", read_data); 	
+
+//	debugmsg = 0;
+
+	//############  Bring Up XPCS and Serdes  ###############################
+	//Configure Port0 (Master) without doing VR reset to Port1 (Slave)
+	if(p0_spd == SGMII_2P5G || p0_spd == SGMII_2500BASEX){
+#if 0
+//wyl.rm
+		pma_type = PMA_TYPE_1G_BASE_KX;
+		tx_preset_id_p0 = TX_2P5G_CUSTOM;
+		//rx_preset_id_p0 = RX_2P5G;				
+		if(p0_spd == SGMII_2500BASEX)
+			an_37_p0 = 0;
+			//autoneg_2p5g = 0;
+		else if(p0_spd == SGMII_2P5G){
+			an_37_p0 = 1;
+			cl37_link_timer_p0 = cl37_link_timer_2p5g;
+			//autoneg_2p5g = 1;	
+		}	
+		//an_37_p0 = autoneg_2p5g;
+		sgmii_2p5g_c10phy_bringup(mpll_cfg_x2_xpcs_port);  
+#endif
+	}else if(p0_spd == SGMII_1G || p0_spd == SGMII_1000BASEX){
+		pma_type = PMA_TYPE_1G_BASE_KX;
+		tx_preset_id_p0 = TX_1G_CUSTOM;
+		//rx_preset_id_p0 = RX_1G;			
+		if(p0_spd == SGMII_1000BASEX)
+			an_37_p0 = 0;
+			//autoneg_1g = 0;
+		else if(p0_spd == SGMII_1G){
+			an_37_p0 = 1;
+			cl37_link_timer_p0 = cl37_link_timer_1g;
+			//autoneg_1g = 1;		
+		}
+		//an_37_p0 = autoneg_1g;
+
+		LGM_NET_DBG("p0_spd =0x%x \n",p0_spd);
+		LGM_NET_DBG("pma_type =0x%x \n",pma_type );
+		LGM_NET_DBG("tx_preset_id_p0 =0x%x \n",tx_preset_id_p0 );
+		LGM_NET_DBG("an_37_p0 =0x%x \n",an_37_p0 );
+		LGM_NET_DBG("cl37_link_timer_p0 =0x%x \n",cl37_link_timer_p0 );
+
+		ct_base_1g_c10phy_bringup(mpll_cfg_x2_xpcs_port);	
+	}
+
+	//Do VR Reset for XPCS Master
+	ct_vr_reset(mpll_cfg_x2_xpcs_port);
+	
+	mdelay(15);
+
+	if(p0_id == COMBO_PORT30){
+		LGM_NET_DBG("**************SRAM CSR addr val %x*********************\n",  REG32(0xd0c40008));	
+		//Check SRAM Init
+		//sram_init_chk(p0_id);
+		while (!(REG32(0xd0c40008) & SRAM_INIT_DONE)){
+			udelay(1);
+			if (++i >= 1000)
+				break;
+		}
+	}if(p0_id == COMBO_PORT40){
+		LGM_NET_DBG("**************SRAM CSR addr val %x*********************\n",  REG32(0xc0c40008));	
+		//Check SRAM Init
+		//sram_init_chk(p0_id);
+		while (!(REG32(0xc0c40008) & SRAM_INIT_DONE)){
+			udelay(1);
+			if (++i >= 1000)
+				break;
+		}
+	}
+
+	/* Load done */
+	if(p0_id == COMBO_PORT30){
+		REG32(0xd0c40008) |= SRAM_LOAD_DONE;
+		LGM_NET_DBG("**************SRAM CSR addr val %x*********************\n",  REG32(0xd0c40008));	
+	}if(p0_id == COMBO_PORT40){
+		REG32(0xc0c40008) |= SRAM_LOAD_DONE;
+		LGM_NET_DBG("**************SRAM CSR addr val %x*********************\n",  REG32(0xc0c40008));
+	}
+	//Poll VR Reset Clear Bit and PHY Power Stable.
+
+	ct_vr_reset_poll(mpll_cfg_x2_xpcs_port);
+	ct_check_rxtx_stable(mpll_cfg_x2_xpcs_port);
+
+	//Configure TX EQ after VR Reset
+	struct tx_eq *txeq_p0 = &tx_presets[tx_preset_id_p0];
+	//struct tx_eq *txeq_p1 = &tx_presets[tx_preset_id_p1];
+
+	ct_tx_eq_config(mpll_cfg_x2_xpcs_port, txeq_p0);
+
+	//Workaround set TX_CLK_RDY_0 BIT12 to 0x1
+	 LGM_NET_DBG("\nWriting to VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 register for TX_CLK_RDY_0 BIT12 \n");
+	 indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,mpll_cfg_x2_xpcs_port); 
+	 LGM_NET_DBG("[RD]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 Set TX_CLK_RDY_0[12] = 0x%08x\n", read_data);
+	 //read_data &= 0xFFFFEFFF; //TX_CLK_RDY_0 BIT12 = 0
+	 read_data |= 0x1 <<12; //TX_CLK_RDY_0 BIT12 = 1
+	 indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,read_data,mpll_cfg_x2_xpcs_port);	
+	 indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1,mpll_cfg_x2_xpcs_port); 
+	 LGM_NET_DBG("[WR]VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1 Set TX_CLK_RDY_0[12] = 0x%08x\n", read_data);
+	 
+	//Only for Step-B to enable XGMII clock from XPCS to XGMAC
+	LGM_NET_DBG("\n\n 1 means enable xgmii glock gate, p0_spd =0x%x \n\n", p0_spd);
+	if(p0_spd != 0)
+		ct_hsiotop_xgmiiclk_gate_cfg(mpll_cfg_x2_xpcs_port, 1); //1 means enable xgmii glock gate.
+
+	//Disable CL73 or CL37 AN if not required as after VR Reset this will be enable.
+	//Configuring AUTONEG for CL73 and CL37 of 2.5G,1G
+
+	//Port0 2.5G & 1G
+
+	LGM_NET_DBG("an_37_p0 =0x%x \n", an_37_p0);
+	if(an_37_p0 == 0)
+		ct_disable_an_37(mpll_cfg_x2_xpcs_port);
+	if(an_37_p0 == 1)
+		ct_cl37_autoneg(mpll_cfg_x2_xpcs_port,cl37_link_timer_p0);
+
+	//READ MPLLA/B state
+	//read_mpll_state(mpll_cfg_x2_xpcs_port);
+	//read_mpll_state(p0_id);	
+
+	#define MPLLB_STATE	BIT(14)
+	mdelay(100);
+
+	if(p0_id == COMBO_PORT30)
+		read_data = REG32(0xd0c00064);
+	else if(p0_id == COMBO_PORT40)
+		read_data = REG32(0xc0c00064);
+	
+	LGM_NET_DBG("SUP_DIG_ASIC_IN 0x%08x MPLLB_STATE %s\n",
+		read_data, (read_data & MPLLB_STATE)? "set": "clr");
+	
+	//Enable RX auto adapt
+	//ct_phy_rxeq_autoadapt(mpll_cfg_x2_xpcs_port, LANE0);
+	//phy_rxeq_autoadapt(p0_id, LANE0);
+	//phy_rxeq_autoadapt(p0_id, LANE1); //Cannot use CR Base Address for Lane 1 as it does not connect to the PHY LANE1. Instead use PHY0 base addr LANE1.
+	xpcs_initialized[mpll_cfg_x2_xpcs_port] = 1;
+
+	return 0;
+}
+#endif
+
+int combophy_hsio_init(int phy)
+{
+	int ret;
+	int p0_id;
+	int p1_id;
+	int p0_spd = 0;
+	int p1_spd = 0;
+	struct combo_port *paddr = &g_combo_port_defs[0];
+
+	if (phy == HSIO_R) {
+		p0_id = COMBO_PORT20;
+		p1_id = COMBO_PORT21;
+#ifdef CONFIG_LAN_HSIO_R_XFI_10G_KR_NO_ANEG
+#ifdef CONFIG_LAN_HSIO_R_USXGMII_10G
+		printf("HSIO-R USXGMII_10G \n");
+#else
+		printf("HSIO-R XFI_10G_KR_NO_ANEG \n");
+#endif
+		p0_spd = XFI_10G_KR_NO_ANEG;
+		p1_spd = XFI_10G_KR_NO_ANEG;
+#elif  CONFIG_LAN_HSIO_R_SGMII_1G
+		printf("LAN1 HSIO-R SGMII_1G autoneg \n");
+		p0_spd = SGMII_1G;
+		p1_spd = SGMII_1G;
+#elif  CONFIG_LAN_HSIO_R_SGMII_2500BASEX
+		printf("LAN HSIO-R SGMII_2500BASEX, autoneg disabled. only link & flow control enabled. \n");
+		p0_spd = SGMII_2500BASEX;
+		p1_spd = SGMII_2500BASEX;
+#endif
+		enable_xpcs_clk(HSIOR_TOP_BASE);
+	} else {
+		p0_id = COMBO_PORT10;
+		p1_id = COMBO_PORT11;
+#ifdef CONFIG_LAN_HSIO_L_XFI_10G_KR_NO_ANEG
+		printf("LAN0 HSIO-L XFI_10G_KR_NO_ANEG \n");
+		p0_spd = XFI_10G_KR_NO_ANEG;
+		p1_spd = XFI_10G_KR_NO_ANEG;
+#elif  CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET
+		printf("LAN HSIO-L SGMII_2500BASEX, autoneg disabled. only link & flow control enabled. \n");
+		p0_spd = SGMII_2500BASEX;
+		p1_spd = SGMII_2500BASEX;
+#endif
+		enable_xpcs_clk(HSIOL_TOP_BASE);
+	}
+
+	init_combo_base(&paddr[p0_id], p0_id);
+	init_combo_base(&paddr[p1_id], p1_id);
+
+	/* remove this at the moment, kernel cannot seem to
+	 * re-init after u-boot reconfigs the ljpll3 */
+	/*ljpll3_cfg_frac_eth(); */
+
+	hsiotop_clk_gate_cfg(p0_id, 0);
+	hsiotop_clk_gate_cfg(p1_id, 0);
+
+	/* Only need to configure once for either PORT10 or PORT20 */
+	ret = combophy_mode(p0_id, DUAL_ETH);
+	if (ret)
+		return ret;
+
+	/* Assert RESET of COMBOPHY */
+	combophy_rst_assert(p0_id);
+	combophy_rst_assert(p1_id);
+
+	/* Assert reset on PHY 10/11 */
+	eth_phy_rst_assert(p0_id);
+	eth_phy_rst_assert(p1_id);
+
+	/* Asser reset on XPCS0/1 */
+	xpcs_rst_assert(p0_id);
+	xpcs_rst_assert(p1_id);
+
+	udelay(10);
+
+	/* De-assert WAN/COMBOPHY Subsystem Reset */
+	combophy_rst_deassert(p0_id);
+	combophy_rst_deassert(p1_id);
+
+	/* De-assert PHY0/1/2 Reset */
+	eth_phy_rst_deassert(p0_id);
+	eth_phy_rst_deassert(p1_id);
+
+	/* De-assert XPCS0/1/2 Reset */
+	xpcs_rst_deassert(p0_id);
+	xpcs_rst_deassert(p1_id);
+	mdelay(100);
+
+	ret = verify_reset_status(p0_id, p1_id);
+	if (ret)
+		return ret;
+
+	combophy_paraclk_div2_cfg(paddr, p0_id, 1); /*1 means enable clock. */
+	combophy_paraclk_div2_cfg(paddr, p1_id, 1); /*1 means enable clock. */
+
+	udelay(100);
+
+	/* Enable SRAM_BYPASS */
+	combophy_sram_bypass_cfg(paddr, p0_id, 1); /*1 means enable SRAM Bypass to use internal FW. */
+	combophy_sram_bypass_cfg(paddr, p1_id, 1); /*1 means enable SRAM Bypass to use internal FW. */
+
+	LGM_NET_DBG("SRAM Init for Port %d\n", p0_id);
+	ret = sram_init_chk(p0_id, 0);
+	if (ret)
+		return ret;
+
+	LGM_NET_DBG("SRAM Init for Port %d\n", p1_id);
+	ret = sram_init_chk(p1_id, 0);
+	if (ret)
+		return ret;
+
+#if defined(CONFIG_LAN_HSIO_R_SGMII_2500BASEX) || defined(CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET)
+	init_xpcs_sgmii_2500basex(p0_id, p1_id, p0_spd, p1_spd);
+#else
+	init_xpcs(p0_id, p1_id, p0_spd, p1_spd);
+#endif
+
+	/*READ MPLLA/B state */
+	read_mpll_state(p0_id);
+	/*read_mpll_state(p0_id); */
+
+	/*Enable RX auto adapt */
+	phy_rxeq_autoadapt(p0_id, LANE0);
+	phy_rxeq_autoadapt(p0_id, LANE1); /*Cannot use CR Base Address for  Lane 1 as it does not connect to the PHY LANE1. Instead use PHY0 base addr LANE1 */
+
+#if defined(CONFIG_LAN_HSIO_R_SGMII_2500BASEX) || defined(CONFIG_LAN_HSIO_L_SGMII_1G_2G5_AUTO_DET)
+	phy_rxeq_autoadapt(p1_id, LANE0);
+	phy_rxeq_autoadapt(p1_id, LANE1); /*Cannot use CR Base Address for  Lane 1 as it does not connect to the PHY LANE1. Instead use PHY0 base addr LANE1 */
+#endif
+
+#ifdef CONFIG_LAN_HSIO_R_USXGMII_10G
+	disable_xpcs_clk(HSIOR_TOP_BASE);
+	LGM_NET_DBG("SRAM Init for Port %d\n", p0_id);
+	ret = sram_init_chk(p0_id, 0);
+	if (ret)
+		return ret;
+
+	LGM_NET_DBG("SRAM Init for Port %d\n", p1_id);
+	check_rxtx_stable(p0_id);
+	set_mode_usxgmii(p0_id);
+	xpcs_disable_an(p0_id);
+	xpcs_cfg_clk(p0_id);
+	xpcs_cfg_table(p0_id);
+	xpcs_vs_reset(p0_id);
+	tx_eq_config_kernel(p0_id);
+	KR_workaround(p0_id);
+	xpcs_an(p0_id);
+	enable_xpcs_clk(HSIOR_TOP_BASE);
+#endif
+	return 0;
+}
+
+u32 XPCS_RGRD(u32 xpcs_prt, u32 reg)
+{
+	return indirect_pcs_rd(reg, xpcs_prt);
+}
+
+void XPCS_RGWR(u32 xpcs_prt, u32 reg, u32 reg_val)
+{
+	indirect_pcs_wr(reg, reg_val, xpcs_prt);
+}
+
+void XPCS_RGWR_VAL_OFF(u32 xpcs_prt, u32 reg, u32 bits_mask, u32 bits_pos, u32 bits_val, u32 regs_shift)
+{
+	indirect_pcs_rd(reg + regs_shift * 4, xpcs_prt);
+	read_data = (read_data & (~(bits_mask << (bits_pos))));
+	read_data |= bits_val << (bits_pos);
+	indirect_pcs_wr(reg + regs_shift * 4, (read_data), xpcs_prt);
+}
+
+void XPCS_RGWR_VAL_SHIFT(u32 xpcs_prt, u32 reg, u32 bits_mask, u32 bits_pos, u32 bits_val, u32 bits_shift)
+{
+	indirect_pcs_rd(reg, xpcs_prt);
+	read_data = (read_data & (~(bits_mask << (bits_pos + bits_shift))));
+	read_data |= bits_val << (bits_pos + bits_shift);
+	indirect_pcs_wr(reg, (read_data), xpcs_prt);
+}
+
+void XPCS_RGWR_VAL_OFF_SHIFT(u32 xpcs_prt, u32 reg, u32 bits_mask, u32 bits_pos, u32 bits_val, u32 regs_shift, u32 bits_shift)
+{
+	indirect_pcs_rd(reg + regs_shift * 4, xpcs_prt);
+	read_data = (read_data & (~(bits_mask << (bits_pos + bits_shift))));
+	read_data |= bits_val << (bits_pos + bits_shift);
+	indirect_pcs_wr(reg + regs_shift * 4, (read_data), xpcs_prt);
+}
+
+void xpcs_disable_an(int xpcs_prt)
+{
+/* clear bit12 of SR_AN_CTRL reg, AN_EN bit, Disable CL73 Autoneg */
+/* clear bit13 of SR_AN_CTRL reg, EXP_NP_CTL bit, Disable Next page */	
+	indirect_pcs_rd(SR_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(SR_AN_CTRL, (read_data & (~(3 << 12))), xpcs_prt);
+
+/* clear bit12 of VR_XS_PCS_DIG_CTRL1 reg, CL37_BP bit, Disable Backplane CL37 Autonegotiation */
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1, (read_data & (~(1 << 12))), xpcs_prt);
+
+/* clear bit12 of SR_MII_CTRL reg, AN_ENABLE bit, Disable CL37 Autoneg */
+	indirect_pcs_rd(SR_MII_CTRL, xpcs_prt);
+	indirect_pcs_wr(SR_MII_CTRL, (read_data & (~(1 << 12))), xpcs_prt);
+
+/* clear bit9 of VR_MII_DIG_CTRL1 reg, MAC_AUTO_SW bit, Disable Auto Speed Mode Change after CL37 AN */
+	indirect_pcs_rd(VR_MII_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_MII_DIG_CTRL1, (read_data & (~(1 << 9))), xpcs_prt);
+
+/* Reset MII Ctrl register */
+/* clear bit0   of VR_MII_AN_CTRL reg, MII_AN_INTR_EN bit, Disable Clause 37 AN Complete Interrupt Enable */
+/* clear bit1,2 of VR_MII_AN_CTRL reg, PCS_MODE bit, set 1000BASE-X mode (clause 37 auto-negotiation is as per 1000BaseX). */
+/* clear bit3   of VR_MII_AN_CTRL reg, TX_CONFIG bit, Configures the DWC_xpcs as the MAC side SGMII/QSGMII/USXGMII. */
+	indirect_pcs_rd(VR_MII_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_AN_CTRL, (read_data & (~(0xf << 0))), xpcs_prt);
+
+/* clear bit8 of VR_MII_AN_CTRL reg, MII_CONTROL bit, set 4-bit MII. */
+	indirect_pcs_rd(VR_MII_AN_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_MII_AN_CTRL, (read_data & (~(1 << 8))), xpcs_prt);
+}
+
+void set_mode_usxgmii(int xpcs_prt)
+{
+/* clear bit3:0 of SR_XS_PCS_CTRL2 reg, PCS_TYPE_SEL bit, 0000: Select 10GBASE-R PCS Type */	
+	indirect_pcs_rd(SR_XS_PCS_CTRL2, xpcs_prt);
+	indirect_pcs_wr(SR_XS_PCS_CTRL2, (read_data & (~(0xf << 0))), xpcs_prt);
+
+/*BIT9,USXG_EN*/
+	indirect_pcs_rd(VR_XS_PCS_DIG_CTRL1, xpcs_prt);
+	indirect_pcs_wr(VR_XS_PCS_DIG_CTRL1, (read_data | ((0x1 << 9))), xpcs_prt);
+
+/*BIT12:10,USXG_MODE, 000=10G-SXGMII*/
+	indirect_pcs_rd(VR_XS_PCS_KR_CTRL, xpcs_prt);
+	indirect_pcs_wr(VR_XS_PCS_KR_CTRL, (read_data & (~(0x7 << 10))), xpcs_prt);
+}
+
+#if defined(CONFIG_LAN_HSIO_R_USXGMII_10G ) || defined(CONFIG_WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G) || defined(CONFIG_XPCS5_USXGMII_RTL8261)
+static void xpcs_cfg_clk(int xpcs_prt)
+{
+	const struct xpcs_mode_cfg *mode_cfg = &mode_cfg_tbl[0];
+	const struct xpcs_serdes_cfg *lane_cfg = mode_cfg_tbl[0].lane_cfg;
+
+/*VR_XS_PMA_MP_12G_16G_25G_REF_CLK_CTRL, bit6 = REF_MPLLA_DIV2, bit7 = REF_MPLLB_DIV2*/
+	read_data = mode_cfg->ref_clk_ctrl | (1 << (MPLLB ? 7 : 6));
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_REF_CLK_CTRL, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_MP_12G_16G_MPLLA_CTRL0, bit7:0 = MPLLA_MULTIPLIER*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0, xpcs_prt);
+	read_data = (read_data & (~(0xff << 0))) | ((mode_cfg->mplla_mult) << 0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_MP_12G_16G_MPLLA_CTRL0, bit15 = MPLLA_CAL_DISABLE*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0, xpcs_prt);
+	read_data = (read_data & (~(1 << 15)));
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL0, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_MP_16G_MPLLA_CTRL3, bit15:0 = MPLLA_BANDWIDTH*/
+	read_data = mode_cfg->mplla_bw;
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_MPLLA_CTRL3, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_MP_12G_16G_MPLLA_CTRL2, 
+bit10 = MPLLA_DIV16P5_CLK_EN
+bit9 = MPLLA_DIV10_CLK_EN
+bit8 = MPLLA_DIV8_CLK_EN
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2, xpcs_prt);
+	read_data = (read_data & (~(0x7 << 8)));
+	read_data |= mode_cfg->mplla_div165_clk_en << 10;
+	read_data |= mode_cfg->mplla_div10_clk_en << 9;
+	read_data |= mode_cfg->mplla_div8_clk_en << 8;
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLLA_CTRL2, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_MP_12G_16G_25G_TX_GENCTRL1, bit4 = VBOOST_EN_0*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1, xpcs_prt);
+	read_data = (read_data & (~(0x1 << 4)));
+	read_data |= lane_cfg->tx_vboost_en << 4;
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_MP_12G_16G_25G_TX_GENCTRL1, bit10:8 = VBOOST_LVL*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1, xpcs_prt);
+	read_data = (read_data & (~(0x7 << 8)));
+	read_data |= lane_cfg->tx_vboost_lvl << 8;
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1, (read_data), xpcs_prt);
+}
+
+static void xpcs_cfg_table(int xpcs_prt)
+{
+	const struct xpcs_mode_cfg *mode_cfg = &mode_cfg_tbl[0];
+	const struct xpcs_serdes_cfg *lane_cfg = mode_cfg_tbl[0].lane_cfg;
+	u32 lane;
+	u32 boost_gain;
+
+/*VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL*/
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL, 0, xpcs_prt);
+
+/*VR_XS_PMA_GEN5_16G_VCO_CAL_REF0   */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0, 0, xpcs_prt);
+
+/*VR_XS_PMA_GEN5_16G_VCO_CAL_REF1   */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF1, 0, xpcs_prt);
+
+/*VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0  */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0, 0, xpcs_prt);
+
+/*VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3  */
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3, 0, xpcs_prt);
+
+	/* lane configuration */
+	for (lane = 0; lane < mode_cfg->lane; lane++) {
+		/* Select MPLLB for 10G-XAUI/10GBASE-KX4/2.5G-SGMII
+		 * When this bit is set, PHY selects MPLLB to generate
+		 * Tx analog clocks on lane 0
+		 */
+/*VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL, bit0:3 = MPLL_EN_0:3*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL, xpcs_prt);
+	read_data = (read_data & (~(0x1 << (0 + lane))));
+	read_data |= 0x1 << (0 + lane);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL, bit4:7 = MPLLB_SEL_0:3*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL, xpcs_prt);
+	read_data = (read_data & (~(0x1 << (4 + lane))));
+	read_data |= 0x0 << (4 + lane);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_MPLL_CMN_CTRL, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0, bit0:12 = VCO_LD_VAL_0*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0 + lane * 4, xpcs_prt);
+	read_data = (read_data & (~(0x1fff << (0))));
+	read_data |= mode_cfg->vco_ld_val << (0);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_VCO_CAL_LD0 + lane * 4, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_GEN5_16G_VCO_CAL_REF0, bit0:6 = VCO_REF_LD_0, bit8:14 = VCO_REF_LD_1*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0 + (lane / 2) * 4, xpcs_prt);
+	read_data = (read_data & (~(0x7f << (0 + (lane & 1) * 8))));
+	read_data |= mode_cfg->vco_ref_ld << (0 + (lane & 1) * 8);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_16G_VCO_CAL_REF0 + (lane / 2) * 4, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4, bit0:3 = CONT_ADAPT_0:3*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4, xpcs_prt);
+	read_data = (read_data & (~(0x1 << (0 + lane))));
+	read_data |= lane_cfg->cont_adapt << (0 + lane);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_EQ_CTRL4, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL, 
+bit2:0 = TX0_RATE
+bit6:4 = TX1_RATE
+bit10:8 = TX2_RATE
+bit14:12 = TX3_RATE
+*/
+	/* MPLL VCO 5G - 1G bit[2:0] = 3'b011 : baud/8 */
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL, xpcs_prt);
+	read_data = (read_data & (~(0x7 << (0 + lane * 4))));
+	read_data |= mode_cfg->tx_rate << (0 + lane * 4);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_TX_RATE_CTRL, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL, 
+bit1:0 = RX0_RATE
+bit5:4 = RX1_RATE
+bit9:8 = RX2_RATE
+bit13:12 = RX3_RATE
+*/
+	indirect_pcs_rd(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL, xpcs_prt);
+	read_data = (read_data & (~(0x3 << (0 + lane * 4))));
+	read_data |= mode_cfg->rx_rate << (0 + lane * 4);
+	indirect_pcs_wr(VR_XS_PMA_GEN5_12G_16G_RX_RATE_CTRL, (read_data), xpcs_prt);
+
+/*VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2, 
+bit9:8 = TX0_WIDTH
+bit11:10 = TX1_WIDTH
+bit13:12 = TX2_WIDTH
+bit15:14 = TX3_WIDTH
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL2, 0x3, 8,
+			      mode_cfg->tx_width, lane * 2);
+
+/*VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2, 
+bit9:8 = RX0_WIDTH
+bit11:10 = RX1_WIDTH
+bit13:12 = RX2_WIDTH
+bit15:14 = RX3_WIDTH
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL2, 0x3, 8,
+			      mode_cfg->rx_width, lane * 2);
+
+/*VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1, bit4:7 = VBOOST_EN_0:3*/
+		/* Tx Voltage Boost Maximum level,
+		 * maximum achievable Tx swing in the PHY
+		 */
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_TX_GENCTRL1, 0x1, 4,
+				    lane_cfg->tx_vboost_en, lane);
+
+/*VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL, 
+bit2:0 = RX0_EQ_ATT_LVL
+bit6:4 = RX1_EQ_ATT_LVL
+bit10:8 = RX2_EQ_ATT_LVL
+bit14:12 = RX3_EQ_ATT_LVL
+*/
+		/* PHY RX attenuation Level */
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_RX_ATTN_CTRL, 0x7, 0,
+				    lane_cfg->rx_attn_lvl, lane * 4);
+/*VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0, 
+bit2:0 = RX0_EQ_ATT_LVL
+bit6:4 = RX1_EQ_ATT_LVL
+bit10:8 = RX2_EQ_ATT_LVL
+bit14:12 = RX3_EQ_ATT_LVL
+*/
+		/* PHY ctle_pole and boost and gain register */
+		boost_gain = ((lane_cfg->rx_vga1_gain & 0x0F) << 12)
+			     | ((lane_cfg->rx_vga2_gain & 0x0F) << 8)
+			     | ((lane_cfg->rx_ctle_pole & 0x07) << 5)
+			     | (lane_cfg->rx_ctle_boost & 0x1F);
+		XPCS_RGWR(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_EQ_CTRL0 + lane * 4, boost_gain);
+/*VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0, 
+PMA_RX_PPM_CTRL0
+bit4:0 = RX0_CDR_PPM_MAX
+bit12:8 = RX1_CDR_PPM_MAX
+PMA_RX_PPM_CTRL1
+bit4:0 = RX2_CDR_PPM_MAX
+bit12:8 = RX3_CDR_PPM_MAX
+*/
+		XPCS_RGWR_VAL_OFF_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_PPM_CTRL0, 0x1f, 0,
+					mode_cfg->cdr_ppm_max, lane / 2,
+					(lane & 1) * 8);
+/*VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1, 
+bit0:3 = VCO_TEMP_COMP_EN_0:3
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1, 0x1, 0,
+				    mode_cfg->vco_temp_comp_en, lane);
+/*VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1, 
+bit4:7 = VCO_STEP_CTRL_0:3
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1, 0x1, 4,
+				    mode_cfg->vco_step_ctrl, lane);
+/*VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1, 
+bit9:8 = VCO_FRQBAND_0
+bit11:10 = VCO_FRQBAND_1
+bit13:12 = VCO_FRQBAND_2
+bit15:14 = VCO_FRQBAND_3
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_CDR_CTRL1, 0x3, 8,
+				    mode_cfg->vco_frqband, lane * 2);
+/*VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0, 
+PMA_RX_MISC_CTRL0
+bit7:0 = RX0_MISC
+bit15:8 = RX1_MISC
+PMA_RX_MISC_CTRL1
+bit7:0 = RX2_MISC
+bit15:8 = RX3_MISC
+*/
+		XPCS_RGWR_VAL_OFF_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_MISC_CTRL0, 0xff, 0,
+					mode_cfg->rx_misc, lane / 2,
+					(lane & 1) * 8);
+/*VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4, 
+bit8:11 = RX_DFE_BYP_0:3
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_GEN_CTRL4, 0x1, 8,
+				    lane_cfg->rx_dfe_bypass, lane);
+/*VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0, 
+PMA_DFE_TAP_CTRL0
+bit7:0 = DFE_TAP1_0
+bit15:8 = DFE_TAP1_1
+PMA_DFE_TAP_CTRL1
+bit7:0 = DFE_TAP1_2
+bit15:8 = DFE_TAP1_3
+*/
+		XPCS_RGWR_VAL_OFF_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_DFE_TAP_CTRL0, 0xff, 0,
+					mode_cfg->rx_dfe_tap1, lane / 2,
+					(lane & 1) * 8);
+/*VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0, 
+bit11:8 = RX0_DELTA_IQ
+*/
+		XPCS_RGWR_VAL_OFF(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0, 0xff, 8,
+					mode_cfg->rx_delta_iq, lane);
+/*VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0, 
+bit6:0 = RX0_MARGIN_IQ
+*/
+		XPCS_RGWR_VAL_OFF(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_IQ_CTRL0, 0x7f, 0,
+					mode_cfg->rx_margin_iq, lane);
+
+
+/*VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5, 
+bit0:3 = RX_ADPT_SEL_0:3
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5, 0x1, 0,
+				    mode_cfg->adpt_sel, lane);
+/*VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5, 
+bit5:4 = RX0_ADPT_MODE
+bit7:6 = RX1_ADPT_MODE
+bit9:8 = RX2_ADPT_MODE
+bit11:10 = RX3_ADPT_MODE
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_RX_EQ_CTRL5, 0x3, 4,
+				   mode_cfg->adpt_mode, lane * 2);
+
+/*VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3, 
+bit2:0 = LOS_TRSHLD_0
+bit5:3 = LOS_TRSHLD_1
+bit8:6 = LOS_TRSHLD_2
+bit11:9 = LOS_TRSHLD_3
+*/
+	/* PHY LOS threshold register */
+	XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_RX_GENCTRL3, 0x7, 0,
+	  mode_cfg->los_thr, lane * 3);
+	}
+
+/*
+#define VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0              0x060240
+bit12:8 = RX_VREF_CTRL
+*/
+	/* Rx Biasing Current Control for Rx analog front end */
+	XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_MISC_CTRL0, 0x1f, 8,
+	  mode_cfg->rx_vref_ctrl, 0);
+
+/*
+VR_XS_PMA_GEN5_16G_MISC_CTRL2
+bit7:0 = SUP_MISC
+*/
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_16G_MISC_CTRL2, 0xff, 0,
+				  1, 0);
+}
+
+
+static void tx_eq_config_kernel(u32 xpcs_prt)
+{
+	const struct xpcs_mode_cfg *mode_cfg = &mode_cfg_tbl[0];
+	const struct xpcs_serdes_cfg *lane_cfg = mode_cfg_tbl[0].lane_cfg;
+	u32 lane;
+
+/*#define VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0             0x0600D8
+bit5:0 = TX_EQ_PRE
+bit13:8 = TX_EQ_MAIN
+*/
+	XPCS_RGRD(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0);
+	read_data &= ~(0x3f | (0x3f << 8));
+	read_data |= lane_cfg->tx_eq_pre | (lane_cfg->tx_eq_main << 8);
+	XPCS_RGWR(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL0, read_data);
+/*
+#define VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1             0x0600DC
+bit5:0 = TX_EQ_POST
+bit6 = TX_EQ_OVR_RIDE
+*/
+	XPCS_RGRD(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1);
+	read_data &= ~(0x7f);
+	read_data |= lane_cfg->tx_eq_post | (lane_cfg->tx_eq_ovrride << 6);
+	XPCS_RGWR(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_TX_EQ_CTRL1, read_data);
+
+/*
+#define VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL           0x0600CC
+bit3:0 = TX0_IBOOST
+bit7:4 = TX1_IBOOST
+bit11:8 = TX2_IBOOST
+bit15:12 = TX3_IBOOST
+*/
+	for (lane = 0; lane < mode_cfg->lane; lane++) {
+		XPCS_RGWR_VAL_SHIFT(xpcs_prt, VR_XS_PMA_GEN5_12G_16G_TX_BOOST_CTRL, 0xf, 0,
+			      lane_cfg->tx_iboost_lvl, lane * 4);
+	}
+}
+#endif
diff --git a/drivers/net/mxl3710_aic.c b/drivers/net/mxl3710_aic.c
new file mode 100644
--- /dev/null
+++ b/drivers/net/mxl3710_aic.c
@@ -0,0 +1,190 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ *
+ * Copyright (C) 2023 Wang Yunliang <yunliangwang@maxlinear.com>
+ *
+ */
+#include <common.h>
+#include <errno.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <dm/device_compat.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <linux/bitops.h>
+#include <time.h>
+#include <linux/delay.h>
+#include <pi4ioe5v6408_gpio.h>
+
+
+struct udevice *i2c_expander_dev;
+extern u8 read_power_good(void);
+extern u8 output_value_set(u8 pos, u8 val);
+extern int init_i2c_dev(u32 i2c_bus, u32 i2c_addr, int alen);
+
+	/*
+	p7 out	MoCA Security
+	p6 in	power good
+	p5 out	led,1=on
+	p4 out	sel2, control HSIO20=a2/3
+	p3 out	sel1, control HSIO21=a0/1
+	p2 out	gsw140 reset
+	p1 out	moca reset
+	p0 out	10g rtl8261n reset
+	*/
+static int init_i2c_expander_io(void)
+{
+	/*
+	manufactor 1000
+	i2c addr:
+	0: 011
+	1: 100
+
+	pcie_A:addr pin = 0: 1000 011x = 0x43
+	pcie_B:addr pin = 1: 1000 100x = 0x44
+	*/
+	u32 i2c_bus = 3;
+	u32 i2c_addr = 0x44;
+	int alen = 1;
+
+	u8 test_val;
+
+	init_i2c_dev(i2c_bus, i2c_addr, alen);
+
+/*1=output, 0=input*/
+	i2c_expander_reg03h_io_dir_wr(0x3d);
+	i2c_expander_reg03h_io_dir_rd(&test_val);
+	//printf("i2c_expander_reg03h_io_dir_wr(0x3d)=0x%x \n", test_val);
+
+/*no impact on input pin, for output pin:1=high impedance, 0=follow output value*/
+	i2c_expander_reg07h_high_impedance_wr(0);
+	i2c_expander_reg07h_high_impedance_rd(&test_val);
+	//printf("i2c_expander_reg07h_high_impedance_wr(0);=0x%x \n", test_val);
+
+/*by default, set all output pin to 0, force all devices in reset status.*/
+	i2c_expander_reg05h_output_value_wr(0x25);
+	i2c_expander_reg05h_output_value_rd(&test_val);
+	//printf("i2c_expander_reg05h_output_value_wr(0x25);=0x%x \n", test_val);
+
+/*no impact on output pin, for input pin:1=default state is high, 0=default state is low*/
+	i2c_expander_reg09h_input_default_state_wr(0xff);
+	i2c_expander_reg09h_input_default_state_rd(&test_val);
+	//printf("i2c_expander_reg09h_input_default_state_wr(0xff);=0x%x \n", test_val);
+
+/*for all input/output pins, 1=enable pull up/down resistor, 0=disable*/
+	i2c_expander_reg0bh_pull_up_down_en_wr(0xff);
+	i2c_expander_reg0bh_pull_up_down_en_rd(&test_val);
+	//printf("i2c_expander_reg0bh_pull_up_down_en_wr(0xff);=0x%x \n", test_val);
+
+/*for all input/output pins, 1=sel pull up resistor, 0=sel pull down resistor*/
+	i2c_expander_reg0dh_pull_up_down_sel_wr(0xff);
+	i2c_expander_reg0dh_pull_up_down_sel_rd(&test_val);
+	//printf("i2c_expander_reg0dh_pull_up_down_sel_wr(0xff);=0x%x \n", test_val);
+
+/*no impact on output pin, for input pin:1=disable irq, 0=enable irq*/
+	i2c_expander_reg11h_irq_mask_val_wr(0xff);
+	i2c_expander_reg11h_irq_mask_val_rd(&test_val);
+	//printf("i2c_expander_reg11h_irq_mask_val_wr(0xff);=0x%x \n", test_val);
+
+/*read irq status bit to clear it which set by power on/software reset/hw reset.*/
+	//i2c_expander_reg01h_rst_int_status_rd();
+	//printf("i2c_expander_reg01h_rst_int_status_rd();=0x%x \n", i2c_expander_reg01h_rst_int_status_rd());
+	//printf("i2c_expander_reg01h_rst_int_status_rd();=0x%x \n", i2c_expander_reg01h_rst_int_status_rd());
+	return 0;
+}
+
+int hsec8_mxl3710_aic_init(void)
+{
+	//printf("hsec8_mxl3710_aic_init \n");
+
+	u8 val;
+	int timer = 100;
+
+	init_i2c_expander_io();
+	mdelay(1);
+
+	//i2c_expander_reg01h_hw_rst();
+	//i2c_expander_reg01h_sft_rst_wr();
+	//mdelay(3);
+
+	/*read irq status bit to clear it which set by power on/software reset/hw reset.*/
+	//i2c_expander_reg01h_rst_int_status_rd();
+	//printf("i2c_expander_reg01h_rst_int_status_rd() =0x%x \n", i2c_expander_reg01h_rst_int_status_rd());
+	//printf("i2c_expander_reg01h_rst_int_status_rd() =0x%x \n", i2c_expander_reg01h_rst_int_status_rd());
+
+	//val = i2c_expander_reg01h_manu_id_rd();
+	//printf("i2c_expander_reg01h_manu_id_rd() = 0x%x \n", val);
+
+	//val = i2c_expander_reg01h_fw_ver_rd();
+	//printf("i2c_expander_reg01h_fw_ver_rd() = 0x%x \n", val);
+
+	mdelay(500);
+	val = (int)read_power_good();
+	while(!val){
+		if (timer-- <= 0)
+			break;
+		mdelay(20);
+		val = read_power_good();
+	}
+
+	if (timer-- <= 0) {
+		printf("timeout on read_power_good() \n");
+		return -1;
+	}
+
+	//output_value_set(u8 pos, u8 val);
+
+	/*reset_10g_rtl8261n*/
+	output_value_set(0, 0);
+	/*release_10g_rtl8261n*/
+	output_value_set(0, 1);
+#if 0
+	/*reset_moca*/
+	output_value_set(1, 0);
+	/*release_moca*/
+	output_value_set(1, 1);
+#endif
+	/*reset_gsw140*/
+	output_value_set(2, 0);
+	/*release_gsw140*/
+	output_value_set(2, 1);
+
+
+/*
+sel2 = p4
+	0
+		HSIO20=10G PHY,REALTEK
+		a2/3=b2/3
+	1
+		HSIO20=a0/1 (with resistor unmounted between a0/1 and HSIO21)
+		a2/3=c2/3
+
+sel1 = p3 (with resistor mounted between a0/1 and HSIO21)
+	0
+		HSIO21=GSW140
+		a0/1=b0/1
+	1
+		HSIO21=MOCA
+		a0/1=c0/1
+*/
+
+	/*HSIO21=GSW140 , a0/1=b0/1*/
+	output_value_set(3, 0);
+	/*HSIO20=10G PHY,REALTEK, a2/3=b2/3*/
+	output_value_set(4, 0);
+
+	/*led_off = 0*/
+	output_value_set(5, 0);
+	/*led_on = 1*/
+	output_value_set(5, 1);
+#if 0
+	/*set_moca_security to 0*/
+	output_value_set(7, 0);
+	/*set_moca_security to 1*/
+	output_value_set(7, 1);
+#endif
+	return 0;
+}
\ No newline at end of file
