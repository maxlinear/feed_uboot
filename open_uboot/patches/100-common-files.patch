# HG changeset patch
# Parent  560b2da809c6544f9049ed0c309aaade6e6a6eee

diff --git a/Makefile b/Makefile
--- a/Makefile
+++ b/Makefile
@@ -922,6 +922,11 @@ endif
 # Always append INPUTS so that arch config.mk's can add custom ones
 INPUTS-y += u-boot.srec u-boot.bin u-boot.sym System.map binary_size_check
 
+# Add u-boot-ram.bin. SPL depends on this, so we need
+# to add this before adding spl bin.
+INPUTS-$(CONFIG_UBOOT_RAM) += u-boot-ram.bin
+INPUTS-$(CONFIG_UBOOT_RAM) += u-boot.dis
+
 INPUTS-$(CONFIG_ONENAND_U_BOOT) += u-boot-onenand.bin
 ifeq ($(CONFIG_SPL_FSL_PBL),y)
 INPUTS-$(CONFIG_RAMBOOT_PBL) += u-boot-with-spl-pbl.bin
@@ -989,6 +994,10 @@ endif
 endif
 endif
 
+ifneq ($(CONFIG_BOOT_FROM_MEM),y)
+include scripts/Makefile.binaries
+endif
+
 INPUTS-$(CONFIG_X86) += u-boot-x86-start16.bin u-boot-x86-reset16.bin \
 	$(if $(CONFIG_SPL_X86_16BIT_INIT),spl/u-boot-spl.bin) \
 	$(if $(CONFIG_TPL_X86_16BIT_INIT),tpl/u-boot-tpl.bin)
@@ -1049,6 +1058,19 @@ cmd_lzma = lzma -c -z -k -9 $< > $@
 
 cfg: u-boot.cfg
 
+ifeq ($(CONFIG_UBOOT_RAM),y)
+
+P34X_SIZE_CHECK = @$(call size_check,$@,$(CONFIG_LGM_U_BOOT_SIZE))
+
+u-boot.dis: u-boot
+		$(OBJDUMP) -d $< > $@
+
+u-boot-ram.bin: u-boot.bin
+	touch dummy
+	cp u-boot.bin u-boot-ram.bin
+	$(P34X_SIZE_CHECK)
+endif # CONFIG_UBOOT_RAM
+
 quiet_cmd_cfgcheck = CFGCHK  $2
 cmd_cfgcheck = $(srctree)/scripts/check-config.sh $2 \
 		$(srctree)/scripts/config_whitelist.txt $(srctree)
@@ -1316,6 +1338,7 @@ cmd_binman = $(srctree)/tools/binman/bin
 		-a spl-dtb=$(CONFIG_SPL_OF_REAL) \
 		-a tpl-dtb=$(CONFIG_TPL_OF_REAL) \
 		$(if $(BINMAN_FAKE_EXT_BLOBS),--fake-ext-blobs) \
+		-a pre-load-key-path=${PRE_LOAD_KEY_PATH} \
 		$(BINMAN_$(@F))
 
 OBJCOPYFLAGS_u-boot.ldr.hex := -I binary -O ihex
@@ -2144,7 +2167,8 @@ clean: $(clean-dirs)
 		-o -name '*.asn1.[ch]' \
 		-o -name '*.symtypes' -o -name 'modules.order' \
 		-o -name modules.builtin -o -name '.tmp_*.o.*' \
-		-o -name 'dsdt.aml' -o -name 'dsdt.asl.tmp' -o -name 'dsdt.c' \
+		-o -name 'dsdt_generated.aml' -o -name 'dsdt_generated.asl.tmp' \
+		-o -name 'dsdt_generated.c' \
 		-o -name '*.efi' -o -name '*.gcno' -o -name '*.so' \) \
 		-type f -print | xargs rm -f
 
diff --git a/arch/Kconfig b/arch/Kconfig
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -194,6 +194,7 @@ config SANDBOX
 	imply PHY_FIXED
 	imply DM_DSA
 	imply CMD_EXTENSION
+	imply BINMAN
 
 config SH
 	bool "SuperH architecture"
@@ -209,14 +210,14 @@ config X86
 	select HAVE_ARCH_IOMAP
 	select HAVE_PRIVATE_LIBGCC
 	select OF_CONTROL
-	select PCI
+	select PCI if !VENDOR_MAXLINEAR
 	select SUPPORT_OF_CONTROL
 	select SYS_CACHE_SHIFT_6
 	select TIMER
 	select USE_PRIVATE_LIBGCC
 	select X86_TSC_TIMER
-	select IRQ
-	imply HAS_ROM if X86_RESET_VECTOR
+	select IRQ if !VENDOR_MAXLINEAR
+	imply HAS_ROM if X86_RESET_VECTOR && !VENDOR_MAXLINEAR
 	imply BLK
 	imply CMD_DM
 	imply CMD_FPGA_LOADMK
@@ -245,7 +246,7 @@ config X86
 	imply USB_ETHER_SMSC95XX
 	imply USB_HOST_ETHER
 	imply PCH
-	imply RTC_MC146818
+	imply RTC_MC146818 if !VENDOR_MAXLINEAR
 	imply ACPIGEN if !QEMU
 	imply SYSINFO if GENERATE_SMBIOS_TABLE
 	imply SYSINFO_SMBIOS if GENERATE_SMBIOS_TABLE
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -42,6 +42,35 @@ config X86_RUN_64BIT
 
 endchoice
 
+choice
+	prompt "SoC Target Selection"
+	depends on VENDOR_MAXLINEAR
+
+config URX851_SOC
+	bool "URX851 SoC"
+	select TARGET_U_BOOT_LIGHTNING
+	select LIGHTNING_MOUNTAIN_SOC
+	help
+	  URX851 is a x86 with quad-core base-IA.
+
+config URX651_SOC
+	bool "URX651 SoC"
+	select TARGET_U_BOOT_LIGHTNING
+	select LIGHTNING_MOUNTAIN_SOC
+	help
+	  URX651 is a x86 with dual-core base-IA.
+
+endchoice
+
+config LIGHTNING_MOUNTAIN_SOC
+	bool
+	default n
+
+config UBOOT_RAM
+	bool "RAM version"
+	default n
+	depends on VENDOR_MAXLINEAR
+
 config X86_64
 	bool
 
@@ -77,6 +106,13 @@ config VENDOR_GOOGLE
 config VENDOR_INTEL
 	bool "Intel"
 
+config VENDOR_MAXLINEAR
+	bool "MaxLinear"
+	select ATOM
+	select X86_RUN_32BIT
+	select SUPPORT_SPL
+	select LGM_EPU
+
 endchoice
 
 # subarchitectures-specific options below
@@ -104,6 +140,7 @@ source "board/efi/Kconfig"
 source "board/emulation/Kconfig"
 source "board/google/Kconfig"
 source "board/intel/Kconfig"
+source "board/maxlinear/Kconfig"
 
 # platform-specific options below
 source "arch/x86/cpu/apollolake/Kconfig"
@@ -113,6 +150,7 @@ source "arch/x86/cpu/broadwell/Kconfig"
 source "arch/x86/cpu/coreboot/Kconfig"
 source "arch/x86/cpu/ivybridge/Kconfig"
 source "arch/x86/cpu/efi/Kconfig"
+source "arch/x86/cpu/lightning_mountain/Kconfig"
 source "arch/x86/cpu/qemu/Kconfig"
 source "arch/x86/cpu/quark/Kconfig"
 source "arch/x86/cpu/queensbay/Kconfig"
@@ -121,6 +159,14 @@ source "arch/x86/cpu/tangier/Kconfig"
 
 # architecture-specific options below
 
+config X86_LOAD_FROM_32_BIT
+	bool "Boot from a 32-bit program"
+	help
+	  Define this to boot U-Boot from a 32-bit program which sets
+	  the GDT differently. This can be used to boot directly from
+	  any stage of coreboot, for example, bypassing the normal
+	  payload-loading feature.
+
 config AHCI
 	default y
 
@@ -131,6 +177,22 @@ config RAMBASE
 	hex
 	default 0x100000
 
+config X86_RESET_VECTOR
+	bool
+	select BINMAN if !VENDOR_MAXLINEAR
+
+config USE_EARLY_BOARD_INIT
+	bool
+
+config USE_CAR
+	bool "Use Cache-As-RAM (CAR) to get temporary RAM at start-up"
+	default y if !HAVE_FSP
+	help
+	  Select this option if your board uses CAR init code, typically in a
+	  car.S file, to get some initial memory for code execution. This is
+	  common with Intel CPUs which don't use FSP.
+
+if !VENDOR_MAXLINEAR
 config XIP_ROM_SIZE
 	hex
 	depends on X86_RESET_VECTOR
@@ -150,10 +212,6 @@ config SMM_TSEG
 config SMM_TSEG_SIZE
 	hex
 
-config X86_RESET_VECTOR
-	bool
-	select BINMAN
-
 # The following options control where the 16-bit and 32-bit init lies
 # If SPL is enabled then it normally holds this init code, and U-Boot proper
 # is normally a 64-bit build.
@@ -201,9 +259,6 @@ config SPL_X86_32BIT_INIT
 	help
 	  This is enabled when 32-bit init is in SPL
 
-config USE_EARLY_BOARD_INIT
-	bool
-
 config RESET_SEG_START
 	hex
 	depends on X86_RESET_VECTOR
@@ -227,14 +282,6 @@ config HAVE_X86_FIT
 	  far it is just a fixed table with the minimum set of headers, so that
 	  it is actually present.
 
-config X86_LOAD_FROM_32_BIT
-	bool "Boot from a 32-bit program"
-	help
-	  Define this to boot U-Boot from a 32-bit program which sets
-	  the GDT differently. This can be used to boot directly from
-	  any stage of coreboot, for example, bypassing the normal
-	  payload-loading feature.
-
 config BOARD_ROMSIZE_KB_512
 	bool
 config BOARD_ROMSIZE_KB_1024
@@ -370,14 +417,6 @@ config HAVE_FSP
 	  Note: Without this binary U-Boot will not be able to set up its
 	  SDRAM so will not boot.
 
-config USE_CAR
-	bool "Use Cache-As-RAM (CAR) to get temporary RAM at start-up"
-	default y if !HAVE_FSP
-	help
-	  Select this option if your board uses CAR init code, typically in a
-	  car.S file, to get some initial memory for code execution. This is
-	  common with Intel CPUs which don't use FSP.
-
 choice
 	prompt "FSP version"
 	depends on HAVE_FSP
@@ -1059,4 +1098,5 @@ config SPL_COREBOOT_SYSINFO
 	  display, memory and build information. It is stored in
 	  struct sysinfo_t after parsing by get_coreboot_info().
 
+endif # VENDOR_MAXLINEAR
 endmenu
diff --git a/arch/x86/Makefile b/arch/x86/Makefile
--- a/arch/x86/Makefile
+++ b/arch/x86/Makefile
@@ -20,6 +20,10 @@ endif
 endif
 endif # EFI
 
+ifdef CONFIG_VENDOR_MAXLINEAR
+head-y := arch/x86/cpu/start.o
+endif
+
 head-$(CONFIG_$(SPL_TPL_)X86_16BIT_INIT) += arch/x86/cpu/start16.o
 head-$(CONFIG_$(SPL_TPL_)X86_16BIT_INIT) += arch/x86/cpu/resetvec.o
 
diff --git a/arch/x86/config.mk b/arch/x86/config.mk
--- a/arch/x86/config.mk
+++ b/arch/x86/config.mk
@@ -119,3 +119,13 @@ EFI_TARGET := --target=efi-app-x86_64
 else
 EFI_TARGET := --target=efi-app-ia32
 endif
+
+ifdef CONFIG_VENDOR_MAXLINEAR
+# kiat_debug: TODO: during SPL build, not sure what is the root cause ???
+# undefined reference to `__normal___udivdi3'
+# need this, otherwise u64 division in partial write will fail
+# PLATFORM_LIBS := -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
+# LDFLAGS to suppress linker warnings
+LDFLAGS_FINAL += -z textoff
+OBJCOPYFLAGS := --gap-fill=0xff
+endif
diff --git a/arch/x86/cpu/Makefile b/arch/x86/cpu/Makefile
--- a/arch/x86/cpu/Makefile
+++ b/arch/x86/cpu/Makefile
@@ -40,7 +40,6 @@ AFLAGS_call32.o := -fpic -fshort-wchar \
 extra-y += call32.o
 endif
 
-obj-y += intel_common/
 obj-$(CONFIG_INTEL_APOLLOLAKE) += apollolake/
 obj-$(CONFIG_INTEL_BAYTRAIL) += baytrail/
 obj-$(CONFIG_INTEL_BRASWELL) += braswell/
@@ -56,6 +55,15 @@ obj-$(CONFIG_INTEL_TANGIER) += tangier/
 obj-$(CONFIG_APIC) += lapic.o ioapic.o
 obj-$(CONFIG_$(SPL_TPL_)ACPI_GPE) += acpi_gpe.o
 obj-$(CONFIG_QFW) += qfw_cpu.o
+obj-$(CONFIG_VENDOR_MAXLINEAR) += lightning_mountain/
+
+ifdef CONFIG_VENDOR_MAXLINEAR
+obj-y += mtrr.o
+obj-y += lapic.o
+obj-y += intel_common/microcode.o
+obj-$(CONFIG_SMP) += sipi_vector.o
+extra-y = start.o
+else
 ifndef CONFIG_SYS_COREBOOT
 obj-$(CONFIG_$(SPL_TPL_)X86_32BIT_INIT) += irq.o
 endif
@@ -69,6 +77,8 @@ obj-$(CONFIG_SMP) += sipi_vector.o
 endif
 obj-y += turbo.o
 obj-$(CONFIG_HAVE_ACPI_RESUME) += wakeup.o
+obj-y += intel_common/
+endif # CONFIG_VENDOR_MAXLINEAR
 
 ifeq ($(CONFIG_$(SPL_)X86_64),y)
 obj-y += x86_64/
diff --git a/arch/x86/cpu/i386/Makefile b/arch/x86/cpu/i386/Makefile
--- a/arch/x86/cpu/i386/Makefile
+++ b/arch/x86/cpu/i386/Makefile
@@ -3,9 +3,10 @@
 # Written by Simon Glass <sjg@chromium.org>
 #
 
-obj-y += call64.o
-obj-y += cpu.o
 ifndef CONFIG_TPL_BUILD
 obj-y += interrupt.o
 endif
 obj-y += setjmp.o
+
+obj-y += cpu.o
+obj-y += call64.o
diff --git a/arch/x86/cpu/i386/cpu.c b/arch/x86/cpu/i386/cpu.c
--- a/arch/x86/cpu/i386/cpu.c
+++ b/arch/x86/cpu/i386/cpu.c
@@ -21,6 +21,7 @@
 #include <common.h>
 #include <cpu_func.h>
 #include <init.h>
+#include <irq_func.h>
 #include <log.h>
 #include <malloc.h>
 #include <spl.h>
@@ -32,6 +33,7 @@
 #include <asm/msr.h>
 #include <asm/mtrr.h>
 #include <asm/processor-flags.h>
+#include <linux/delay.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -415,7 +417,9 @@ int cpu_phys_address_size(void)
 /* Don't allow PCI region 3 to use memory in the 2-4GB memory hole */
 static void setup_pci_ram_top(void)
 {
+#ifndef CONFIG_VENDOR_MAXLINEAR
 	gd->pci_ram_top = 0x80000000U;
+#endif
 }
 
 static void setup_mtrr(void)
@@ -468,8 +472,11 @@ int x86_cpu_init_f(void)
 	if (ll_boot_init())
 		setup_cpu_features();
 	setup_identity();
-	setup_mtrr();
-	setup_pci_ram_top();
+
+	if (IS_ENABLED(CONFIG_VENDOR_MAXLINEAR)) {
+		setup_mtrr();
+		setup_pci_ram_top();
+	}
 
 	/* Set up the i8254 timer if required */
 	if (IS_ENABLED(CONFIG_I8254_TIMER))
@@ -556,6 +563,21 @@ void cpu_disable_paging_pae(void)
 		: "eax");
 }
 
+#ifdef CONFIG_VENDOR_MAXLINEAR
+int do_reset(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	printf("resetting ...\n");
+
+	/* wait 50 ms */
+	udelay(50000);
+	disable_interrupts();
+	reset_cpu();
+
+	/*NOTREACHED*/
+	return 0;
+}
+#endif
+
 static bool can_detect_long_mode(void)
 {
 	return cpuid_eax(0x80000000) > 0x80000000UL;
diff --git a/arch/x86/cpu/i386/interrupt.c b/arch/x86/cpu/i386/interrupt.c
--- a/arch/x86/cpu/i386/interrupt.c
+++ b/arch/x86/cpu/i386/interrupt.c
@@ -269,6 +269,9 @@ int interrupt_init(void)
 	if (!ll_boot_init())
 		return 0;
 
+	if (IS_ENABLED(CONFIG_VENDOR_MAXLINEAR))
+		return 0;
+
 	/* Try to set up the interrupt router, but don't require one */
 	ret = irq_first_device_type(X86_IRQT_BASE, &dev);
 	if (ret && ret != -ENODEV)
diff --git a/arch/x86/cpu/start.S b/arch/x86/cpu/start.S
--- a/arch/x86/cpu/start.S
+++ b/arch/x86/cpu/start.S
@@ -45,11 +45,13 @@
 	cli
 	cld
 
+#ifndef CONFIG_LIGHTNING_B0
 	/* Turn off cache (this might require a 486-class CPU) */
 	movl	%cr0, %eax
 	orl	$(X86_CR0_NW | X86_CR0_CD), %eax
 	movl	%eax, %cr0
 	wbinvd
+#endif
 
 	/*
 	 * Zero the BIST (Built-In Self Test) value since we don't have it.
@@ -143,6 +145,10 @@ car_init_ret:
 	call	debug_uart_init
 #endif
 
+#ifdef CONFIG_VENDOR_MAXLINEAR
+	call rom_msg_backup
+#endif
+
 	/* Get address of global_data */
 	mov	%fs:0, %edx
 #if defined(CONFIG_USE_HOB) && !defined(CONFIG_USE_CAR)
diff --git a/arch/x86/dts/Makefile b/arch/x86/dts/Makefile
--- a/arch/x86/dts/Makefile
+++ b/arch/x86/dts/Makefile
@@ -15,12 +15,17 @@ dtb-y += bayleybay.dtb \
 	efi-x86_app.dtb \
 	efi-x86_payload.dtb \
 	galileo.dtb \
+	osp-tb341.dtb \
 	minnowmax.dtb \
 	qemu-x86_i440fx.dtb \
 	qemu-x86_q35.dtb \
 	theadorable-x86-dfi-bt700.dtb \
 	slimbootloader.dtb \
-	baytrail_som-db5800-som-6867.dtb
+	baytrail_som-db5800-som-6867.dtb \
+	lightning-mountain.dtb		\
+	lightning-mountain-haps.dtb	\
+	octopus.dtb			\
+	octopus-640.dtb
 
 targets += $(dtb-y)
 
diff --git a/arch/x86/include/asm/bitops.h b/arch/x86/include/asm/bitops.h
--- a/arch/x86/include/asm/bitops.h
+++ b/arch/x86/include/asm/bitops.h
@@ -240,7 +240,7 @@ static __inline__ int constant_test_bit(
 	return ((1UL << (nr & 31)) & (((const volatile unsigned int *) addr)[nr >> 5])) != 0;
 }
 
-static __inline__ int variable_test_bit(int nr, volatile void * addr)
+static __inline__ int variable_test_bit(int nr, const volatile void * addr)
 {
 	int oldbit;
 
diff --git a/arch/x86/include/asm/cache.h b/arch/x86/include/asm/cache.h
--- a/arch/x86/include/asm/cache.h
+++ b/arch/x86/include/asm/cache.h
@@ -9,7 +9,14 @@
 /*
  * Use CONFIG_SYS_CACHELINE_SIZE (which is set to 64-bytes) for DMA alignment.
  */
-#define ARCH_DMA_MINALIGN		CONFIG_SYS_CACHELINE_SIZE
+#ifdef CONFIG_SYS_CACHELINE_SIZE
+#define ARCH_DMA_MINALIGN	CONFIG_SYS_CACHELINE_SIZE
+#else
+#define ARCH_DMA_MINALIGN	64
+#endif
+
+#define mb()  asm volatile("mfence" : : : "memory")
+#define wmb() asm volatile("sfence" : : : "memory")
 
 static inline void wbinvd(void)
 {
@@ -27,4 +34,5 @@ void enable_caches(void);
 /* Disable caches and write buffer */
 void disable_caches(void);
 
+void dma_sync_cache_range(void *vaddr, unsigned int size);
 #endif /* __X86_CACHE_H__ */
diff --git a/arch/x86/include/asm/microcode.h b/arch/x86/include/asm/microcode.h
--- a/arch/x86/include/asm/microcode.h
+++ b/arch/x86/include/asm/microcode.h
@@ -22,6 +22,14 @@ extern u32 ucode_size;
  */
 int microcode_update_intel(void);
 
+/**                                                                             
+ * microcode_update_apic() - Apply microcode updates only on APIC
+ *                                                    
+ */
+int microcode_update_apic(void);
+
+void microcode_patch_done(void);
+
 /**
  * microcode_read_rev() - Read the microcode version
  *
diff --git a/arch/x86/include/asm/types.h b/arch/x86/include/asm/types.h
--- a/arch/x86/include/asm/types.h
+++ b/arch/x86/include/asm/types.h
@@ -20,8 +20,13 @@ typedef unsigned short umode_t;
 
 typedef u32 dma_addr_t;
 
+#if defined(CONFIG_X86_RUN_32BIT)
+typedef unsigned long phys_addr_t;                                              
+typedef unsigned long phys_size_t;
+#else
 typedef unsigned long long phys_addr_t;
 typedef unsigned long long phys_size_t;
+#endif
 
 #endif /* __KERNEL__ */
 
diff --git a/arch/x86/include/asm/zimage.h b/arch/x86/include/asm/zimage.h
--- a/arch/x86/include/asm/zimage.h
+++ b/arch/x86/include/asm/zimage.h
@@ -27,7 +27,11 @@
 #define SETUP_MAX_SIZE     32768
 
 #define SETUP_START_OFFSET 0x200
+#ifdef CONFIG_VENDOR_MAXLINEAR
+#define BZIMAGE_LOAD_ADDR  0x2000000
+#else /* CONFIG_VENDOR_MAXLINEAR  */
 #define BZIMAGE_LOAD_ADDR  0x100000
+#endif /* CONFIG_VENDOR_MAXLINEAR  */
 #define ZIMAGE_LOAD_ADDR   0x10000
 
 /**
@@ -60,7 +64,7 @@ struct boot_params *load_zimage(char *im
  * @return 0 (always)
  */
 int setup_zimage(struct boot_params *setup_base, char *cmd_line, int auto_boot,
-		 ulong initrd_addr, ulong initrd_size, ulong cmdline_force);
+			ulong initrd_addr, ulong initrd_size, ulong cmdline_force);
 
 /**
  * zimage_dump() - Dump the metadata of a zimage
@@ -72,4 +76,9 @@ int setup_zimage(struct boot_params *set
  */
 void zimage_dump(struct boot_params *base_ptr);
 
+#ifdef CONFIG_VENDOR_MAXLINEAR
+int setup_fdt(struct boot_params *setup_base, unsigned long ft_addr,
+				unsigned long ft_size, struct lmb *lmb);
 #endif
+
+#endif
diff --git a/arch/x86/lib/Makefile b/arch/x86/lib/Makefile
--- a/arch/x86/lib/Makefile
+++ b/arch/x86/lib/Makefile
@@ -3,6 +3,25 @@
 # (C) Copyright 2002-2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 
+ifdef CONFIG_VENDOR_MAXLINEAR
+obj-y += cache.o
+obj-y += init_helpers.o
+obj-y += interrupts.o
+obj-y += string.o
+obj-y += relocate.o
+ifdef CONFIG_SPL_BUILD
+obj-$(CONFIG_BOOT_FROM_EMMC) += spl_lgm_emmc.o
+obj-$(CONFIG_BOOT_FROM_NAND) += spl_lgm_nand.o spl_lgm_ebu_nand.o
+obj-$(CONFIG_BOOT_FROM_QSPI_NOR) += spl_lgm_nor.o
+obj-$(CONFIG_BOOT_FROM_QSPI_NAND) += spl_lgm_nand.o spl_lgm_spi_nand.o
+else
+obj-$(CONFIG_CMD_BOOTM) += bootm.o
+obj-y += cmd_boot.o
+obj-$(CONFIG_CMD_ZBOOT) += zimage.o
+endif
+
+else # CONFIG_VENDOR_MAXLINEAR
+
 obj-y	+= bdinfo.o
 ifndef CONFIG_X86_64
 ifndef CONFIG_TPL_BUILD
@@ -63,6 +82,8 @@ obj-y += spl.o
 endif
 endif
 
+endif # CONFIG_VENDOR_MAXLINEAR
+
 lib-$(CONFIG_USE_PRIVATE_LIBGCC) += div64.o
 
 ifeq ($(CONFIG_$(SPL_)X86_64),)
diff --git a/arch/x86/lib/bootm.c b/arch/x86/lib/bootm.c
--- a/arch/x86/lib/bootm.c
+++ b/arch/x86/lib/bootm.c
@@ -26,6 +26,7 @@
 #ifdef CONFIG_SYS_COREBOOT
 #include <asm/arch/timestamp.h>
 #endif
+#include <asm/sections.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -78,6 +79,15 @@ static int boot_prep_linux(bootm_headers
 	size_t len;
 	int ret;
 
+#if CONFIG_IS_ENABLED(VENDOR_MAXLINEAR)
+	/*
+	 * for lgm, force to go through zimage hardcoded
+	 * boot_param flow, since there isn't any in fit image
+	 */
+	if (IS_ENABLED(CONFIG_FIT))
+		is_zimage = 1;
+#endif /* CONFIG_IS_ENABLED(VENDOR_MAXLINEAR) */
+
 #ifdef CONFIG_OF_LIBFDT
 	if (images->ft_len) {
 		debug("using: FDT\n");
@@ -119,6 +129,22 @@ static int boot_prep_linux(bootm_headers
 		ulong load_address;
 		char *base_ptr;
 
+#ifdef CONFIG_VENDOR_MAXLINEAR
+
+	#if CONFIG_IS_ENABLED(FIT)
+		if (images->fit_uname_os) {
+			ret = fit_image_get_load(images->fit_hdr_os,
+				images->fit_noffset_os,
+				&load_address);
+			if (ret) {
+				puts("Can't get load address");
+				goto error;
+			}
+		} else if (images->legacy_hdr_valid)
+	#endif /* CONFIG_IS_ENABLED(FIT) */
+		/* use load address from uimage header */
+		load_address = image_get_load(hdr);
+#endif
 		base_ptr = (char *)load_zimage(data, len, &load_address);
 		if (!base_ptr) {
 			puts("## Kernel loading failed ...\n");
@@ -144,6 +170,14 @@ static int boot_prep_linux(bootm_headers
 		return 1;
 	}
 
+#ifdef CONFIG_VENDOR_MAXLINEAR
+	if (images->ft_addr && images->ft_len) {
+		ret = setup_fdt((void *)images->ep,
+				(unsigned long)images->ft_addr,
+				images->ft_len, &images->lmb);
+	}
+#endif
+
 	return 0;
 
 error:
@@ -201,9 +235,16 @@ int boot_linux_kernel(ulong setup_base, 
 /* Subcommand: GO */
 static int boot_jump_linux(bootm_headers_t *images)
 {
-	debug("## Transferring control to Linux (at address %08lx, kernel %08lx) ...\n",
+	printf("## Transferring control to Linux (at address %08lx, kernel %08lx) ...\n",
 	      images->ep, images->os.load);
 
+#ifdef CONFIG_CMD_ICC
+	extern void icc_uboot_bootm(void);
+
+	/* must do it here so that we dont lose RBE firewall rules too early */
+	icc_uboot_bootm();
+#endif
+
 	return boot_linux_kernel(images->ep, images->os.load,
 				 images->os.arch == IH_ARCH_X86_64);
 }
@@ -239,5 +280,44 @@ static ulong get_sp(void)
 
 void arch_lmb_reserve(struct lmb *lmb)
 {
+#ifdef CONFIG_VENDOR_MAXLINEAR
+	ulong sp = get_sp();
+	ulong end = gd->ram_top;
+	ulong bank_end;
+	int bank;
+
+	/*
+	 * Reserve memory from aligned address below the bottom of U-Boot stack
+	 * until end of U-Boot area using LMB to prevent U-Boot from overwriting
+	 * that memory.
+	 */
+	debug("## Current stack ends at 0x%08lx ", sp);
+
+	/* adjust sp by 4K to be safe */
+	sp -= 4096;
+	for (bank = 0; bank < CONFIG_NR_DRAM_BANKS; bank++) {
+		if (!gd->bd->bi_dram[bank].size ||
+		    sp < gd->bd->bi_dram[bank].start)
+			continue;
+		/* Watch out for RAM at end of address space! */
+		bank_end = gd->bd->bi_dram[bank].start +
+			gd->bd->bi_dram[bank].size - 1;
+		/* Reserve space at top of DDR for Rootfs */
+		bank_end -= ROOTFS_MEM_ALLOC_SIZE;
+
+		if (sp > bank_end)
+			continue;
+		if (bank_end > end)
+			bank_end = end - 1;
+
+		lmb_reserve(lmb, sp, bank_end - sp + 1);
+
+		if (gd->flags & GD_FLG_SKIP_RELOC)
+			lmb_reserve(lmb, (phys_addr_t)(uintptr_t)_start, gd->mon_len);
+
+		break;
+	}
+#else
 	arch_lmb_reserve_generic(lmb, get_sp(), gd->ram_top, 4096);
+#endif
 }
diff --git a/arch/x86/lib/cache.c b/arch/x86/lib/cache.c
new file mode 100644
--- /dev/null
+++ b/arch/x86/lib/cache.c
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright © 2022 MaxLinear, Inc.
+ *
+ */
+#include <common.h>
+#include <cpu_func.h>
+#include <asm/cache.h>
+
+/* Invalidates from every level of the cache hierarchy
+ * in the cache coherence domain the
+ * cache line that contains the linear address
+ * specified with the memory operand
+ * Cache line = always 64 bytes
+ */
+void clflush(volatile void *p)
+{
+	asm volatile ("clflush (%0)\n\t"::"r"(p));
+}
+
+void dma_sync_cache_range(void *vaddr, unsigned int size)
+{
+	const unsigned long clflush_size = 64;
+	void *p = (void *)((unsigned long)vaddr & ~(clflush_size - 1));
+	void *vend = vaddr + size;
+
+	if (p >= vend)
+		return;
+
+	for (; p < vend; p += clflush_size)
+		clflush(p);
+
+	mb();
+}
+
+void flush_cache(unsigned long start, unsigned long size)
+{
+	const unsigned long clflush_size = 64;
+	void *p = (void *)((unsigned long)start & ~(clflush_size - 1));
+	void *vend = (void *)(unsigned long)start + size;
+
+	if (p >= vend)
+		return;
+
+	for (; p < vend; p += clflush_size)
+		clflush(p);
+
+	mb();
+}
+
+void flush_dcache_all(void)
+{
+	asm("wbinvd\n");
+}
diff --git a/arch/x86/lib/relocate.c b/arch/x86/lib/relocate.c
--- a/arch/x86/lib/relocate.c
+++ b/arch/x86/lib/relocate.c
@@ -100,6 +100,20 @@ static void do_elf_reloc_fixups32(unsign
 {
 	Elf32_Addr *offset_ptr_rom, *last_offset = NULL;
 	Elf32_Addr *offset_ptr_ram;
+	Elf32_Rel *rel_end_addr;
+
+	/* Linker in GCC 8.4.0 includes R_386_NONE in the last two entries
+	 * causing warnings at SPL. This is to suppress the unsupported
+	 * relocation type warnings.
+	 */
+#if defined(CONFIG_SPL_BUILD)
+	if (IS_ENABLED(CONFIG_VENDOR_MAXLINEAR))
+		rel_end_addr = (Elf32_Rel *)(re_end - 2);
+	else
+		rel_end_addr = (Elf32_Rel *)re_end;
+#else
+	rel_end_addr = (Elf32_Rel *)re_end;
+#endif /* CONFIG_SPL_BUILD */
 
 	do {
 		unsigned int type = ELF32_R_TYPE(re_src->r_info);
@@ -127,17 +141,17 @@ static void do_elf_reloc_fixups32(unsign
 			    *offset_ptr_ram <= text_base + size) {
 				*offset_ptr_ram += gd->reloc_off;
 			} else {
-				debug("   %p: rom reloc %x, ram %p, value %x, limit %lX\n",
+				rbe_debug_print("   %p: rom reloc %x, ram %p, value %x, limit %lX\n",
 				      re_src, re_src->r_offset, offset_ptr_ram,
 				      *offset_ptr_ram, text_base + size);
 			}
 		} else {
-			debug("   %p: rom reloc %x, last %p\n", re_src,
+			rbe_debug_print("   %p: rom reloc %x, last %p\n", re_src,
 			       re_src->r_offset, last_offset);
 		}
 		last_offset = offset_ptr_rom;
 
-	} while (++re_src < re_end);
+	} while (++re_src < rel_end_addr);
 }
 #endif
 
@@ -161,7 +175,11 @@ int do_elf_reloc_fixups(void)
 		panic("No relocation data");
 
 #ifdef CONFIG_SYS_TEXT_BASE
+ #if defined(CONFIG_SPL_BUILD) && defined(CONFIG_VENDOR_MAXLINEAR)
+	text_base = CONFIG_SPL_TEXT_BASE;
+ #else
 	text_base = CONFIG_SYS_TEXT_BASE;
+ #endif
 #else
 	panic("No CONFIG_SYS_TEXT_BASE");
 #endif
diff --git a/arch/x86/lib/zimage.c b/arch/x86/lib/zimage.c
--- a/arch/x86/lib/zimage.c
+++ b/arch/x86/lib/zimage.c
@@ -40,6 +40,13 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+
+#ifdef CONFIG_VENDOR_MAXLINEAR
+/* for LGM, these regions are fixed. 8MB for setup base to
+ * fit firewalled configurations
+ */
+#define DEFAULT_SETUP_BASE	0x800000
+#else
 /*
  * Memory lay-out:
  *
@@ -50,6 +57,8 @@ DECLARE_GLOBAL_DATA_PTR;
  *	0x9000-0x90FF	Kernel command line
  */
 #define DEFAULT_SETUP_BASE	0x90000
+#endif /* CONFIG_VENDOR_MAXLINEAR */
+
 #define COMMAND_LINE_OFFSET	0x9000
 #define HEAP_END_OFFSET		0x8e00
 
@@ -216,6 +225,27 @@ struct boot_params *load_zimage(char *im
 	/* base address for real-mode segment */
 	setup_base = (struct boot_params *)DEFAULT_SETUP_BASE;
 
+	if (*load_addressp) {
+		/* uImage does not have setup.bin. So we fill this with
+		 * static values instead.
+		 */
+		printf("\n WA: CONFIG_VENDOR_MAXLINEAR <setup_header_default>\n");
+		memset(hdr, 0, sizeof(struct setup_header));
+		hdr->hardware_subarch	 = 5; /* X86_SUBARCH_LTM */
+		hdr->boot_flag			 = KERNEL_MAGIC;
+		hdr->jump				 = 0xeb;
+		hdr->header				 = KERNEL_V2_MAGIC;
+		hdr->version			 = 0x020c;
+		hdr->kernel_version		 = 0x2f60;
+		hdr->type_of_loader		 = 8;
+		hdr->code32_start		 = *load_addressp; /* compressed or binary for KERNEL_ENTRY */
+		hdr->relocatable_kernel	 = 0;
+		hdr->kernel_alignment	 = 0x100000;
+		hdr->heap_end_ptr		 = HEAP_END_OFFSET;
+		hdr->loadflags			|= BIG_KERNEL_FLAG;
+		hdr->setup_data			 = 0;
+	}
+
 	if (!kernel_magic_ok(hdr))
 		return 0;
 
@@ -235,8 +265,8 @@ struct boot_params *load_zimage(char *im
 	/* determine boot protocol version */
 	bootproto = get_boot_protocol(hdr, true);
 
-	log_debug("Using boot protocol version %x.%02x\n",
-		  (bootproto & 0xff00) >> 8, bootproto & 0xff);
+	printf("Using boot protocol version %x.%02x\n",
+	       (bootproto & 0xff00) >> 8, bootproto & 0xff);
 
 	version = get_kernel_version(params, image);
 	if (version)
@@ -249,7 +279,9 @@ struct boot_params *load_zimage(char *im
 		    (hdr->loadflags & BIG_KERNEL_FLAG);
 
 	/* Determine load address */
-	if (big_image)
+	if (*load_addressp)
+		; /* for uImage, we use the load_address specified in header */
+	else if (big_image)
 		*load_addressp = BZIMAGE_LOAD_ADDR;
 	else
 		*load_addressp = ZIMAGE_LOAD_ADDR;
@@ -384,7 +416,10 @@ int setup_zimage(struct boot_params *set
 
 	log_debug("Setup devicetree\n");
 	setup_device_tree(hdr, (const void *)env_get_hex("fdtaddr", 0));
+
+#ifndef CONFIG_VENDOR_MAXLINEAR
 	setup_video(&setup_base->screen_info);
+#endif
 
 	if (IS_ENABLED(CONFIG_EFI_STUB))
 		setup_efi_info(&setup_base->efi_info);
@@ -392,6 +427,28 @@ int setup_zimage(struct boot_params *set
 	return 0;
 }
 
+#ifdef CONFIG_VENDOR_MAXLINEAR
+int setup_fdt(struct boot_params *setup_base, unsigned long ft_addr,
+				unsigned long ft_size, struct lmb *lmb)
+{
+	struct setup_header *hdr = &setup_base->hdr;
+	struct setup_data *data;
+
+	/* data structure is placed 16 bytes before ft_addr */
+	data = (struct setup_data*)
+		(ft_addr - offsetof(struct setup_data, data));
+	lmb_reserve(lmb, (ulong) data, sizeof(struct setup_data));
+
+	printf("fdt setup at 0x%lx size %lu\n", ft_addr, ft_size);
+
+	data->len = ft_size;
+	data->type = SETUP_DTB;
+	data->next = 0;
+	hdr->setup_data = (unsigned long)data;
+
+	return 0;
+}
+#endif
 static int do_zboot_start(struct cmd_tbl *cmdtp, int flag, int argc,
 			  char *const argv[])
 {
diff --git a/boot/bootm.c b/boot/bootm.c
--- a/boot/bootm.c
+++ b/boot/bootm.c
@@ -87,6 +87,33 @@ static int bootm_start(struct cmd_tbl *c
 	return 0;
 }
 
+static ulong bootm_data_addr(int argc, char *const argv[])
+{
+	ulong addr;
+
+	if (argc > 0)
+		addr = simple_strtoul(argv[0], NULL, 16);
+	else
+		addr = image_load_addr;
+
+	return addr;
+}
+
+static int bootm_pre_load(struct cmd_tbl *cmdtp, int flag, int argc,
+			  char *const argv[])
+{
+	ulong data_addr = bootm_data_addr(argc, argv);
+	int ret = 0;
+
+	if (CONFIG_IS_ENABLED(CMD_BOOTM_PRE_LOAD))
+		ret = image_pre_load(data_addr);
+
+	if (ret)
+		ret = CMD_RET_FAILURE;
+
+	return ret;
+}
+
 static int bootm_find_os(struct cmd_tbl *cmdtp, int flag, int argc,
 			 char *const argv[])
 {
@@ -174,9 +201,12 @@ static int bootm_find_os(struct cmd_tbl 
 		return 1;
 	}
 
-	/* If we have a valid setup.bin, we will use that for entry (x86) */
-	if (images.os.arch == IH_ARCH_I386 ||
-	    images.os.arch == IH_ARCH_X86_64) {
+	/* If we have a valid setup.bin, we will use that for entry (x86)
+	 * Only do this if kernel image is not a FIT format image
+	 */
+	if ((images.os.arch == IH_ARCH_I386 ||
+	    images.os.arch == IH_ARCH_X86_64) &&
+		(genimg_get_format(os_hdr) != IMAGE_FORMAT_LEGACY)) {
 		ulong len;
 
 		ret = boot_get_setup(&images, IH_ARCH_I386, &images.ep, &len);
@@ -677,6 +707,9 @@ int do_bootm_states(struct cmd_tbl *cmdt
 	if (states & BOOTM_STATE_START)
 		ret = bootm_start(cmdtp, flag, argc, argv);
 
+	if (!ret && (states & BOOTM_STATE_PRE_LOAD))
+		ret = bootm_pre_load(cmdtp, flag, argc, argv);
+
 	if (!ret && (states & BOOTM_STATE_FINDOS))
 		ret = bootm_find_os(cmdtp, flag, argc, argv);
 
@@ -866,6 +899,9 @@ static const void *boot_get_kernel(struc
 					      &fit_uname_config,
 					      &fit_uname_kernel);
 
+	if (CONFIG_IS_ENABLED(CMD_BOOTM_PRE_LOAD))
+		img_addr += image_load_offset;
+
 	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);
 
 	/* check image type, for FIT images get FIT kernel node */
diff --git a/boot/image.c b/boot/image.c
--- a/boot/image.c
+++ b/boot/image.c
@@ -174,13 +174,14 @@ static const table_entry_t uimage_type[]
 	{	IH_TYPE_ZYNQMPIMAGE, "zynqmpimage", "Xilinx ZynqMP Boot Image" },
 	{	IH_TYPE_ZYNQMPBIF,  "zynqmpbif",  "Xilinx ZynqMP Boot Image (bif)" },
 	{	IH_TYPE_FPGA,       "fpga",       "FPGA Image" },
-	{       IH_TYPE_TEE,        "tee",        "Trusted Execution Environment Image",},
+	{	IH_TYPE_TEE,        "tee",        "Trusted Execution Environment Image",},
 	{	IH_TYPE_FIRMWARE_IVT, "firmware_ivt", "Firmware with HABv4 IVT" },
-	{       IH_TYPE_PMMC,        "pmmc",        "TI Power Management Micro-Controller Firmware",},
+	{	IH_TYPE_PMMC,        "pmmc",        "TI Power Management Micro-Controller Firmware",},
 	{	IH_TYPE_STM32IMAGE, "stm32image", "STMicroelectronics STM32 Image" },
 	{	IH_TYPE_MTKIMAGE,   "mtk_image",   "MediaTek BootROM loadable Image" },
 	{	IH_TYPE_COPRO, "copro", "Coprocessor Image"},
 	{	IH_TYPE_SUNXI_EGON, "sunxi_egon",  "Allwinner eGON Boot Image" },
+	{	IH_TYPE_UBOOT, "uboot",  "U-Boot Image"},
 	{	-1,		    "",		  "",			},
 };
 
diff --git a/cmd/Kconfig b/cmd/Kconfig
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -194,6 +194,16 @@ config CMD_BOOTM
 	help
 	  Boot an application image from the memory.
 
+config CMD_BOOTM_PRE_LOAD
+       bool "enable pre-load on bootm"
+       depends on CMD_BOOTM
+       depends on IMAGE_PRE_LOAD
+       default n
+       help
+         Enable support of stage pre-load for the bootm command.
+	 This stage allow to check or modify the image provided
+	 to the bootm command.
+
 config BOOTM_EFI
 	bool "Support booting UEFI FIT images"
 	depends on CMD_BOOTEFI && CMD_BOOTM && FIT
@@ -292,6 +302,12 @@ config CMD_BOOTEFI_HELLO
 	  for testing that EFI is working at a basic level, and for bringing
 	  up EFI support on a new architecture.
 
+config CMD_UPGRADE
+	bool "upgrade"
+	default y if VENDOR_MAXLINEAR
+	help
+	  Support LGM image upgrade command.
+
 source lib/efi_selftest/Kconfig
 
 config CMD_BOOTMENU
@@ -325,6 +341,12 @@ config CMD_ELF
 	help
 	  Boot an ELF/vxWorks image from the memory.
 
+config CMD_FIT_LOAD
+	bool "Load FIT format containing DTBOs"
+	depends on DRIVER_LIGHTNING
+	help
+	  Load FIT image containing DTBO files and apply it to the base DTB
+
 config CMD_FDT
 	bool "Flattened Device Tree utility commands"
 	default y
@@ -976,6 +998,16 @@ config CMD_GPIO
 	help
 	  GPIO support.
 
+config CMD_SSO
+	bool "serial shift output"
+	help
+	  Support serial shift output command
+
+config CMD_AQN
+	bool "Aquantia firmware upload"
+	help
+	  Support Aquantia 10G PHY firmware upload via MDIO
+
 config CMD_PWM
 	bool "pwm"
 	depends on DM_PWM
@@ -2128,6 +2160,29 @@ config CMD_TPM_TEST
 
 endif
 
+config CMD_AUTH
+	bool "LGM image authentication command"
+	default y if CHD_SECURE_BOOT
+	help
+	  User application auth & auth_img & auth_initrd
+
+config CMD_ICC
+	bool "LGM inter chip communication"
+	default y if CHD_SECURE_BOOT
+	help
+	  User application to send message to TEP
+
+config CMD_IA_SWITCH
+	bool "switch from IA_BOOT to IA_VMM mode"
+	default n
+	depends on ( DRIVER_LIGHTNING )
+
+config CMD_WATCHDOG
+	bool "watchdog timer application"
+	default n
+	help
+	  User application to control the watchdog timer
+
 endmenu
 
 menu "Firmware commands"
diff --git a/cmd/Makefile b/cmd/Makefile
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -205,7 +205,7 @@ obj-$(CONFIG_ARM) += arm/
 obj-$(CONFIG_RISCV) += riscv/
 obj-$(CONFIG_SANDBOX) += sandbox/
 obj-$(CONFIG_X86) += x86/
-
+obj-$(CONFIG_VENDOR_MAXLINEAR) += mxl/
 obj-$(CONFIG_ARCH_MVEBU) += mvebu/
 endif # !CONFIG_SPL_BUILD
 
diff --git a/cmd/mxl/Makefile b/cmd/mxl/Makefile
new file mode 100644
--- /dev/null
+++ b/cmd/mxl/Makefile
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-$(CONFIG_CMD_SSO) += serial_sft_cmd.o
+obj-$(CONFIG_CMD_WATCHDOG) += wdt.o
+obj-$(CONFIG_CMD_UPGRADE) += upgrade.o
+obj-$(CONFIG_CMD_AUTH) += cmd_auth.o
+obj-$(CONFIG_CMD_IA_SWITCH) += atom_ia_switch.o
+obj-$(CONFIG_ROLLBACKID_SUPPORT) += cmd_rollbackid.o
+obj-$(CONFIG_FLEXI_RBID) += cmd_flexi_rbid.o
+obj-$(CONFIG_CMD_ICC) += cmd_icc.o
+obj-$(CONFIG_CMD_ICC) += cmd_mxl-md.o
+obj-$(CONFIG_ROLLBACKID_SUPPORT) += cmd_svn_update.o
+obj-$(CONFIG_ROLLBACKID_SUPPORT) += cmd_mxl_commit.o
+obj-$(CONFIG_CMD_FIT_LOAD) += cmd_extract_dtb.o
+obj-$(CONFIG_CMD_AQN) += aquantia.o
+obj-$(CONFIG_CMD_AQN) += cmd_aqn.o
diff --git a/cmd/net.c b/cmd/net.c
--- a/cmd/net.c
+++ b/cmd/net.c
@@ -13,6 +13,7 @@
 #include <dm.h>
 #include <env.h>
 #include <image.h>
+#include <cpu_func.h>
 #include <net.h>
 #include <net/udp.h>
 #include <net/sntp.h>
@@ -275,6 +276,8 @@ static int netboot_common(enum proto_t p
 		return CMD_RET_SUCCESS;
 	}
 
+	flush_cache(image_load_addr, size);
+
 	bootstage_mark(BOOTSTAGE_ID_NET_LOADED);
 
 	rcode = bootm_maybe_autostart(cmdtp, argv[0]);
diff --git a/cmd/ubi.c b/cmd/ubi.c
--- a/cmd/ubi.c
+++ b/cmd/ubi.c
@@ -148,7 +148,7 @@ bad:
 	return err;
 }
 
-static int ubi_create_vol(char *volume, int64_t size, int dynamic, int vol_id,
+int ubi_create_vol(char *volume, int64_t size, int dynamic, int vol_id,
 			  bool skipcheck)
 {
 	struct ubi_mkvol_req req;
@@ -197,7 +197,7 @@ static struct ubi_volume *ubi_find_volum
 	return NULL;
 }
 
-static int ubi_remove_vol(char *volume)
+int ubi_remove_vol(char *volume)
 {
 	int err, reserved_pebs, i;
 	struct ubi_volume *vol;
@@ -511,6 +511,11 @@ int ubi_part(char *part_name, const char
 	struct mtd_info *mtd;
 	int err = 0;
 
+	if (ubi && ubi->mtd && !strcmp(ubi->mtd->name, part_name)) {
+		printf("UBI partition '%s' already selected\n", part_name);
+		return 0;
+	}
+
 	ubi_detach();
 
 	mtd_probe_devices();
diff --git a/common/Makefile b/common/Makefile
--- a/common/Makefile
+++ b/common/Makefile
@@ -46,6 +46,12 @@ obj-$(CONFIG_UPDATE_COMMON) += update.o
 obj-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
 obj-$(CONFIG_CMDLINE) += cli_readline.o cli_simple.o
 
+ifndef CONFIG_BOOT_FROM_EMMC
+obj-$(CONFIG_CMD_UPGRADE) += img_upgrade.o
+else
+obj-$(CONFIG_CMD_UPGRADE) += img_upgrade_emmc.o
+obj-$(CONFIG_MMC) += gpt_part_abstract.o
+endif # !CONFIG_BOOT_FROM_EMMC
 endif # !CONFIG_SPL_BUILD
 
 obj-$(CONFIG_$(SPL_TPL_)BOOTSTAGE) += bootstage.o
@@ -95,6 +101,10 @@ obj-$(CONFIG_IO_TRACE) += iotrace.o
 obj-y += memsize.o
 obj-y += stdio.o
 
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_CMD_ICC) += image-mxl-md.o
+endif
+
 ifdef CONFIG_CMD_EEPROM_LAYOUT
 obj-y += eeprom/eeprom_field.o eeprom/eeprom_layout.o
 endif
diff --git a/common/board_f.c b/common/board_f.c
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -107,7 +107,7 @@ static int init_func_watchdog_init(void)
 	(defined(CONFIG_M68K) || defined(CONFIG_MICROBLAZE) || \
 	defined(CONFIG_SH) || \
 	defined(CONFIG_DESIGNWARE_WATCHDOG) || \
-	defined(CONFIG_IMX_WATCHDOG))
+	defined(CONFIG_IMX_WATCHDOG) || defined(CONFIG_WDT_LGM))
 	hw_watchdog_init();
 	puts("       Watchdog enabled\n");
 # endif
@@ -385,6 +385,29 @@ static int reserve_round_4k(void)
 	return 0;
 }
 
+#ifdef CONFIG_VENDOR_MAXLINEAR
+/* Reserve space at top of DDR for Rootfs mounted from DDR */
+static int reserve_ro_region(void)
+{
+	ulong addr;
+
+	/* All EMMC models use pseudo RAM filesystem
+	 * All secureboot models use pseudo RAM filesystem
+	 */
+	if (!CONFIG_IS_ENABLED(BOOT_FROM_EMMC)) {
+		if (!CONFIG_IS_ENABLED(CHD_SECURE_BOOT))
+			return 0;
+	}
+
+	addr = gd->relocaddr;
+	addr -= ROOTFS_MEM_ALLOC_SIZE;
+	gd->relocaddr = addr;
+	printf("Reserving %dM for Rootfs at: %08lx\n",
+	      ROOTFS_MEM_ALLOC_SIZE >> 20, gd->relocaddr);
+	return 0;
+}
+#endif
+
 static int reserve_video(void)
 {
 #ifdef CONFIG_DM_VIDEO
@@ -694,10 +717,12 @@ static int setup_reloc(void)
 	if (gd->flags & GD_FLG_SKIP_RELOC) {
 		debug("Skipping relocation due to flag\n");
 	} else {
-		debug("Relocation Offset is: %08lx\n", gd->reloc_off);
-		debug("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
+		printf("Relocation Offset is: %08lx\n", gd->reloc_off);
+		printf("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
 		      gd->relocaddr, (ulong)map_to_sysmem(gd->new_gd),
 		      gd->start_addr_sp);
+		printf("Relocating to <0x%08lx> with offset <0x%08lx> \n",
+		      gd->relocaddr, gd->reloc_off);
 	}
 
 	return 0;
@@ -915,6 +940,9 @@ static const init_fnc_t init_sequence_f[
 #endif
 	reserve_round_4k,
 	arch_reserve_mmu,
+#ifdef CONFIG_VENDOR_MAXLINEAR
+	reserve_ro_region,
+#endif
 	reserve_video,
 	reserve_trace,
 	reserve_uboot,
diff --git a/common/usb_hub.c b/common/usb_hub.c
--- a/common/usb_hub.c
+++ b/common/usb_hub.c
@@ -141,7 +141,6 @@ int usb_get_port_status(struct usb_devic
 	 *
 	 * Note: this only supports driver model.
 	 */
-
 	if (!usb_hub_is_root_hub(dev->dev) && usb_hub_is_superspeed(dev)) {
 		struct usb_port_status *status = (struct usb_port_status *)data;
 		u16 tmp = le16_to_cpu(status->wPortStatus) &
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -155,6 +155,12 @@ config INTEL_ICH6_GPIO
 	help
 	  Say yes here to select Intel ICH6 compatible legacy GPIO driver.
 
+config MXL_LGM_GPIO
+	bool "MXL LGM SoC gpio driver"
+	default y if VENDOR_MAXLINEAR
+	help
+	  Select MaxLinear LGM SoC gpio driver for U-boot
+
 config IMX_RGPIO2P
 	bool "i.MX7ULP RGPIO2P driver"
 	depends on DM
@@ -414,6 +420,16 @@ config DM_74X164
 	  shift registers, such as 74lv165, 74hc595.
 	  This driver can be used to provide access to more gpio outputs.
 
+config DM_PI4IOE5V6408
+	bool "PI4IOE5V6408 I2C expander I/O ports"
+	depends on DM_GPIO && DM_I2C
+	help
+	  Say yes here to provide access to several register-oriented
+	  SMBus I/O expanders, made by pericom.  Compatible
+	  models include:
+
+	  8 bits:	PI4IOE5V6408,
+
 config DM_PCA953X
 	bool "PCA95[357]x, PCA9698, TCA64xx, and MAX7310 I/O ports"
 	depends on DM_GPIO && DM_I2C
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -11,6 +11,7 @@ endif
 obj-$(CONFIG_$(SPL_TPL_)DM_GPIO) += gpio-uclass.o
 
 obj-$(CONFIG_$(SPL_)DM_PCA953X)	+= pca953x_gpio.o
+obj-$(CONFIG_$(SPL_)DM_PI4IOE5V6408)	+= pi4ioe5v6408_gpio.o
 
 obj-$(CONFIG_AT91_GPIO)	+= at91_gpio.o
 obj-$(CONFIG_ATMEL_PIO4)	+= atmel_pio4.o
@@ -19,6 +20,7 @@ obj-$(CONFIG_CORTINA_GPIO)      += corti
 obj-$(CONFIG_INTEL_GPIO)	+= intel_gpio.o
 obj-$(CONFIG_INTEL_ICH6_GPIO)	+= intel_ich6_gpio.o
 obj-$(CONFIG_INTEL_BROADWELL_GPIO)	+= intel_broadwell_gpio.o
+obj-$(CONFIG_MXL_LGM_GPIO)	+= lgm_gpio.o
 obj-$(CONFIG_IPROC_GPIO)	+= iproc_gpio.o
 obj-$(CONFIG_KIRKWOOD_GPIO)	+= kw_gpio.o
 obj-$(CONFIG_KONA_GPIO)	+= kona_gpio.o
diff --git a/drivers/i2c/muxes/Makefile b/drivers/i2c/muxes/Makefile
--- a/drivers/i2c/muxes/Makefile
+++ b/drivers/i2c/muxes/Makefile
@@ -3,5 +3,7 @@
 # Copyright (c) 2015 Google, Inc
 obj-$(CONFIG_I2C_ARB_GPIO_CHALLENGE) += i2c-arb-gpio-challenge.o
 obj-$(CONFIG_I2C_MUX) += i2c-mux-uclass.o
+ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_I2C_MUX_PCA954x) += pca954x.o
+endif
 obj-$(CONFIG_I2C_MUX_GPIO) += i2c-mux-gpio.o
diff --git a/drivers/led/Kconfig b/drivers/led/Kconfig
--- a/drivers/led/Kconfig
+++ b/drivers/led/Kconfig
@@ -77,6 +77,103 @@ config SPL_LED_GPIO
 	  This option is an SPL-variant of the LED_GPIO option.
 	  See the help of LED_GPIO for details.
 
+config LED_LGM_SSO
+	bool "Enable LED driver for Lightning mountain using SSO interface"
+	depends on LIGHTNING_MOUNTAIN_SOC
+	help
+	  This driver uses the SSO interface to operate on the LED
+	  functionalities.
+
+config LGM_SSO_PORT
+	int "LED on SSO connected to Port 0/1"
+	default 0
+	depends on LED_LGM_SSO
+	help
+	  Which SSO port are the LEDs connected to
+
+menu "Lightning Mountain LED configurations"
+	depends on LED_LGM_SSO
+
+config LGM_SSO_LED_DUTY_CYCLE
+	int "LED_DUTY_CYCLE 0-255"
+	default 255
+	help
+	  Defines the LED duty cycle
+
+config LGM_SSO_LED1_PIN
+	bool "Support LED_1 SSO pin"
+	help
+	  Defines the pin connected to LED1
+
+config LGM_SSO_LED1_PIN_NO
+	int "LED_1 pin value"
+	depends on LGM_SSO_LED1_PIN
+
+config LGM_SSO_LED2_PIN
+	bool "Support LED_2 SSO pin"
+	help
+	  Defines the pin connected to LED2
+
+config LGM_SSO_LED2_PIN_NO
+	int "LED_2 pin value"
+	depends on LGM_SSO_LED2_PIN
+
+config LGM_SSO_LED3_PIN
+	bool "Support LED_3 SSO pin"
+	help
+	  Defines the pin connected to LED3
+
+config LGM_SSO_LED3_PIN_NO
+	int "LED_3 pin value"
+	depends on LGM_SSO_LED3_PIN
+
+config LGM_SSO_LED4_PIN
+	bool "Support LED_4 SSO pin"
+	help
+	  Defines the pin connected to LED4
+
+config LGM_SSO_LED4_PIN_NO
+	int "LED_4 pin value"
+	depends on LGM_SSO_LED4_PIN
+
+config LGM_SSO_LED5_PIN
+	bool "Support LED_5 SSO pin"
+	help
+	  Defines the pin connected to LED5
+
+config LGM_SSO_LED5_PIN_NO
+	int "LED_5 pin value"
+	depends on LGM_SSO_LED5_PIN
+
+config LGM_SSO_BLUE_LED_PIN
+	bool "Support Blue LED on SSO pin"
+	help
+	  Defines the pin connected to the blue LED
+
+config LGM_SSO_BLUE_LED_PIN_NO
+	int "LED_BLUE pin value"
+	depends on LGM_SSO_BLUE_LED_PIN
+
+config LGM_SSO_GREEN_LED_PIN
+	bool "Support Green LED on SSO pin"
+	help
+	  Defines the pin connected to the green LED
+
+config LGM_SSO_GREEN_LED_PIN_NO
+	int "LED_GREEN pin value"
+	depends on LGM_SSO_GREEN_LED_PIN
+
+config LGM_SSO_RED_LED_PIN
+	bool "Support Red LED on SSO pin"
+	help
+	  Defines the pin connected to the red LED
+
+config LGM_SSO_RED_LED_PIN_NO
+	int "LED_RED pin value"
+	depends on LGM_SSO_RED_LED_PIN
+
+endmenu
+
 config LED_STATUS
 	bool "Enable status LED API"
 	help
diff --git a/drivers/led/Makefile b/drivers/led/Makefile
--- a/drivers/led/Makefile
+++ b/drivers/led/Makefile
@@ -9,3 +9,7 @@ obj-$(CONFIG_LED_BCM6358) += led_bcm6358
 obj-$(CONFIG_LED_BCM6858) += led_bcm6858.o
 obj-$(CONFIG_$(SPL_)LED_GPIO) += led_gpio.o
 obj-$(CONFIG_LED_CORTINA) += led_cortina.o
+
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_LED_LGM_SSO) += led_lgm.o
+endif
\ No newline at end of file
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -31,6 +31,31 @@ config TPL_MISC
 	  set of generic read, write and ioctl methods may be used to
 	  access the device.
 
+config SERIAL_SHIFT_LGM
+	bool "Enable LGM Serial Shift"
+	default y
+	help
+	  SSO controls up to 32 external LEDs.
+
+config SSO_MAX_PINS
+	int "Max number of SSO pins on board"
+	depends on SERIAL_SHIFT_LGM
+	default 32
+	help
+	  Configure this value to 8, 16, 24, 32
+
+config SERIAL_SHIFT_LGM_ENABLE_PIN
+	bool "SSO enable pin required"
+	depends on SERIAL_SHIFT_LGM
+	help
+	  Select this when a GPIO pin is required to enable the SSO
+
+config SERIAL_SHIFT_ENABLE_PIN_NO
+	int "SSO enable GPIO pin"
+	depends on SERIAL_SHIFT_LGM_ENABLE_PIN
+	help
+	  GPIO pin number connected to the SSO Enable
+
 config ALTERA_SYSID
 	bool "Altera Sysid support"
 	depends on MISC
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_CROS_EC_I2C) += cros_ec_i2c
 obj-$(CONFIG_CROS_EC_SPI) += cros_ec_spi.o
 obj-$(CONFIG_SANDBOX) += p2sb_sandbox.o p2sb_emul.o
 obj-$(CONFIG_SANDBOX) += swap_case.o
+obj-$(CONFIG_SERIAL_SHIFT_LGM) += sso_lgm.o
 endif
 
 ifdef CONFIG_$(SPL_)DM_I2C
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -536,6 +536,22 @@ config MMC_SDHCI_CADENCE
 
 	  If unsure, say N.
 
+config MMC_SDHCI_MXL
+	bool "MXL SDHCI controller support"
+	depends on DM_MMC && OF_CONTROL
+	help
+	  Support for Arasan SDHCI host controller on MXL SoCs platform
+
+config MXL_SD_CARD
+	bool "MXL SD CARD with FAT Filesystem"
+	depends on MMC_SDHCI_MXL
+		select FS_FAT
+		select FAT_WRITE
+		select CMD_FAT
+		select CMD_FS_GENERIC
+	help
+	  Support for MXL SD Card
+
 config MMC_SDHCI_AM654
 	bool "SDHCI Controller on TI's Am654 devices"
 	depends on ARCH_K3
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -58,6 +58,7 @@ obj-$(CONFIG_MMC_SDHCI_BCMSTB)		+= bcmst
 obj-$(CONFIG_MMC_SDHCI_CADENCE)		+= sdhci-cadence.o
 obj-$(CONFIG_MMC_SDHCI_AM654)		+= am654_sdhci.o
 obj-$(CONFIG_MMC_SDHCI_IPROC)		+= iproc_sdhci.o
+obj-$(CONFIG_MMC_SDHCI_MXL) 		+= mxl_sdhci.o
 obj-$(CONFIG_MMC_SDHCI_KONA)		+= kona_sdhci.o
 obj-$(CONFIG_MMC_SDHCI_MSM)		+= msm_sdhci.o
 obj-$(CONFIG_MMC_SDHCI_MV)		+= mv_sdhci.o
diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
--- a/drivers/mtd/Kconfig
+++ b/drivers/mtd/Kconfig
@@ -121,7 +121,7 @@ source "drivers/mtd/nand/Kconfig"
 config SYS_NAND_MAX_CHIPS
 	int "NAND max chips"
 	depends on MTD_RAW_NAND || CMD_ONENAND || TARGET_S5PC210_UNIVERSAL || \
-		SPL_OMAP3_ID_NAND
+		SPL_OMAP3_ID_NAND || MTD_SPI_NAND
 	default 1
 	help
 	  The maximum number of NAND chips per device to be supported.
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -37,5 +37,5 @@ obj-$(CONFIG_$(SPL_TPL_)NAND_SUPPORT) +=
 obj-$(CONFIG_SPL_ONENAND_SUPPORT) += onenand/
 obj-$(CONFIG_$(SPL_TPL_)SPI_FLASH_SUPPORT) += spi/
 obj-$(CONFIG_SPL_UBI) += ubispl/
-
+obj-$(CONFIG_MXL_SPI_NAND) += nand/
 endif
diff --git a/drivers/mtd/mtd_uboot.c b/drivers/mtd/mtd_uboot.c
--- a/drivers/mtd/mtd_uboot.c
+++ b/drivers/mtd/mtd_uboot.c
@@ -16,7 +16,7 @@
 #include <asm/global_data.h>
 #include <mtd.h>
 
-#define MTD_NAME_MAX_LEN 20
+#define MTD_NAME_MAX_LEN 30
 
 void board_mtdparts_default(const char **mtdids, const char **mtdparts);
 
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -7,4 +7,6 @@ obj-$(CONFIG_MTD_RAW_NAND) += raw/
 obj-$(CONFIG_MTD_SPI_NAND) += spi/
 else
 obj-$(CONFIG_$(SPL_TPL_)NAND_SUPPORT) += raw/
+obj-$(CONFIG_MXL_SPI_NAND) += spi/
+obj-$(CONFIG_MXL_SPI_NAND) += core.o bbt.o
 endif
diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -475,11 +475,91 @@ config ROCKCHIP_NAND
 	    NFC v800: RK3308, RV1108
 	    NFC v900: PX30, RK3326
 
+config NAND_FLASH_MXL
+	bool "MXL CHD support for NAND Flash"
+	help
+	  This enables NAND driver support for CHD SoC NAND flash controller.
+
+choice
+	prompt "NAND INTERFACE"
+	depends on NAND_FLASH_MXL
+
+config NAND_EBU_MXL
+	bool "Parallel EBU controller NAND driver"
+
+config NAND_EBU_MXL_16BIT
+	bool "Support 16-bit NAND interface Interface"
+	depends on NAND_EBU_MXL
+	help
+	  This configure the controller to support 16-bit interface.
+
+endchoice
+
+choice
+	prompt "ECC-mechanism"
+	depends on NAND_EBU_MXL
+
+config MXL_HW_BCH
+	bool "Use Hardware BCH controller"
+	help
+	  This enables the us of the hardware ECC of the
+	  EBU controller
+
+config MXL_EBU_BENAND
+	bool "Use ECC-enabled NAND flash"
+	help
+	  This uses the controller without any ECC.
+
+endchoice
+
+choice
+	prompt "BCH ECC Strength configuration"
+	depends on MXL_HW_BCH
+
+config 1BITS_BCH_ECC
+	bool "Support for 1-bits/512bytes BCH"
+
+config 4BITS_BCH_ECC
+	bool "Support for 4-bits/512bytes BCH"
+
+config 8BITS_BCH_ECC
+	bool "Support for 8-bits/512bytes BCH"
+
+config 24BITS_BCH_ECC
+	bool "Support for 24-bits/1024bytes BCH"
+
+config 32BITS_BCH_ECC
+	bool "Support for 32-bits/1024bytes BCH"
+
+config 40BITS_BCH_ECC
+	bool "Support for 40-bits/1024bytes BCH"
+
+config 60BITS_BCH_ECC
+	bool "Support for 60-bits/1024bytes BCH"
+
+endchoice
+
+config BCH_ECC_STRENGTH
+	int
+	default "1" if 1BITS_BCH_ECC
+	default "2" if 4BITS_BCH_ECC
+	default "3" if 8BITS_BCH_ECC
+	default "4" if 24BITS_BCH_ECC
+	default "5" if 32BITS_BCH_ECC
+	default "6" if 40BITS_BCH_ECC
+	default "7" if 60BITS_BCH_ECC
+
+config LGM_C0_ADEP_ENDIAN_RESOLVED
+	bool "To disable the ADEP/ENDIAN issue"
+	help
+	  Select this to disable the ADEP/Endian issue workaround
+	  in C-step	
+
 comment "Generic NAND options"
 
 config SYS_NAND_BLOCK_SIZE
 	hex "NAND chip eraseblock size"
-	depends on ARCH_SUNXI || SPL_NAND_SUPPORT || TPL_NAND_SUPPORT
+	depends on NAND_EBU_MXL || ARCH_SUNXI || SPL_NAND_SUPPORT || TPL_NAND_SUPPORT
 	depends on !NAND_MXS && !NAND_DENALI_DT && !NAND_LPC32XX_MLC && !NAND_FSL_IFC
 	help
 	  Number of data bytes in one eraseblock for the NAND chip on the
@@ -502,7 +582,7 @@ config SYS_NAND_PAGE_COUNT
 
 config SYS_NAND_PAGE_SIZE
 	hex "NAND chip page size"
-	depends on ARCH_SUNXI || NAND_OMAP_GPMC || NAND_LPC32XX_SLC || \
+	depends on NAND_EBU_MXL || ARCH_SUNXI || NAND_OMAP_GPMC || NAND_LPC32XX_SLC || \
 		SPL_NAND_SIMPLE || (NAND_MXC && SPL_NAND_SUPPORT) || \
 		(NAND_ATMEL && SPL_NAND_SUPPORT) || SPL_GENERATE_ATMEL_PMECC_HEADER
 	depends on !NAND_MXS && !NAND_DENALI_DT && !NAND_LPC32XX_MLC
@@ -512,7 +592,7 @@ config SYS_NAND_PAGE_SIZE
 
 config SYS_NAND_OOBSIZE
 	hex "NAND chip OOB size"
-	depends on ARCH_SUNXI || NAND_OMAP_GPMC || NAND_LPC32XX_SLC || \
+	depends on NAND_EBU_MXL || ARCH_SUNXI || NAND_OMAP_GPMC || NAND_LPC32XX_SLC || \
 		SPL_NAND_SIMPLE || (NAND_MXC && SPL_NAND_SUPPORT) || \
 		(NAND_ATMEL && SPL_NAND_SUPPORT) || SPL_GENERATE_ATMEL_PMECC_HEADER
 	depends on !NAND_MXS && !NAND_DENALI_DT && !NAND_LPC32XX_MLC
diff --git a/drivers/mtd/nand/raw/Makefile b/drivers/mtd/nand/raw/Makefile
--- a/drivers/mtd/nand/raw/Makefile
+++ b/drivers/mtd/nand/raw/Makefile
@@ -57,6 +57,7 @@ obj-$(CONFIG_NAND_LPC32XX_SLC) += lpc32x
 obj-$(CONFIG_NAND_VF610_NFC) += vf610_nfc.o
 obj-$(CONFIG_NAND_MXC) += mxc_nand.o
 obj-$(CONFIG_NAND_MXS) += mxs_nand.o
+obj-$(CONFIG_NAND_EBU_MXL) += mxl_ebu_nand.o
 obj-$(CONFIG_NAND_MXS_DT) += mxs_nand_dt.o
 obj-$(CONFIG_NAND_OCTEONTX) += octeontx_nand.o
 obj-$(CONFIG_NAND_OCTEONTX_HW_ECC) += octeontx_bch.o
diff --git a/drivers/mtd/nand/spi/Kconfig b/drivers/mtd/nand/spi/Kconfig
--- a/drivers/mtd/nand/spi/Kconfig
+++ b/drivers/mtd/nand/spi/Kconfig
@@ -5,3 +5,39 @@ menuconfig MTD_SPI_NAND
 	select SPI_MEM
 	help
 	  This is the framework for the SPI NAND device drivers.
+
+config MXL_SPI_NAND
+	bool "MXL Serial (SPI/QSPI) NAND driver"
+	select MXL_QSPI
+	help
+	  Enable MXL SPI NAND flash platforms.
+
+config QSPI_QUAD_MODE
+	depends on MXL_SPI_NAND
+	bool "Use QSPI controller in QUAD I/O mode"
+	default n
+	help
+	  Force the controller to use QUAD IO instead of
+	  Single IO (must be supported by the flash)
+
+config SYS_NAND_BLOCK_SIZE
+	hex "NAND chip eraseblock size"
+	depends on MXL_SPI_NAND
+	help
+	  Number of data bytes in one eraseblock for the NAND chip on the
+	  board. This is the multiple of NAND_PAGE_SIZE and the number of
+	  pages.
+
+config SYS_NAND_PAGE_SIZE
+	hex "NAND chip page size"
+	depends on MXL_SPI_NAND
+	help
+	  Number of data bytes in one page for the NAND chip on the
+	  board, not including the OOB area.
+
+config RAW_NAND_OOB_COMPATIBLE
+	bool "OOB layout compatible with RAW NAND flash"
+	help
+	  This allows the SPI NAND to use the same OOB layout
+	  as the RAW flash, without hiding the first bytes of the
+	  OOB area.
diff --git a/drivers/mtd/nand/spi/Makefile b/drivers/mtd/nand/spi/Makefile
--- a/drivers/mtd/nand/spi/Makefile
+++ b/drivers/mtd/nand/spi/Makefile
@@ -2,3 +2,4 @@
 
 spinand-objs := core.o gigadevice.o macronix.o micron.o toshiba.o winbond.o
 obj-$(CONFIG_MTD_SPI_NAND) += spinand.o
+obj-$(CONFIG_MXL_SPI_NAND) += mxl_spi_nand.o
\ No newline at end of file
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -849,4 +849,192 @@ config MDIO_MUX_MESON_G12A
 	  This driver is used for the MDIO mux found on the Amlogic G12A & compatible
 	  SoCs.
 
+config LIGHTNING_MOUNTAIN_ETH
+	bool "Lightning Mountain Ethernet Support"
+	select MII
+	select PHYLIB
+	depends on DRIVER_LIGHTNING
+
+config OCTOPUS_I2C_CONTROL_PCIE
+	bool "Use I2C control pcie card on octopus"
+	depends on LIGHTNING_MOUNTAIN_ETH
+	default n
+
+config LGM_P34X_SUPPORT
+	bool "Use P34X Internal PHY"
+	depends on LIGHTNING_MOUNTAIN_ETH
+	default y
+
+config EXTERNAL_P34X_ATTACHED
+	bool "P34X is external to the SOC"
+	depends on LGM_P34X_SUPPORT
+	help
+	  For some LGM SOCs, the P34X is attached outside of the
+	  SOC and firmware loading for such design is not needed.
+
+config LGM_GPHY_FW_SIZE
+	hex "GPHY FW pad size after lzma"
+	default "0x10000"
+	depends on ( LGM_P34X_SUPPORT && !EXTERNAL_P34X_ATTACHED )
+
+config GPHY_LED_INV_VALUE
+	hex "GPHY LED control register INV value for bitfield 14 to 12"
+	default "0x0"
+	depends on LGM_P34X_SUPPORT
+
+menu "Ports Auto Negotation Caps for P34X GPHY"
+	depends on LGM_P34X_SUPPORT
+
+config LGM_P34X_P1_25G_OFF
+	bool "Port 1 Disable >= 2.5G BASE-T Ads"
+	default n
+	depends on LGM_P34X_SUPPORT
+        help
+          Auto Negation advertisements caps for Port 1.
+          1G will be on, and the rests are off.
+          - 1G BASE-T ON
+          - 2.5G BASE-T OFF
+          - 5G BASE=T OFF
+          potentially even above 5G BASE-T, so only 1G is advertised
+
+config LGM_P34X_P2_25G_OFF
+	bool "Port 2 Disable >= 2.5G BASE-T Ads"
+	default n
+	depends on LGM_P34X_SUPPORT
+        help
+          Auto Negation advertisements caps for Port 2.
+          1G will be on, and the rests are off.
+          - 1G BASE-T ON
+          - 2.5G BASE-T OFF
+          - 5G BASE=T OFF
+          potentially even above 5G BASE-T, so only 1G is advertised
+
+config LGM_P34X_P3_25G_OFF
+	bool "Port 3 Disable >= 2.5G BASE-T Ads"
+	default n
+	depends on LGM_P34X_SUPPORT
+        help
+          Auto Negation advertisements caps for Port 3.
+          1G will be on, and the rests are off.
+          - 1G BASE-T ON
+          - 2.5G BASE-T OFF
+          - 5G BASE=T OFF
+          potentially even above 5G BASE-T, so only 1G is advertised
+
+config LGM_P34X_P4_25G_OFF
+	bool "Port 4 Disable >= 2.5G BASE-T Ads"
+	default n
+	depends on LGM_P34X_SUPPORT
+        help
+          Auto Negation advertisements caps for Port 4.
+          1G will be on, and the rests are off.
+          - 1G BASE-T ON
+          - 2.5G BASE-T OFF
+          - 5G BASE=T OFF
+          potentially even above 5G BASE-T, so only 1G is advertised
+
+endmenu
+
+config XPCS5_USXGMII_RTL8261
+	bool "Use XPCS5 USXGMII connect to RTL8261"
+	depends on ( LIGHTNING_MOUNTAIN_ETH && !LGM_P34X_SUPPORT )
+	default n
+
+config LAN_HSIO_R
+	bool "Use XPCS on HSIO-R bus"
+	depends on ( LIGHTNING_MOUNTAIN_ETH && !LGM_P34X_SUPPORT )
+	default y
+
+choice
+    prompt "LAN1_HSIO_R Speed"
+    depends on LAN_HSIO_R
+
+config LAN_HSIO_R_XFI_10G_KR_NO_ANEG
+    bool "LAN_HSIO_R_XFI_10G_KR_NO_ANEG"
+
+config LAN_HSIO_R_USXGMII_10G
+	bool "Use USXGMII ON PORT20, LAN PORT"
+	depends on ( LAN_HSIO_R_XFI_10G_KR_NO_ANEG )
+	default n
+
+config LAN_HSIO_R_SGMII_1G
+    bool "LAN_HSIO_R_SGMII_1G"
+
+config LAN_HSIO_R_SGMII_2500BASEX
+    bool "LAN_HSIO_R_SGMII_2500BASEX"
+endchoice
+
+config LAN_HSIO_L
+	bool "Use XPCS on HSIO-L bus"
+	depends on ( LIGHTNING_MOUNTAIN_ETH && !LGM_P34X_SUPPORT )
+	default n
+
+choice
+    prompt "LAN0_HSIO_L Speed"
+    depends on LAN_HSIO_L
+
+config LAN_HSIO_L_XFI_10G_KR_NO_ANEG
+    bool "LAN_HSIO_L_XFI_10G_KR_NO_ANEG"
+
+config LAN_HSIO_L_SGMII_1G
+    bool "LAN_HSIO_L_SGMII_1G"
+
+config LAN_HSIO_L_SGMII_2500BASEX
+    bool "LAN_HSIO_L_SGMII_2500BASEX"
+
+endchoice
+
+config WAN_XPCS
+	bool "Use WAN XPCS"
+	depends on ( LIGHTNING_MOUNTAIN_ETH && !LGM_P34X_SUPPORT )
+	default n
+
+
+config WAN_SFP
+	bool "WAN_SFP"
+	depends on WAN_XPCS
+	default n
+
+choice
+	prompt "WAN Speed"
+	depends on WAN_XPCS
+
+config XFI_10G_KR_NO_ANEG
+	bool "XFI_10G_KR_NO_ANEG"
+
+config WAN_XPCS_XFI_10G_KR_NO_ANEG_USXGMII_10G
+	bool "Use USXGMII ON XPCS4, WAN PORT"
+	depends on ( WAN_XPCS && XFI_10G_KR_NO_ANEG )
+	default n
+
+config SGMII_1000BASEX
+	bool "SGMII_1000BASEX"
+
+config SGMII_1G
+	bool "SGMII_1G"
+endchoice
+
+config LGMC_SGMII
+	bool "lgmc sgmii settings"
+	depends on ( LIGHTNING_MOUNTAIN_ETH && !LGM_P34X_SUPPORT )
+	default n
+
+choice
+	prompt "SGMII Connection"
+	depends on LGMC_SGMII
+config HSIO2_XPCS1_HSIO4_PHY0_C10
+	bool "(HSIOR)HSIO2_XPCS1_HSIO4_PHY0_C10"
+config HSIO1_XPCS1_HSIO3_PHY0_C10
+	bool "(HSIOL)HSIO1_XPCS1_HSIO3_PHY0_C10"
+endchoice
+
+choice
+	prompt "SGMII Speed"
+	depends on LGMC_SGMII
+config LGMC_SGMII_2G5
+	bool "LGMC_SGMII_2G5"
+config LGMC_SGMII_1G
+	bool "LGMC_SGMII_1G"
+endchoice
+
 endif # NETDEVICES
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -5,6 +5,7 @@
 
 obj-y += phy/
 
+obj-$(CONFIG_OCTOPUS_I2C_CONTROL_PCIE)	+= mxl3710_aic.o
 obj-$(CONFIG_ALTERA_TSE) += altera_tse.o
 obj-$(CONFIG_AG7XXX) += ag7xxx.o
 obj-$(CONFIG_ARMADA100_FEC) += armada100_fec.o
@@ -101,3 +102,5 @@ obj-$(CONFIG_HIGMACV300_ETH) += higmacv3
 obj-$(CONFIG_MDIO_SANDBOX) += mdio_sandbox.o
 obj-$(CONFIG_FSL_ENETC) += fsl_enetc.o fsl_enetc_mdio.o
 obj-$(CONFIG_FSL_LS_MDIO) += fsl_ls_mdio.o
+obj-$(CONFIG_LIGHTNING_MOUNTAIN_ETH) += lightning_mountain_sw.o \
+		lightning_mountain_xpcs.o lightning_mountain_combophy.o
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -722,6 +722,13 @@ config INTEL_MID_SERIAL
 	  Select this to enable a UART for Intel MID platforms.
 	  This uses the ns16550 driver as a library.
 
+config MXL_SERIAL
+	bool "MaxLinear SoC - UART (ASC) support"
+	depends on DM_SERIAL
+	help
+	  If you have MaxLinear LGM SoC based board and want to use the ASC (UART)
+	  serial ports, say Y to this option. If unsure, say N.
+
 config PL011_SERIAL
 	bool "ARM PL011 driver"
 	depends on !DM_SERIAL
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -75,6 +75,7 @@ obj-$(CONFIG_MTK_SERIAL) += serial_mtk.o
 obj-$(CONFIG_MT7620_SERIAL) += serial_mt7620.o
 obj-$(CONFIG_SIFIVE_SERIAL) += serial_sifive.o
 obj-$(CONFIG_XEN_SERIAL) += serial_xen.o
+obj-$(CONFIG_MXL_SERIAL) += serial_mxl.o
 
 ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_USB_TTY) += usbtty.o
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -121,6 +121,13 @@ config CADENCE_QSPI
 	  used to access the SPI NOR flash on platforms embedding this
 	  Cadence IP core.
 
+config MXL_QSPI
+	bool "MXL - Cadence QSPI driver"
+	help
+	  Enable the Cadence Quad-SPI (QSPI) driver. This driver can be
+	  used to access the SPI NOR flash on platforms embedding this
+	  Cadence IP core.
+
 config CF_SPI
         bool "ColdFire SPI driver"
         help
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -7,6 +7,7 @@
 ifdef CONFIG_$(SPL_TPL_)DM_SPI
 obj-y += spi-uclass.o
 obj-$(CONFIG_CADENCE_QSPI) += cadence_qspi.o cadence_qspi_apb.o
+obj-$(CONFIG_MXL_QSPI) += mxl_qspi.o mxl_qspi_apb.o
 obj-$(CONFIG_SANDBOX) += spi-emul-uclass.o
 obj-$(CONFIG_SOFT_SPI) += soft_spi.o
 obj-$(CONFIG_SPI_MEM) += spi-mem.o
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -6,6 +6,9 @@ config DM_THERMAL
 	  automatic power-off when the temperature gets too high or low. Other
 	  devices may be discrete but connected on a suitable bus.
 
+config LGM_THERMAL
+	bool "Lightning Mountain thermal driver"
+
 if DM_THERMAL
 
 config IMX_THERMAL
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -8,3 +8,7 @@ obj-$(CONFIG_IMX_THERMAL) += imx_thermal
 obj-$(CONFIG_IMX_SCU_THERMAL) += imx_scu_thermal.o
 obj-$(CONFIG_TI_DRA7_THERMAL) += ti-bandgap.o
 obj-$(CONFIG_IMX_TMU) += imx_tmu.o
+
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_LGM_THERMAL) += lgm_thermal.o
+endif
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -114,6 +114,13 @@ config USB_XHCI_BRCM
 	  USB controller based on the Broadcom USB3 IP Core.
 	  Supports USB2/3 functionality.
 
+config USB_XHCI_MXL
+	bool "Maxlinear USB3 Host XHCI controller"
+	depends on DM_USB
+	help
+	  USB controller based on the Maxlinear USB3 IP Core.
+	  Supports USB2/3 functionality.
+
 endif # USB_XHCI_HCD
 
 config USB_EHCI_HCD
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -47,6 +47,7 @@ obj-$(CONFIG_USB_XHCI_BRCM) += xhci-brcm
 obj-$(CONFIG_USB_XHCI_HCD) += xhci.o xhci-mem.o xhci-ring.o
 obj-$(CONFIG_USB_XHCI_DWC3) += xhci-dwc3.o
 obj-$(CONFIG_USB_XHCI_DWC3_OF_SIMPLE) += dwc3-of-simple.o
+obj-$(CONFIG_USB_XHCI_MXL) += xhci-dwc3-mxl.o
 obj-$(CONFIG_USB_XHCI_EXYNOS) += xhci-exynos5.o
 obj-$(CONFIG_USB_XHCI_FSL) += xhci-fsl.o
 obj-$(CONFIG_USB_XHCI_MTK) += xhci-mtk.o
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -158,6 +158,13 @@ config WDT_GPIO
 	  doc/device-tree-bindings/watchdog/gpio-wdt.txt for
 	  information on how to describe the watchdog in device tree.
 
+config WDT_LGM
+        bool "Lightning watchdog timer support"
+        depends on WDT && DRIVER_LIGHTNING
+        help
+          Select this to enable lightning watchdog timer
+        default n
+
 config WDT_MPC8xx
 	bool "MPC8xx watchdog timer support"
 	depends on WDT && MPC8xx
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -39,3 +39,4 @@ obj-$(CONFIG_WDT_STM32MP) += stm32mp_wdt
 obj-$(CONFIG_WDT_SUNXI) += sunxi_wdt.o
 obj-$(CONFIG_WDT_TANGIER) += tangier_wdt.o
 obj-$(CONFIG_WDT_XILINX) += xilinx_wwdt.o
+obj-$(CONFIG_WDT_LGM) += lgm_wdt.o
\ No newline at end of file
diff --git a/include/image.h b/include/image.h
--- a/include/image.h
+++ b/include/image.h
@@ -37,6 +37,8 @@ struct fdt_region;
 #include <linker_lists.h>
 
 #define IMAGE_INDENT_STRING	"   "
+#define IMAGE_ENABLE_MXL_MD		0
+#define MXL_MD_IH_MULTI_NAME	"URX Linux Kernel Container"
 
 #endif /* USE_HOSTCC */
 
@@ -48,6 +50,7 @@ struct fdt_region;
 extern ulong image_load_addr;		/* Default Load Address */
 extern ulong image_save_addr;		/* Default Save Address */
 extern ulong image_save_size;		/* Default Save Size */
+extern ulong image_load_offset;	/* Default Load Address Offset */
 
 /* An invalid size, meaning that the image size is not known */
 #define IMAGE_SIZE_INVAL	(-1UL)
@@ -215,6 +218,14 @@ enum {
 	IH_TYPE_ZYNQIMAGE,		/* Xilinx Zynq Boot Image */
 	IH_TYPE_ZYNQMPIMAGE,		/* Xilinx ZynqMP Boot Image */
 	IH_TYPE_ZYNQMPBIF,		/* Xilinx ZynqMP Boot Image (bif) */
+#if defined(CONFIG_VENDOR_MAXLINEAR)
+	/* Need to make it backward compatible to the
+	 * older versions of MXL U-boot.
+	 */
+	IH_TYPE_UBOOT,			/* U-Boot Image */
+	IH_TYPE_UBOOTENV,		/* MXL uboot environment image */
+	IH_TYPE_SYSTEMSW,		/* MXL ubinized image */
+#endif
 	IH_TYPE_FPGA,			/* FPGA Image */
 	IH_TYPE_VYBRIDIMAGE,	/* VYBRID .vyb Image */
 	IH_TYPE_TEE,            /* Trusted Execution Environment OS Image */
@@ -350,6 +361,7 @@ typedef struct bootm_headers {
 #define	BOOTM_STATE_OS_PREP	(0x00000100)
 #define	BOOTM_STATE_OS_FAKE_GO	(0x00000200)	/* 'Almost' run the OS */
 #define	BOOTM_STATE_OS_GO	(0x00000400)
+#define	BOOTM_STATE_PRE_LOAD	0x00000800
 	int		state;
 
 #if defined(CONFIG_LMB) && !defined(USE_HOSTCC)
@@ -566,6 +578,9 @@ int boot_get_ramdisk(int argc, char *con
 int boot_get_loadable(int argc, char *const argv[], bootm_headers_t *images,
 		      uint8_t arch, const ulong *ld_start, ulong *const ld_len);
 
+int boot_get_mxl_md(int argc, char * const argv[], bootm_headers_t *images,
+		      uint8_t arch, ulong *ro_start, ulong *ro_end);
+
 int boot_get_setup_fit(bootm_headers_t *images, uint8_t arch,
 		       ulong *setup_start, ulong *setup_len);
 
@@ -799,7 +814,8 @@ static inline int image_check_arch(const
 	if (!tools_build() && IS_ENABLED(CONFIG_SANDBOX))
 		return true;
 	return (image_get_arch(hdr) == arch) ||
-		(image_get_arch(hdr) == IH_ARCH_ARM && arch == IH_ARCH_ARM64);
+		(image_get_arch(hdr) == IH_ARCH_ARM && arch == IH_ARCH_ARM64) ||
+		(image_get_arch(hdr) == IH_ARCH_X86_64 && arch == IH_ARCH_I386);
 }
 static inline int image_check_os(const image_header_t *hdr, uint8_t os)
 {
@@ -1017,6 +1033,21 @@ int fit_image_hash_get_value(const void 
 
 int fit_set_timestamp(void *fit, int noffset, time_t timestamp);
 
+/**
+ * fit_pre_load_data() - add public key to fdt blob
+ *
+ * Adds public key to the node pre load.
+ *
+ * @keydir:	Directory containing keys
+ * @keydest:	FDT blob to write public key
+ * @fit:	Pointer to the FIT format image header
+ *
+ * returns:
+ *	0, on success
+ *	< 0, on failure
+ */
+int fit_pre_load_data(const char *keydir, void *keydest, void *fit);
+
 int fit_cipher_data(const char *keydir, void *keydest, void *fit,
 		    const char *comment, int require_keys,
 		    const char *engine_id, const char *cmdname);
@@ -1289,6 +1320,62 @@ struct crypto_algo *image_get_crypto_alg
  */
 struct padding_algo *image_get_padding_algo(const char *name);
 
+#define IMAGE_PRE_LOAD_SIG_MAGIC               0x55425348
+#define IMAGE_PRE_LOAD_SIG_OFFSET_MAGIC                0
+#define IMAGE_PRE_LOAD_SIG_OFFSET_IMG_LEN      4
+#define IMAGE_PRE_LOAD_SIG_OFFSET_SIG          8
+
+#define IMAGE_PRE_LOAD_PATH                    "/image/pre-load/sig"
+#define IMAGE_PRE_LOAD_PROP_ALGO_NAME          "algo-name"
+#define IMAGE_PRE_LOAD_PROP_PADDING_NAME       "padding-name"
+#define IMAGE_PRE_LOAD_PROP_SIG_SIZE           "signature-size"
+#define IMAGE_PRE_LOAD_PROP_PUBLIC_KEY         "public-key"
+#define IMAGE_PRE_LOAD_PROP_MANDATORY          "mandatory"
+
+/*
+* Information in the device-tree about the signature in the header
+*/
+struct image_sig_info {
+	char *algo_name;        /* Name of the algo (eg: sha256,rsa2048) */
+	char *padding_name;     /* Name of the padding */
+	uint8_t *key;           /* Public signature key */
+	int key_len;            /* Length of the public key */
+	uint32_t sig_size;              /* size of the signature (in the header) */
+	int mandatory;          /* Set if the signature is mandatory */
+
+	struct image_sign_info sig_info; /* Signature info */
+};
+
+/*
+* Header of the signature header
+*/
+struct sig_header_s {
+	uint32_t magic;
+	uint32_t version;
+	uint32_t header_size;
+	uint32_t image_size;
+	uint32_t offset_img_sig;
+	uint32_t flags;
+	uint32_t reserved0;
+	uint32_t reserved1;
+	uint8_t sha256_img_sig[SHA256_SUM_LEN];
+};
+
+#define SIG_HEADER_LEN                 (sizeof(struct sig_header_s))
+
+/**
+ * image_pre_load() - Manage pre load header
+ *
+ * Manage the pre-load header before launching the image.
+ * It checks the signature of the image. It also set the
+ * variable image_load_offset to skip this header before
+ * launching the image.
+ *
+ * @param addr		Address of the image
+ * @return: 0 on success, -ve on error
+ */
+int image_pre_load(ulong addr);
+
 /**
  * fit_image_verify_required_sigs() - Verify signatures marked as 'required'
  *
diff --git a/include/linux/printk.h b/include/linux/printk.h
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -15,6 +15,13 @@
 #define KERN_DEBUG
 #define KERN_CONT
 
+#ifdef CONFIG_DEBUG_SIMPLIFY
+#define rbe_debug_print(fmt, ...)
+#else
+#define rbe_debug_print(fmt, ...)	\
+		printk(fmt, ##__VA_ARGS__)
+#endif
+
 #define printk(fmt, ...) \
 	printf(fmt, ##__VA_ARGS__)
 
diff --git a/include/lmb.h b/include/lmb.h
--- a/include/lmb.h
+++ b/include/lmb.h
@@ -6,6 +6,14 @@
 #include <asm/types.h>
 #include <asm/u-boot.h>
 
+#ifndef CONFIG_LMB_RESERVED_REGIONS
+#define CONFIG_LMB_RESERVED_REGIONS 8
+#endif
+
+#ifndef CONFIG_LMB_MEMORY_REGIONS
+#define CONFIG_LMB_MEMORY_REGIONS 8
+#endif
+
 /*
  * Logical memory blocks.
  *
diff --git a/include/nand.h b/include/nand.h
--- a/include/nand.h
+++ b/include/nand.h
@@ -111,6 +111,8 @@ int nand_torture(struct mtd_info *mtd, l
 int nand_verify_page_oob(struct mtd_info *mtd, struct mtd_oob_ops *ops,
 			 loff_t ofs);
 int nand_verify(struct mtd_info *mtd, loff_t ofs, size_t len, u_char *buf);
+int nand_write_partial (struct mtd_info *mtd, loff_t offset,
+			uint64_t len, uint64_t *retlen, const u_char * buf);
 
 #define NAND_LOCK_STATUS_TIGHT	0x01
 #define NAND_LOCK_STATUS_UNLOCK 0x04
diff --git a/include/part.h b/include/part.h
--- a/include/part.h
+++ b/include/part.h
@@ -294,7 +294,8 @@ part_get_info_by_dev_and_name_or_num(con
 #ifdef CONFIG_SPL_BUILD
 # define part_print_ptr(x)	NULL
 # if defined(CONFIG_SPL_FS_EXT4) || defined(CONFIG_SPL_FS_FAT) || \
-	defined(CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION)
+	defined(CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION) || \
+	defined(CONFIG_BOOT_FROM_EMMC)
 #  define part_get_info_ptr(x)	x
 # else
 #  define part_get_info_ptr(x)	NULL
@@ -434,6 +435,16 @@ int gpt_verify_headers(struct blk_desc *
 		       gpt_entry **gpt_pte);
 
 /**
+ * gpt_repair_headers() - Function to repair the GPT's header
+ *                        and partition table entries (PTE)
+ *
+ * @param dev_desc - block device descriptor
+ *
+ * Return: - '0' on success, otherwise error
+ */
+int gpt_repair_headers(struct blk_desc *dev_desc);
+
+/**
  * gpt_verify_partitions() - Function to check if partitions' name, start and
  *                           size correspond to '$partitions' env variable
  *
@@ -517,6 +528,11 @@ static inline struct part_driver *part_d
 	return ll_entry_start(struct part_driver, part_driver);
 }
 
+/* From partition defintion, retrieve start/end/blkstart/blkend addr
+ * and export it to the env.
+*/
+int build_gpt_table(const char *partitions, unsigned long num_partitions);
+
 #else
 static inline int part_driver_get_count(void)
 { return 0; }
diff --git a/lib/Makefile b/lib/Makefile
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -17,8 +17,6 @@ obj-$(CONFIG_OF_LIVE) += of_live.o
 obj-$(CONFIG_CMD_DHRYSTONE) += dhry/
 obj-$(CONFIG_ARCH_AT91) += at91/
 obj-$(CONFIG_OPTEE_LIB) += optee/
-obj-$(CONFIG_ASN1_DECODER) += asn1_decoder.o
-obj-y += crypto/
 
 obj-$(CONFIG_AES) += aes.o
 obj-$(CONFIG_AES) += aes/
@@ -58,6 +56,8 @@ obj-$(CONFIG_TPM_V1) += tpm-v1.o
 obj-$(CONFIG_TPM_V2) += tpm-v2.o
 endif
 
+obj-y += crypto/ 
+
 obj-$(CONFIG_$(SPL_)ACPIGEN) += acpi/
 obj-$(CONFIG_$(SPL_)MD5) += md5.o
 obj-$(CONFIG_ECDSA) += ecdsa/
@@ -67,6 +67,7 @@ obj-$(CONFIG_SHA1) += sha1.o
 obj-$(CONFIG_SHA256) += sha256.o
 obj-$(CONFIG_SHA512) += sha512.o
 obj-$(CONFIG_CRYPT_PW) += crypt/
+obj-$(CONFIG_$(SPL_)ASN1_DECODER) += asn1_decoder.o
 
 obj-$(CONFIG_$(SPL_)ZLIB) += zlib/
 obj-$(CONFIG_$(SPL_)ZSTD) += zstd/
@@ -87,6 +88,11 @@ obj-$(CONFIG_SPL_YMODEM_SUPPORT) += crc1
 obj-$(CONFIG_$(SPL_TPL_)HASH) += crc16.o
 obj-$(CONFIG_MMC_SPI_CRC_ON) += crc16.o
 obj-y += net_utils.o
+ifndef CONFIG_NAND_BOOT
+obj-$(CONFIG_LANTIQ) += bootstrap/
+endif
+obj-$(CONFIG_VENDOR_MAXLINEAR) += bootstrap/LzmaDecode.o 
+obj-$(CONFIG_VENDOR_MAXLINEAR) += bootstrap/LzmaWrapper.o
 endif
 obj-$(CONFIG_ADDR_MAP) += addr_map.o
 obj-y += qsort.o
@@ -128,9 +134,9 @@ obj-$(CONFIG_$(SPL_TPL_)STRTO) += strto.
 else
 # Main U-Boot always uses the full printf support
 obj-y += vsprintf.o strto.o
-obj-$(CONFIG_OID_REGISTRY) += oid_registry.o
 obj-$(CONFIG_SSCANF) += sscanf.o
 endif
+obj-$(CONFIG_$(SPL_)OID_REGISTRY) += oid_registry.o
 
 obj-y += abuf.o
 obj-y += date.o
diff --git a/net/net.c b/net/net.c
--- a/net/net.c
+++ b/net/net.c
@@ -1210,7 +1210,7 @@ void net_process_received_packet(uchar *
 			return;
 		/* Check the Checksum of the header */
 		if (!ip_checksum_ok((uchar *)ip, IP_HDR_SIZE)) {
-			debug("checksum bad\n");
+			printf("UDP header checksum bad.\n");
 			return;
 		}
 		/* If it is not for us, ignore it */
@@ -1293,7 +1293,7 @@ void net_process_received_packet(uchar *
 				       ((xsum >> 16) & 0x0000ffff);
 			}
 			if ((xsum != 0x00000000) && (xsum != 0x0000ffff)) {
-				printf(" UDP wrong checksum %08lx %08x\n",
+				printf("UDP data checksum bad. %08lx %08x\n",
 				       xsum, ntohs(ip->udp_xsum));
 				return;
 			}
diff --git a/scripts/Makefile.binaries b/scripts/Makefile.binaries
new file mode 100644
--- /dev/null
+++ b/scripts/Makefile.binaries
@@ -0,0 +1,165 @@
+ifeq ($(CONFIG_VENDOR_MAXLINEAR),y)
+###############################################################################
+# common placeholder for binaries name
+###############################################################################
+
+#------------------------------------------------------------------------------
+# 1. RBE extra copy with specific name
+
+# default value
+ifeq ($(CONFIG_BOOT_FROM_EMMC),y)
+RBE := spl/u-boot-spl-emmc.bin
+endif #  ($(CONFIG_BOOT_FROM_EMMC)
+ifeq ($(CONFIG_BOOT_FROM_NAND),y)
+RBE := spl/u-boot-spl-nand.bin
+endif #  ($(CONFIG_BOOT_FROM_NAND)
+ifeq ($(CONFIG_BOOT_FROM_QSPI_NOR),y)
+RBE := spl/u-boot-spl-sf.bin
+endif #  ($(CONFIG_BOOT_FROM_QSPI_NOR)
+ifeq ($(CONFIG_BOOT_FROM_QSPI_NAND),y)
+RBE := spl/u-boot-spl-nand.bin
+endif #  ($(CONFIG_BOOT_FROM_QSPI_NAND)
+
+# override if SPL_IMAGE is set
+ifneq ($(CONFIG_SPL_IMAGE),)
+ifneq ($(CONFIG_SPL_IMAGE),"")
+RBE := $(CONFIG_SPL_IMAGE:"%"=%)
+
+# force to empty or no extra copy
+#RBE :=
+
+endif # ($(CONFIG_SPL_IMAGE),"")
+endif # ($(CONFIG_SPL_IMAGE),)
+
+export RBE
+#------------------------------------------------------------------------------
+# 2. Uboot
+
+# default value
+ifeq ($(CONFIG_BOOT_FROM_EMMC),y)
+UBOOT_EXT := u-boot-emmc.bin
+endif #  ($(CONFIG_BOOT_FROM_EMMC)
+ifeq ($(CONFIG_BOOT_FROM_NAND),y)
+UBOOT_EXT := u-boot-nand.bin
+endif #  ($(CONFIG_BOOT_FROM_NAND)
+ifeq ($(CONFIG_BOOT_FROM_QSPI_NOR),y)
+UBOOT_EXT := u-boot-sf.bin
+endif #  ($(CONFIG_BOOT_FROM_QSPI_NOR)
+ifeq ($(CONFIG_BOOT_FROM_QSPI_NAND),y)
+UBOOT_EXT := u-boot-nand.bin
+endif #  ($(CONFIG_BOOT_FROM_QSPI_NAND)
+
+# override if SPL_PAYLOAD is set
+ifneq ($(CONFIG_SPL_PAYLOAD),)
+ifneq ($(CONFIG_SPL_PAYLOAD),"")
+UBOOT_EXT := $(CONFIG_SPL_PAYLOAD:"%"=%)
+
+# force to empty or no extra copy
+#UBOOT_EXT :=
+
+endif # ($(CONFIG_SPL_IMAGE),"")
+endif # ($(CONFIG_SPL_IMAGE),)
+
+ifneq ($(UBOOT_EXT),)
+INPUTS-y += $(UBOOT_EXT)
+
+# empty recipe on top makefile, created in Makefile.spl
+u-boot.lzimg: ;
+
+$(UBOOT_EXT): u-boot.lzimg spl/u-boot-spl
+	$(call if_changed,copy)
+
+endif # $(UBOOT_EXT)
+
+#------------------------------------------------------------------------------
+# 2. RBE +  UBOOT
+
+# default value
+ifeq ($(CONFIG_BOOT_FROM_EMMC),y)
+RBE_PLUS_UBOOT := u-boot-plus-spl-emmc.bin
+endif #  ($(CONFIG_BOOT_FROM_EMMC)
+ifeq ($(CONFIG_BOOT_FROM_NAND),y)
+RBE_PLUS_UBOOT := u-boot-plus-spl-nand.bin
+endif #  ($(CONFIG_BOOT_FROM_NAND)
+ifeq ($(CONFIG_BOOT_FROM_QSPI_NOR),y)
+RBE_PLUS_UBOOT := u-boot-plus-spl-sf.bin
+endif #  ($(CONFIG_BOOT_FROM_QSPI_NOR)
+ifeq ($(CONFIG_BOOT_FROM_QSPI_NAND),y)
+RBE_PLUS_UBOOT := u-boot-plus-spl-nand.bin
+endif #  ($(CONFIG_BOOT_FROM_QSPI_NAND)
+
+# override if BUILD_TARGET is set
+ifneq ($(CONFIG_BUILD_TARGET),)
+ifneq ($(CONFIG_BUILD_TARGET),"")
+RBE_PLUS_UBOOT := $(CONFIG_BUILD_TARGET:"%"=%)
+endif # ($(CONFIG_BUILD_TARGET),"")
+endif # ($(CONFIG_BUILD_TARGET),)
+
+export RBE_PLUS_UBOOT
+
+# created in Makefile.spl
+# in top Makfile over rule it as empty recipe
+ifneq ($(CONFIG_BUILD_TARGET),)
+ifneq ($(CONFIG_BUILD_TARGET),"")
+$(CONFIG_BUILD_TARGET:"%"=%): ;
+endif # ($(CONFIG_BUILD_TARGET),"")
+endif # ($(CONFIG_BUILD_TARGET),)
+
+# 4. DDR binary
+ifdef CONFIG_DDR_TUNING_SEPARATE
+DDR_TUNING := spl/ddr-binary.img
+else
+DDR_TUNING :=
+endif
+
+export DDR_TUNING
+
+#------------------------------------------------------------------------------
+# 5. compatibility before ugw 9.0 CI integration
+
+# default value
+ifeq ($(CONFIG_BOOT_FROM_EMMC),y)
+FINAL_BIN_EXTRA := u-boot-emmc.intel
+endif #  ($(CONFIG_BOOT_FROM_EMMC)
+ifeq ($(CONFIG_BOOT_FROM_NAND),y)
+FINAL_BIN_EXTRA := u-boot-nand.intel
+endif #  ($(CONFIG_BOOT_FROM_NAND)
+ifeq ($(CONFIG_BOOT_FROM_QSPI_NOR),y)
+FINAL_BIN_EXTRA := u-boot-sf.intel
+endif #  ($(CONFIG_BOOT_FROM_QSPI_NOR)
+ifeq ($(CONFIG_BOOT_FROM_QSPI_NAND),y)
+FINAL_BIN_EXTRA := u-boot-nand.intel
+endif #  ($(CONFIG_BOOT_FROM_QSPI_NAND)
+
+# force to empty or no extra copy
+FINAL_BIN_EXTRA  :=
+
+ifneq ($(FINAL_BIN_EXTRA),)
+INPUTS-y += $(FINAL_BIN_EXTRA)
+
+PHONY += $(RBE_PLUS_UBOOT)
+$(FINAL_BIN_EXTRA): $(RBE_PLUS_UBOOT) spl/u-boot-spl $(DDR_TUNING)
+	$(call if_changed,copy)
+endif # (($(FINAL_BIN_EXTRA),)
+
+###############################################################################
+# 6. recovery copy
+
+# source bin
+SRC_DFU_BIN := u-boot-recovery.bstrap
+
+# dest default value
+USB_DFU_RECOVERY := u-boot-recovery.bin
+
+# force to empty or no extra copy
+# USB_DFU_RECOVERY :=
+
+ifneq ($(USB_DFU_RECOVERY),)
+INPUTS-y += $(USB_DFU_RECOVERY)
+
+PHONY += $(SRC_DFU_BIN)
+$(USB_DFU_RECOVERY): $(SRC_DFU_BIN) spl/u-boot-spl
+	$(call if_changed,copy)
+endif # ($(USB_DFU_RECOVERY),)
+
+endif # ($(CONFIG_VENDOR_MAXLINEAR),y)
diff --git a/scripts/Makefile.spl b/scripts/Makefile.spl
--- a/scripts/Makefile.spl
+++ b/scripts/Makefile.spl
@@ -102,6 +102,10 @@ libs-$(CONFIG_PARTITIONS) += disk/
 endif
 endif
 
+ifdef CONFIG_VENDOR_MAXLINEAR
+libs-$(CONFIG_PARTITIONS) += disk/
+endif
+
 libs-y += drivers/
 libs-$(CONFIG_SPL_USB_GADGET) += drivers/usb/dwc3/
 libs-$(CONFIG_SPL_USB_GADGET) += drivers/usb/cdns3/
@@ -264,6 +268,49 @@ ifeq ($(CONFIG_SYS_SOC),"at91")
 INPUTS-y	+= $(obj)/boot.bin
 endif
 
+ifdef CONFIG_VENDOR_MAXLINEAR
+$(info ^^^ MaxLinear AnyWAN SoC U-Boot Binary Builder ^^^)
+
+ALL += $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map
+ALL-$(CONFIG_VENDOR_MAXLINEAR) += u-boot-ram.bin
+
+ALL-$(CONFIG_BOOT_FROM_SPI) += u-boot-sf.intel
+ALL-$(CONFIG_BOOT_FROM_QSPI_NOR)  += $(RBE_PLUS_UBOOT)
+ALL-$(CONFIG_BOOT_FROM_QSPI_NAND) += $(RBE_PLUS_UBOOT)
+ALL-$(CONFIG_BOOT_FROM_NAND) += $(RBE_PLUS_UBOOT)
+ALL-$(CONFIG_BOOT_FROM_EMMC) += $(RBE_PLUS_UBOOT)
+
+__dir := $(shell mkdir -p spl/$(CONFIG_SPL_START_S_PATH:"%"=%))
+
+ifdef CONFIG_DDR_TUNING_SEPARATE
+include $(srctree)/board/$(BOARDDIR)/Makefile.externddr
+endif
+
+ifdef CONFIG_BOOT_FROM_SPI
+include $(srctree)/board/$(BOARDDIR)/Makefile.sf
+endif
+
+ifdef CONFIG_BOOT_FROM_QSPI_NOR
+include $(srctree)/board/$(BOARDDIR)/Makefile.sf
+endif
+
+ifdef CONFIG_BOOT_FROM_QSPI_NAND
+include $(srctree)/board/$(BOARDDIR)/Makefile.nand
+endif
+
+ifdef CONFIG_BOOT_FROM_NAND
+include $(srctree)/board/$(BOARDDIR)/Makefile.nand
+endif
+
+ifdef CONFIG_BOOT_FROM_EMMC
+include $(srctree)/board/$(BOARDDIR)/Makefile.emmc
+endif
+
+ifdef CONFIG_BOOT_FROM_MEM
+include $(srctree)/board/$(BOARDDIR)/Makefile.mem
+endif
+endif # CONFIG_VENDOR_MAXLINEAR
+
 ifdef CONFIG_TPL_BUILD
 INPUTS-$(CONFIG_TPL_X86_16BIT_INIT) += $(obj)/u-boot-x86-start16-tpl.bin \
 	$(obj)/u-boot-x86-reset16-tpl.bin
